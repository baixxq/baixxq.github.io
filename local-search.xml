<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Zookeeper笔记</title>
    <link href="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第1-章-Zookeeper-入门"><a href="#第1-章-Zookeeper-入门" class="headerlink" title="第1 章 Zookeeper 入门"></a>第1 章 Zookeeper 入门</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的Apache 项目。</p><p><strong>Zookeeper工作机制</strong></p><p>Zookeeper从设计模式角度来理解：是一个基于<strong>观察者模式</strong>设计的<strong>分布式</strong>服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><ul><li><p>Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。</p></li><li><p>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。</p></li><li><p>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</p></li><li><p>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。</p></li><li><p>数据更新原子性，一次数据更新要么成功，要么失败。</p></li><li><p>实时性，在一定时间范围内，Client能读到最新数据。</p></li></ul><h3 id="1-3-数据结构"><a href="#1-3-数据结构" class="headerlink" title="1.3 数据结构"></a>1.3 数据结构</h3><p>ZooKeeper 数据模型的结构与Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode 默认能够存储1MB 的数据(不能存储海量数据)，每个ZNode 都可以通过其路径唯一标识。</p><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429105725581.png" alt="image-20220429105725581"></p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><ol><li>统一命名服务</li></ol><ul><li>在分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。</li></ul><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429124109629.png" alt="image-20220429124109629"></p><ol start="2"><li>统一配置管理</li></ol><ul><li><p>分布式环境下，配置文件同步非常常见。</p><p>（1）一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka 集群。</p><p>（2）对配置文件修改后，希望能够快速同步到各个节点上。</p></li><li><p>配置管理可交由ZooKeeper实现。</p><p>（1）可将配置信息写入ZooKeeper上的一个Znode。</p><p>（2）各个客户端服务器监听这个Znode。</p><p>（3）一旦Znode中的数据被修改，ZooKeeper将通知各个客户端服务器。</p></li></ul><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429124539314.png" alt="image-20220429124539314"></p><ol start="3"><li>统一集群管理</li></ol><ul><li><p>分布式环境中，实时掌握每个节点的状态是必要的。</p><p>（1）可根据节点实时状态做出一些调整。</p></li><li><p>ZooKeeper可以实现实时监控节点状态变化</p><p>（1）可将节点信息写入ZooKeeper上的一个ZNode。</p><p>（2）监听这个ZNode可获取它的实时状态变化。</p></li></ul><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429124832277.png" alt="image-20220429124832277"></p><ol start="4"><li>服务器动态上下线</li></ol><ul><li>客户端能实时洞察到服务器上下线的变化</li></ul><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429124959856.png" alt="image-20220429124959856"></p><ol start="5"><li>软负载均衡</li></ol><ul><li>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</li></ul><p><img src="/2022/04/29/Zookeeper%E7%AC%94%E8%AE%B0/image-20220429125057897.png" alt="image-20220429125057897"></p><h2 id="第2章-Zookeeper本地安装"><a href="#第2章-Zookeeper本地安装" class="headerlink" title="第2章 Zookeeper本地安装"></a>第2章 Zookeeper本地安装</h2><h3 id="2-1-本地模式-安装"><a href="#2-1-本地模式-安装" class="headerlink" title="2.1 本地模式 安装"></a>2.1 本地模式 安装</h3><p>官网下载地址：</p><p><a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selecr,poll,epoll模型</title>
    <link href="/2022/04/28/epoll/"/>
    <url>/2022/04/28/epoll/</url>
    
    <content type="html"><![CDATA[<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="/2022/04/28/epoll/img%5Cpassage_photo%5Cselect.jpg" alt="select"></p><p>fd[i] 监听socket编号，有就把相应的编号加入，rset对应的是fd_set，是一个bitMap类型，最默认1024</p><p>同时有一个max最大编号</p><p>fd_set数据结构定义如下，可以看出fd_set是一个整型<strong>数组</strong>，用于保存socket文件描述符</p><ol><li>用户线程调用select，将fd_set从用户空间拷贝到内核空间 </li><li>内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符</li><li>内核返回select的结果给用户线程，即就绪的文件描述符数量  </li><li>用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符</li><li>用户线程对就绪的文件描述符进行读写操作</li></ol><p>缺点</p><p>每次调用select，都需要将fd_set从用户空间拷贝到内核空间，当fd很多时，这个开销很大</p><p>最大连接数（支持的最大文件描述符数量）有限制，一般为1024</p><p>每次有活跃的socket描述符时，都需要遍历一次fd_set，造成大量的时间开销，时间复杂度是O(n)</p><p>将fd_set从用户空间拷贝到内核空间，内核空间也需要对fd_set遍历一遍</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC笔记整理</title>
    <link href="/2022/04/28/JDBC%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/28/JDBC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、JDBC："><a href="#一、JDBC：" class="headerlink" title="一、JDBC："></a>一、JDBC：</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</p><p>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><h4 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><p>步骤：</p><p>(1) 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar（&#x3D;&#x3D;不同的Java版本导入不同的jar包&#x3D;&#x3D;）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>复制mysql-connector-java-<span class="hljs-number">5.1</span><span class="hljs-number">.37</span>-bin.jar到项目的libs目录下<br><span class="hljs-number">2.</span>右键--&gt;Add As Library<br></code></pre></div></td></tr></table></figure><p>(2) 注册驱动</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);java-<span class="hljs-number">5.1</span><span class="hljs-number">.37</span><br></code></pre></div></td></tr></table></figure><p>(3) 获取数据库连接对象 Connection</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>(4) 定义sql</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set balance = 500 where id = 1&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>(5) 获取执行sql语句的对象 Statement </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br></code></pre></div></td></tr></table></figure><p>(6) 执行sql，接受返回结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<br></code></pre></div></td></tr></table></figure><p>(7) 处理结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(count);<br></code></pre></div></td></tr></table></figure><p>(8) 释放资源    注意空指针异常</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">stmt.close();     先释放<br>conn.close();<br></code></pre></div></td></tr></table></figure><h4 id="3-详解各个对象"><a href="#3-详解各个对象" class="headerlink" title="3.详解各个对象"></a>3.详解各个对象</h4><h5 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="(1) DriverManager：驱动管理对象"></a>(1) DriverManager：驱动管理对象</h5><p>功能：</p><p>①.注册驱动：告诉程序该使用哪一个数据库驱动jar</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDriver</span><span class="hljs-params">(Driver driver)</span> :注册与给定的驱动程序 DriverManager 。 <br>写代码使用：  Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块<br> <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p><p>②.获取数据库连接：</p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String url, String user, String password)</span> <br></code></pre></div></td></tr></table></figure><p>参数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">url：指定连接的路径<br>user：用户名<br>password：密码 <br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">语法：jdbc:mysql:<span class="hljs-comment">//ip地址(域名):端口号/数据库名称</span><br>例子：jdbc:mysql:<span class="hljs-comment">//localhost:3306/db3</span><br></code></pre></div></td></tr></table></figure><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</p><h5 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="(2) Connection：数据库连接对象"></a>(2) Connection：数据库连接对象</h5><p>功能：</p><p>① 获取执行sql 的对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span><br>PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql)</span>  <br></code></pre></div></td></tr></table></figure><p>② 管理事务：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">开启事务：setAutoCommit(<span class="hljs-type">boolean</span> autoCommit) ：调用该方法设置参数为<span class="hljs-literal">false</span>，即开启事务<br>提交事务：commit() <br>回滚事务：rollback() <br></code></pre></div></td></tr></table></figure><h5 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="(3) Statement：执行sql的对象"></a>(3) Statement：执行sql的对象</h5><p>① 执行sql</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String sql)</span> ：可以执行任意的sql  不常用<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(String sql)</span> ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句<br>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;<span class="hljs-number">0</span>的则执行成功，反之，则失败。<br><br>ResultSet <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String sql)</span>  ：执行DQL（select)语句<br></code></pre></div></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//1. 注册驱动</span><br>       Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>       <span class="hljs-comment">//2. 定义sql</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;</span>;<br>       <span class="hljs-comment">//3.获取Connection对象</span><br>       conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:///db3&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>       <span class="hljs-comment">//4.获取执行sql的对象 Statement</span><br>       stmt = conn.createStatement();<br>       <span class="hljs-comment">//5.执行sql</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//影响的行数</span><br>       <span class="hljs-comment">//6.处理结果</span><br>       System.out.println(count);<br>       <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>           System.out.println(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;添加失败！&quot;</span>);<br>       &#125;<br><br>   &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>       e.printStackTrace();<br>   &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>       e.printStackTrace();<br>   &#125;<span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">//stmt.close();</span><br>       <span class="hljs-comment">//7. 释放资源</span><br>       <span class="hljs-comment">//避免空指针异常</span><br>       <span class="hljs-keyword">if</span>(stmt != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               stmt.close();<br>           &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               conn.close();<br>           &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></div></td></tr></table></figure><p>② ResultSet：结果集对象,封装查询结果</p><p>方法:</p><p>boolean next()</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回<span class="hljs-literal">false</span>，如果不是则返回<span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><p>getXxx(参数):获取数据</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Xxx：代表数据类型   如： <span class="hljs-type">int</span> <span class="hljs-title function_">getInt</span><span class="hljs-params">()</span> ,String <span class="hljs-title function_">getString</span><span class="hljs-params">()</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">参数：<br><span class="hljs-type">int</span>：代表列的编号,从<span class="hljs-number">1</span>开始   如： getString(<span class="hljs-number">1</span>)<br>String：代表列名称。 如： getDouble(<span class="hljs-string">&quot;balance&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>使用步骤：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>游标向下移动一行<br><span class="hljs-number">2.</span>判断是否有数据<br><span class="hljs-number">3.</span>获取数据<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//循环判断游标是否是最后一行末尾。</span><br>    <span class="hljs-keyword">while</span>(rs.next())&#123;<br>        <span class="hljs-comment">//获取数据</span><br>        <span class="hljs-comment">//6.2 获取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-number">3</span>);<br>       System.out.println(id + <span class="hljs-string">&quot;---&quot;</span> + name + <span class="hljs-string">&quot;---&quot;</span> + balance);<br>   &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-PreparedStatement：执行sql的对象"><a href="#4-PreparedStatement：执行sql的对象" class="headerlink" title="(4) PreparedStatement：执行sql的对象"></a>(4) PreparedStatement：执行sql的对象</h5><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">比如：输入用户随便，输入密码：a<span class="hljs-string">&#x27; or &#x27;</span>a<span class="hljs-string">&#x27; = &#x27;</span>a<br><span class="hljs-keyword">sql</span>：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;fhdsjkf&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> <br></code></pre></div></td></tr></table></figure><p>解决sql注入问题：使用PreparedStatement对象来解决</p><p>&#x3D;&#x3D;预编译的SQL&#x3D;&#x3D;：参数使用?作为占位符</p><p>步骤：</p><ol><li><p>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p></li><li><p>注册驱动</p></li><li><p>获取数据库连接对象 Connection</p></li><li><p>&#x3D;&#x3D;定义sql&#x3D;&#x3D;</p> <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">注意：<span class="hljs-keyword">sql</span>的参数使用？作为占位符<br>如：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username = ? <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span> = ?;<br></code></pre></div></td></tr></table></figure></li><li><p>&#x3D;&#x3D;获取执行sql语句的对象 PreparedStatement&#x3D;&#x3D; </p> <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Connection</span>.</span></span>prepare<span class="hljs-constructor">Statement(String <span class="hljs-params">sql</span>)</span> <br></code></pre></div></td></tr></table></figure></li><li><p>&#x3D;&#x3D;给？赋值&#x3D;&#x3D;：</p> <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">方法： setXxx(参数1,参数2)<br><span class="hljs-bullet">*</span> 参数1：？的位置编号 从1 开始<br><span class="hljs-bullet">*</span> 参数2：？的值<br></code></pre></div></td></tr></table></figure></li><li><p>执行sql，接受返回结果，不需要传递sql语句</p></li><li><p>处理结果</p></li><li><p>释放资源</p></li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users where usernames =? and passwords =?&quot;</span>;<br><span class="hljs-comment">//获取执行sql的语句的对象</span><br>            <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> con.prepareStatement(sql);<br><span class="hljs-comment">//设置值</span><br>            preparedStatement.setString(<span class="hljs-number">1</span>,username);<br>            preparedStatement.setString(<span class="hljs-number">2</span>,password);<br>            System.out.println(sql);<br><span class="hljs-comment">//不需要传递sql</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br></code></pre></div></td></tr></table></figure><p>&#x3D;&#x3D;后期都会使用PreparedStatement来完成增删改查的所有操作&#x3D;&#x3D;，好处：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">可以防止<span class="hljs-keyword">SQL</span>注入<br>效率更高<br></code></pre></div></td></tr></table></figure><h4 id="4-抽取JDBC工具类-：-JDBCUtils"><a href="#4-抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="4.抽取JDBC工具类 ： JDBCUtils"></a>4.抽取JDBC工具类 ： JDBCUtils</h4><p>目的：简化书写</p><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> 注册驱动也抽取<br><span class="hljs-number">2.</span> 抽取一个方法获取连接对象<br>* 需求：不想传递参数（麻烦），还得保证工具类的通用性。<br>* 解决：配置文件<br>jdbc.properties<br>url=<br>user=<br>password=<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">3.</span> 抽取一个方法释放资源<br><br>* 代码实现：<br><span class="hljs-comment">/*--------------------------------------------------------------*/</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//读取资源文件，获取值。</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 创建Properties集合类。</span><br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><br>            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> JDBCUtils.class.getClassLoader();<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">res</span>  <span class="hljs-operator">=</span> classLoader.getResource(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> res.getPath();  <br>            <br>            System.out.println(path);<br>            <span class="hljs-comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br>            <br>            <span class="hljs-comment">//2. 加载文件</span><br>           <span class="hljs-comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br>            pro.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br><br>            <span class="hljs-comment">//3. 获取数据，赋值</span><br>            url = pro.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            user = pro.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            password = pro.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            driver = pro.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            <span class="hljs-comment">//4. 注册驱动</span><br>            Class.forName(driver);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>        <br><span class="hljs-comment">/*-----------------------------获取连接---------------------------------*/</span> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;   <br><span class="hljs-comment">/*-----------------------------释放资源---------------------------------*/</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span>&#123;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>对于ResultSet结果集对象，释放资源</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stmt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet rs,Statement stmt, Connection conn)</span>&#123;<br>        <span class="hljs-keyword">if</span>( rs != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( conn != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​</p><p>例子</p><p>​需求：</p><p>(1) 通过键盘录入用户名和密码</p><p>(2) 判断用户是否登录成功</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">select * from user <span class="hljs-type">where</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-type">and</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>如果这个sql有查询结果，则成功，反之，则失败<br></code></pre></div></td></tr></table></figure><p>步骤：</p><p>(1) 创建数据库表 user</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CREATE TABLE <span class="hljs-title function_">USER</span><span class="hljs-params">(</span><br><span class="hljs-params">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="hljs-params">username VARCHAR(<span class="hljs-number">32</span>)</span>,<br>PASSWORD <span class="hljs-title function_">VARCHAR</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span><br><br>);<br>INSERT INTO USER <span class="hljs-title function_">VALUES</span><span class="hljs-params">(NULL,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>)</span>;<br>INSERT INTO USER <span class="hljs-title function_">VALUES</span><span class="hljs-params">(NULL,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;234&#x27;</span>)</span>;<br></code></pre></div></td></tr></table></figure><p>(2) 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCDemo9</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.键盘录入，接受用户名和密码</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入用户名：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;请输入密码：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        <span class="hljs-comment">//2.调用方法</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JDBCDemo9</span>().login(username, password);<br>        <span class="hljs-comment">//3.判断结果，输出不同语句</span><br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-comment">//登录成功</span><br>            System.out.println(<span class="hljs-string">&quot;登录成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;用户名或密码错误！&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>登录方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username ,String password)</span>&#123;<br>        <span class="hljs-keyword">if</span>(username == <span class="hljs-literal">null</span> || password == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//连接数据库判断是否登录成功</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span>  <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//1.获取连接</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn =  JDBCUtils.getConnection();<br>            <span class="hljs-comment">//2.定义sql</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where username = &#x27;&quot;</span>+username+<span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span>+password+<span class="hljs-string">&quot;&#x27; &quot;</span>;<br>            <span class="hljs-comment">//3.获取执行sql的对象</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">//4.执行查询</span><br>            rs = stmt.executeQuery(sql);<br>            <span class="hljs-comment">//5.判断</span><br>           <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;else&#123;</span><br><span class="hljs-comment">                return false;</span><br><span class="hljs-comment">            &#125;*/</span><br>           <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.close(rs,stmt,conn);<br>        &#125;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​</p><h4 id="5-JDBC控制事务"><a href="#5-JDBC控制事务" class="headerlink" title="5.JDBC控制事务"></a>5.JDBC控制事务</h4><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p><p>操作：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 开启事务<br><span class="hljs-bullet">2.</span> 提交事务<br><span class="hljs-bullet">3.</span> 回滚事务<br></code></pre></div></td></tr></table></figure><p>使用Connection对象来管理事务</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">* 开启事务：setAutoCommit(<span class="hljs-type">boolean</span> autoCommit) ：调用该方法设置参数为<span class="hljs-literal">false</span>，即开启事务<br>* 在执行sql之前开启事务<br>* 提交事务：commit() <br>* 当所有sql都执行完提交事务<br>* 回滚事务：rollback() <br>* 在<span class="hljs-keyword">catch</span>中回滚事务<br></code></pre></div></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCDemo10</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.获取连接</span><br>            conn = JDBCUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-comment">//2.定义sql</span><br>            <span class="hljs-comment">//2.1 张三 - 500</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//2.2 李四 + 500</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;<br>            <span class="hljs-comment">//3.获取执行sql对象</span><br>            pstmt1 = conn.prepareStatement(sql1);<br>            pstmt2 = conn.prepareStatement(sql2);<br>            <span class="hljs-comment">//4. 设置参数</span><br>            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br>            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br>            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//5.执行sql</span><br>            pstmt1.executeUpdate();<br>            <span class="hljs-comment">// 手动制造异常</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br><br>            pstmt2.executeUpdate();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//事务回滚</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//判断空再回滚</span><br>                <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>) &#123;<br>                    conn.rollback();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JDBCUtils.close(pstmt1,conn);<br>            JDBCUtils.close(pstmt2,<span class="hljs-literal">null</span>);<br>        &#125;<br> &#125;<br>&#125;       <br></code></pre></div></td></tr></table></figure><h4 id="6-数据库连接池"><a href="#6-数据库连接池" class="headerlink" title="6.数据库连接池"></a>6.数据库连接池</h4><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><p>​    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p><p>好处：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.节约资源<br>2.用户访问高效<br></code></pre></div></td></tr></table></figure><p>实现方式</p><p>标准接口：DataSource   javax.sql包下的，sun公司并没有实现具体的方法，而是交给了提供驱动的数据厂商来实现</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.C3P0技术：数据库连接池技术<br>2.Druid：由阿里提供的数据库连接池技术<br></code></pre></div></td></tr></table></figure><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">获取连接：getConnection()<br>归还连接：Connection.close()     <span class="hljs-comment">//只归还，不关闭</span><br>如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接<br></code></pre></div></td></tr></table></figure><h5 id="1-C3P0数据库连接池技术"><a href="#1-C3P0数据库连接池技术" class="headerlink" title="(1) C3P0数据库连接池技术"></a>(1) C3P0数据库连接池技术</h5><p>步骤：</p><ol><li><p>导入jar包 (两个) 项目下libs</p> <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">c3p0</span>-<span class="hljs-number">0.9.5.2</span>.jar <br><span class="hljs-attribute">mchange</span>-commons-java-<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">12</span>.jar        <br><span class="hljs-attribute">mysql</span>-connector-java-<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">37</span>-bin.jar不要忘记导入数据库驱动jar包!!!!!!<br></code></pre></div></td></tr></table></figure></li><li><p>定义配置文件：</p> <figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">名称： c3p0.properties 或者 c3p0-config.xml<br>路径： 直接将文件放在src目录下即可。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">default-config</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  连接参数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/db3<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 连接池参数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">default-config</span>&gt;</span><br> <br> <br> 采用有参构造！<br>  <span class="hljs-tag">&lt;<span class="hljs-name">named-config</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;otherc3p0&quot;</span>&gt;</span> <br>  ..............<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">named-config</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>定义配置文件：创建核心对象 数据库连接池对象 ComboPooledDataSource</p> <figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">//创建数据库连接池对象</span><br>      DataSource ds  = <span class="hljs-keyword">new</span> <span class="hljs-type">ComboPooledDataSource</span>();<br></code></pre></div></td></tr></table></figure></li><li><p>获取连接： getConnection</p> <figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">//获取连接对象<br>       Connection conn <span class="hljs-operator">=</span> ds.getConnection()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure></li></ol><h5 id="2-Druid数据库连接池技术"><a href="#2-Druid数据库连接池技术" class="headerlink" title="(2) Druid数据库连接池技术"></a>(2) Druid数据库连接池技术</h5><p>步骤：</p><ol><li><p>导入jar包 </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">druid</span>-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span>.jar   项目下libs<br><span class="hljs-attribute">mysql</span>-connector-java-<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">37</span>-bin.jar不要忘记导入数据库驱动jar包!!!!!!<br></code></pre></div></td></tr></table></figure></li><li><p>定义配置文件：</p> <figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">是<span class="hljs-keyword">properties</span>形式的<br>可以叫任意名称，可以放在任意目录下，需要手动加载<br></code></pre></div></td></tr></table></figure></li><li><p>加载配置文件 Properties</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//3.加载配置文件</span><br> Properties pro = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Properties()</span>;<br> InputStream is = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DruidDemo</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>)</span>;<br> pro.load(is);<br></code></pre></div></td></tr></table></figure></li><li><p>获取数据库连接池对象</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">通过工厂来来获取  DruidDataSourceFactory<br><span class="hljs-comment">//4.获取连接池对象</span><br> DataSource ds = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DruidDataSourceFactory</span>.</span></span>create<span class="hljs-constructor">DataSource(<span class="hljs-params">pro</span>)</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">getConnection<br> //<span class="hljs-number">5</span>.获取连接<br> Connection conn <span class="hljs-operator">=</span> ds.getConnection()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure></li></ol><h5 id="3-Druid工具类"><a href="#3-Druid工具类" class="headerlink" title="(3) Druid工具类"></a>(3) Druid工具类</h5><p>JDBCUtils工具类</p><ol><li><p>提供静态代码块加载配置文件，初始化连接池对象</p></li><li><p>提供方法</p></li></ol>  <figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">获取连接方法：通过数据库连接池获取连接<br>获取连接池的方法<br>释放资源<br></code></pre></div></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtils</span> &#123;    <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;    <span class="hljs-comment">//1.定义成员变量 DataSource</span><br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载配置文件</span><br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>));<br>            <span class="hljs-comment">//2.获取DataSource</span><br>            ds = DruidDataSourceFactory.createDataSource(pro);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span>&#123;<br>       close(<span class="hljs-literal">null</span>,stmt,conn);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span>&#123;<br>          <span class="hljs-keyword">if</span>(rs != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>      <span class="hljs-keyword">if</span>(stmt != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>&#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br><br>&#125;      <br></code></pre></div></td></tr></table></figure><p>使用工具类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JDBCUtils.getConnection();<br>   <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from employee&quot;</span>;<br>   <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>   <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br></code></pre></div></td></tr></table></figure><h4 id="7-Spring-JDBC"><a href="#7-Spring-JDBC" class="headerlink" title="7.Spring JDBC"></a>7.Spring JDBC</h4><p> Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p><p>步骤：</p><ol><li><p>导入jar包   </p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">五个Spring jar包<br>spring-tx-<span class="hljs-number">5.2</span>.<span class="hljs-number">16</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>spring-jdbc-<span class="hljs-number">5.2</span>.<span class="hljs-number">16</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>spring-jcl-<span class="hljs-number">5.2</span>.<span class="hljs-number">16</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>spring-core-<span class="hljs-number">5.2</span>.<span class="hljs-number">16</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>spring-beans-<span class="hljs-number">5.2</span>.<span class="hljs-number">16</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><br>两个数据库连接池jar包<br>druid-<span class="hljs-number">1.2</span>.<span class="hljs-number">8</span><span class="hljs-selector-class">.jar</span><br>mysql-connector-java-<span class="hljs-number">8.0</span>.<span class="hljs-number">27</span>.jar<br></code></pre></div></td></tr></table></figure></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">ds用的上边<span class="hljs-keyword">JDBCUtils的方法，其中 </span> ds为DataSource<br>用到了<span class="hljs-keyword">JDBCUtils </span>，所以要有配置文件<br><br><span class="hljs-keyword">JdbcTemplate </span>template = new <span class="hljs-keyword">JdbcTemplate(ds);</span><br></code></pre></div></td></tr></table></figure></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><p>① update():</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">执行DML语句。增、删、改语句<br></code></pre></div></td></tr></table></figure><p>② queryForMap():</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">查询结果将结果集封装为<span class="hljs-built_in">map</span>集合，将列名作为<span class="hljs-built_in">key</span>，将值作为value.将这条记录封装为一个<span class="hljs-built_in">map</span>集合<br>注意：这个方法查询的结果集长度只能是<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>③ queryForList():</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica">查询结果将结果集封装为<span class="hljs-variable">list</span>集合<br>注意：将每一条记录封装为一个<span class="hljs-built_in">Map</span>集合，再将<span class="hljs-built_in">Map</span>集合装载到<span class="hljs-built_in">List</span>集合中<br></code></pre></div></td></tr></table></figure><p>④ query():</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">查询结果，将结果封装为JavaBean对象<br>query的参数：RowMapper<br>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">BeanPropertyRowMapper</span>&lt;类型&gt;(类型.<span class="hljs-keyword">class</span>)<br></code></pre></div></td></tr></table></figure><p>queryForObject：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">查询结果，将结果封装为对象<br><span class="hljs-bullet">* </span>一般用于聚合函数的查询<br></code></pre></div></td></tr></table></figure></li></ol><p>例如：</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica">修改<span class="hljs-number">1</span>号数据的 <span class="hljs-variable">salary</span> 为 <span class="hljs-number">10000</span><br>添加一条记录<br>删除刚才添加的记录<br>查询<span class="hljs-variable">id</span>为<span class="hljs-number">1</span>的记录，将其封装为<span class="hljs-built_in">Map</span>集合<br>查询所有记录，将其封装为<span class="hljs-built_in">List</span><br>查询所有记录，将其封装为<span class="hljs-variable">Emp</span>对象的<span class="hljs-built_in">List</span>集合<br>查询总记录数<br></code></pre></div></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.itcast.domain.Emp;<br><span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><br><span class="hljs-keyword">import</span> java.sql.Date;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTemplateDemo2</span> &#123;<br>       <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span><br>        <span class="hljs-comment">//1. 获取JDBCTemplate对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//2. 定义sql</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.update(sql);<br>        System.out.println(count);<br>  &#125;<br>    <br>    <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-comment">//2. 定义sql</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update emp set salary = 10000 where id = 1001&quot;</span>;<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.update(sql);<br>        System.out.println(count);<br>    &#125;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 添加一条记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">&quot;郭靖&quot;</span>, <span class="hljs-number">10</span>);<br>        System.out.println(count);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3.删除刚才添加的记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from emp where id = ?&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.update(sql, <span class="hljs-number">1015</span>);<br>        System.out.println(count);<br>    &#125;  <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="hljs-comment">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="hljs-comment">     例子会报错，应该只查询一个</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp where id = ? or id = ?&quot;</span>;<br>        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br>    &#125;<br>    <br>    <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 5. 查询所有记录，将其封装为List</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);<br><br>        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;<br>            System.out.println(stringObjectMap);<br>        &#125;<br>    &#125;<br>    <br>    <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合，要实现RowMapper，我们一般用BeanPropertyRowMapper</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowMapper</span>&lt;Emp&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>                <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ename</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;ename&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">job_id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;job_id&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;mgr&quot;</span>);<br>                <span class="hljs-type">Date</span> <span class="hljs-variable">joindate</span> <span class="hljs-operator">=</span> rs.getDate(<span class="hljs-string">&quot;joindate&quot;</span>);<br>                <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>);<br>                <span class="hljs-type">double</span> <span class="hljs-variable">bonus</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;bonus&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;dept_id&quot;</span>);<br><br>                emp.setId(id);<br>                emp.setEname(ename);<br>                emp.setJob_id(job_id);<br>                emp.setMgr(mgr);<br>                emp.setJoindate(joindate);<br>                emp.setSalary(salary);<br>                emp.setBonus(bonus);<br>                emp.setDept_id(dept_id);<br><br>                <span class="hljs-keyword">return</span> emp;<br>            &#125;<br>        &#125;);<br>        <br>             <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6_2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp&quot;</span>;<br>List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;Emp&gt;(Emp.class));<br>        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;<br>            System.out.println(emp);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 7. 查询总记录数</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test7</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select count(id) from emp&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> template.queryForObject(sql, Long.class);<br>        System.out.println(total);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git工具的使用</title>
    <link href="/2022/04/28/git/"/>
    <url>/2022/04/28/git/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p><p>多人开发就必须要使用版本控制！</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p><p>主流的版本控制器有如下这些：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><strong>2、集中版本控制  SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制 Git</strong></p><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><p>&#x3D;&#x3D;Git是目前世界上最先进的分布式版本控制系统。&#x3D;&#x3D;</p><p><strong>Git的历史</strong></p><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录    cd ~ 推出到开头</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf / 切勿在Linux中尝试！删除电脑中全部文件！<br></code></pre></div></td></tr></table></figure><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端&#x2F;清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><p>查看配置 git config -l</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>查看不同级别的配置文件：</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">#查看系统<span class="hljs-built_in">config</span> git <span class="hljs-built_in">config</span> <span class="hljs-comment">--system --list　</span><br>#查看当前用户（global）配置git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global  --list</span><br></code></pre></div></td></tr></table></figure><p><strong>Git相关的配置文件：</strong></p><p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p><p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><h2 id="x3D-x3D-设置用户名与邮箱（用户标识，必要）-x3D-x3D"><a href="#x3D-x3D-设置用户名与邮箱（用户标识，必要）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;设置用户名与邮箱（用户标识，必要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;设置用户名与邮箱（用户标识，必要）&#x3D;&#x3D;</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;kuangshen&quot;</span>  #名称git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-number">24736743</span>@qq<span class="hljs-selector-class">.com</span>   #邮箱<br></code></pre></div></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0zQZY37q1iaG0n7445X8YgPVvZH5AqyGvT4RgmoyIcZlJWiaLcxyDgSdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Git基本理论（重要）</p><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>Git项目搭建</p><h2 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h2><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><h2 id><a href="#" class="headerlink" title="- "></a>- </h2><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-meta"># 在当前目录新建一个Git代码库$ git init</span><br></code></pre></div></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><h2 id="-1"><a href="#-1" class="headerlink" title="- "></a>- </h2><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"># 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]  # https:<span class="hljs-comment">//gitee.com/kuangstudy/openclass.git</span><br></code></pre></div></td></tr></table></figure><p>2、去 gitee 或者 github 上克隆一个测试！</p><p>Git文件操作</p><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">#查看指定文件状态git status [filename]<br>#查看所有文件状态git status<br># git add .                  添加所有文件到暂存区# git commit -m <span class="hljs-string">&quot;消息内容&quot;</span>    提交暂存区中的内容到本地仓库 -m 提交信息<br></code></pre></div></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">#为注释*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外<span class="hljs-regexp">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/</span>       #忽略build<span class="hljs-regexp">/目录下的所有文件doc/</span>*.txt    #会忽略 doc<span class="hljs-regexp">/notes.txt 但不包括 doc/</span>server/arch.txt<br></code></pre></div></td></tr></table></figure><p>Github配置教程</p><p>1.ssh-keygen -t rsa</p><p>2.配置代理服务器  </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git config --global http.proxy 127.0.0.1:7890<br>git config --local http.proxy 127.0.0.1:7890<br></code></pre></div></td></tr></table></figure><p>3.故障排除</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T -p 443 git@ssh.github.com</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hi username! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">provide shell access.</span></span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hi username! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">provide shell access.</span></span><br></code></pre></div></td></tr></table></figure><p>4.解除ssl验证</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git config --global http.sslVerify &quot;false&quot;<br></code></pre></div></td></tr></table></figure><p>使用码云</p><h2 id="github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器"><a href="#github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器" class="headerlink" title="github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器"></a>github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p><p>1、注册登录码云，完善个人信息</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ebAqhteskG4GHwD01bX4lXYmxlmMGn8PRqn4aCXfaQdp3SnbBHdibtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"># 进入 C:\Users\Administrator\.ssh 目录# 生成公钥ssh-keygen<br></code></pre></div></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3、将公钥信息public key 添加到码云账户中即可！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0I5Zicrm4PEbnox9L5wjCPtPybCyrKI1JOkRWCYIY5zsX4FvI77LXXmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>4、使用码云创建一个自己的仓库！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0FSIwJb9g6Qbp99jY605xdPfh3N4l2rGpD44d6NCcdibankBUL60uODg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0S96XfGogNWVqRAexeybT7DXdyQhfcYJ1oEAgaH1RibRU0WZE0eczdxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>克隆到本地！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0PyKfGFd8UHSGIRbVLkXH5icQsgxh6K2RPibYeUER54UzuNVAYsgxXcfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>IDEA中集成Git</p><p>1、新建项目，绑定git。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>注意观察idea中的变化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>2、修改文件，使用IDEA操作git。</p><ul><li>添加到暂存区</li><li>commit 提交</li><li>push到远程仓库</li></ul><p>3、提交测试</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这些都是单个人的操作！</p><p>学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）</p><p>有道无术、术尚可求。有术无道、止于术！</p><p>真正的教学，授人以渔！</p><h2 id="说明：GIT分支"><a href="#说明：GIT分支" class="headerlink" title="说明：GIT分支"></a>说明：GIT分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>git分支中常用指令：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 列出所有本地分支git branch</span><br><span class="hljs-comment"># 列出所有远程分支git branch -r</span><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支git branch [branch-name]</span><br><span class="hljs-comment"># 新建一个分支，并切换到该分支git checkout -b [branch]</span><br><span class="hljs-comment"># 合并指定分支到当前分支$ git merge [branch]</span><br><span class="hljs-comment"># 删除分支$ git branch -d [branch-name]</span><br><span class="hljs-comment"># 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</span><br></code></pre></div></td></tr></table></figure><p>IDEA中操作</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！</p><p>1、不要把Git想的很难，工作中多练习使用就自然而然的会了！</p><p>2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！</p>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java垃圾回收</title>
    <link href="/2022/04/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/04/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h3><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有那些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/29176325.jpg" alt="img"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1 揭开 JVM 内存分配与回收的神秘面纱"></a>1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="img"></p><p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到年老代中。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%A0%86%E5%86%85%E5%AD%98.jpg" alt="堆内存常见分配策略 "></p><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC&#x2F;Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">byte</span>[] allocation1, allocation2;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">30900</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//allocation2 = new byte[900*1024];</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过以下方式运行：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/25178350.jpg" alt="img"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/10317146.jpg" alt="img"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg" alt="img"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">900</span>*<span class="hljs-number">1024</span>];<br></code></pre></div></td></tr></table></figure><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg" alt="img"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">32000</span>*<span class="hljs-number">1024</span>];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>        allocation5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1000</span>*<span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/11034259.jpg" alt="img"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        <span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-literal">null</span>;<br>        objB = <span class="hljs-literal">null</span>;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg" alt="可达性分析算法 "></p><p>​<strong>可达性分析算法</strong></p><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量"><a href="#2-5-如何判断一个常量是废弃常量" class="headerlink" title="2.5 如何判断一个常量是废弃常量"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p>注意：我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd">可能是把 Java 内存区域讲的最清楚的一篇文章 </a>也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.jpg" alt="垃圾收集算法分类"></p><p>​<strong>垃圾收集算法分类</strong></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg" alt="公众号"></p><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg" alt="公众号"></p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg" alt="标记-整理算法 "></p><p>​<strong>标记-整理算法</strong></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器分类"></p><p>​<strong>垃圾收集器分类</strong></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><u><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></u></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/46873026.jpg" alt=" Serial 收集器 "></p><p>​<strong>Serial 收集器</strong></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg" alt="ParNew 收集器 "></p><p>​<strong>ParNew 收集器</strong></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span> <br><br>    使用 Parallel 收集器+ 老年代串行<br><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelOldGC</span><br><br>    使用 Parallel 收集器+ 老年代并行<br></code></pre></div></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg" alt="Parallel Scavenge 收集器 "></p><p>​<strong>Parallel Scavenge 收集器</strong></p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg" alt="CMS 垃圾收集器 "></p><p>​<strong>CMS 垃圾收集器</strong></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p>**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾回收</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库学习</title>
    <link href="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据库的基础知识"><a href="#一、数据库的基础知识" class="headerlink" title="一、数据库的基础知识"></a>一、数据库的基础知识</h2><h3 id="1-1数据库作用"><a href="#1-1数据库作用" class="headerlink" title="1.1数据库作用"></a>1.1数据库作用</h3><p>数据库（database） 保存有组织的数据的容器  </p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.实现数据的完整化<br>2.便于操作和管理<br></code></pre></div></td></tr></table></figure><blockquote><p>人们通常用数据库这个术语来代表他们使用的数据库软件。这是不正确的，确切地说，数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。数据库可以是保存在硬设备上的文件，但也可以不是。在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库  </p></blockquote><h3 id="1-2DB、DBMS、SQL关系"><a href="#1-2DB、DBMS、SQL关系" class="headerlink" title="1.2DB、DBMS、SQL关系"></a>1.2DB、DBMS、SQL关系</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>数据库 (<span class="hljs-keyword">Database</span>):存储数据的仓库，保存一系列有组织的数据<br><span class="hljs-number">2.</span>数据库管理系统（<span class="hljs-keyword">Database</span> Management <span class="hljs-keyword">System</span>）：数据库是通过DBMS创建和操作的，常见的数据库管理系统有MySQL、Oracle、DB2、SqlServer<br><span class="hljs-number">3.</span>结构化查询语言（Structure Query <span class="hljs-keyword">Language</span>）:专门用来和数据库通信的语言，大部分DBMS都支持<span class="hljs-keyword">SQL</span><br> DBA    —————<span class="hljs-keyword">SQL</span>语言—————     DBMS    —————<span class="hljs-keyword">SQL</span>语言———————    DB   <br></code></pre></div></td></tr></table></figure><p>数据库管理员（Database Administrator，简称DBA）</p><h3 id="1-3数据库存储数据的特点"><a href="#1-3数据库存储数据的特点" class="headerlink" title="1.3数据库存储数据的特点"></a>1.3数据库存储数据的特点</h3><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.数据先放进表里，表再放进数据库<br><span class="hljs-number">2</span>.一个数据库可能有多个表，每个表有唯一名字，用来标识自己<br><span class="hljs-number">3</span>.表有一些特性，这些特性定义数据如何在表中存储，类似<span class="hljs-keyword">Java中的类</span><br><span class="hljs-keyword"></span><span class="hljs-number">4</span>.表由列组成，我们也成为字段，所有的表都是由一个或多个列组成，每一列类似<span class="hljs-keyword">JAVA中的属性</span><br><span class="hljs-keyword"></span><span class="hljs-number">5</span>.表中的数据按行存储的，每一行类似<span class="hljs-keyword">java中的对象</span><br></code></pre></div></td></tr></table></figure><h3 id="1-4MySQL特点"><a href="#1-4MySQL特点" class="headerlink" title="1.4MySQL特点"></a>1.4MySQL特点</h3><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">成本低，开源、免费、性能高、简单安装和使用<br></code></pre></div></td></tr></table></figure><h3 id="1-5DBMS分为两类"><a href="#1-5DBMS分为两类" class="headerlink" title="1.5DBMS分为两类"></a>1.5DBMS分为两类</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span>.基于共享文件系统的DBMS(微软的Access)   不需要安装服务端<br><span class="hljs-number">2</span>.基于客户机<span class="hljs-regexp">/服务器（C/</span>S）的DBMS（MySQL、Oracle、SqlServer）：需要安装客户端和服务端，数据存储在服务端，一般指安装服务端。<br></code></pre></div></td></tr></table></figure><h3 id="1-6MySQL服务的启动和停止"><a href="#1-6MySQL服务的启动和停止" class="headerlink" title="1.6MySQL服务的启动和停止"></a>1.6MySQL服务的启动和停止</h3><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-number">1</span>.手动到我的电脑-管理-服务和应用程序-MySQL57停止。<br><span class="hljs-number">2</span>.<span class="hljs-built_in">cmd</span>以管理员身份运行。<span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span>/stop mysql57<br></code></pre></div></td></tr></table></figure><h3 id="1-7MySQL服务的登录和退出"><a href="#1-7MySQL服务的登录和退出" class="headerlink" title="1.7MySQL服务的登录和退出"></a>1.7MySQL服务的登录和退出</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">MySQL服务必须开启！<br><span class="hljs-number">1</span>.可以用软件自带的客户端进去，但是只能自己访问（不推荐）<br><span class="hljs-number">2</span>.可以用命令行mysql （-h localhost -P <span class="hljs-number">3306</span>） -u root -proot<br>host:主机名称P:端口号 password后边不能有空格，其他的可以有<br>退出：<span class="hljs-keyword">exit</span>/Ctrl+c<br></code></pre></div></td></tr></table></figure><blockquote><p>如果不行应该是没配置环境变量，path里边加入MySQL安装路径，到bin目录</p></blockquote><h3 id="1-8-MySQL的命令"><a href="#1-8-MySQL的命令" class="headerlink" title="1.8 MySQL的命令"></a>1.8 MySQL的命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">查看所有数据库:  <span class="hljs-keyword">show</span> databases;<br>打开指定库:use test; <br>查看当前库的所有表: <span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;  <br>看其他库的所有表   <span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">from</span> mysql;<br>查看当前位置:   <span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>();<br>看表的结构： <span class="hljs-keyword">desc</span> 表名字<br>查看表的所有索引<span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> 表名<br>查看数据库版本：<span class="hljs-keyword">select</span> version();退出去之后，msaql <span class="hljs-comment">--version</span><br><br>看数据：  <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sss;<br>插入数据：     <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> sss (id,<span class="hljs-type">name</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;rose&#x27;</span>);<br>修改<span class="hljs-keyword">update</span> sss <span class="hljs-keyword">set</span> <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;llliiii&#x27;</span> <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span>;<br>删除<span class="hljs-keyword">delete</span> form sss <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span>;<br>建表：    creat <span class="hljs-keyword">table</span> +表名字（列名 列类型，列名 列类型）<br>例：creat <span class="hljs-keyword">table</span> sss(id <span class="hljs-type">int</span>, <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>));<br></code></pre></div></td></tr></table></figure><h3 id="1-9语法规范"><a href="#1-9语法规范" class="headerlink" title="1.9语法规范"></a>1.9语法规范</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>不区分大小写，建议关键字大些，表名、列名小写<br><span class="hljs-number">2.</span>每条命令分号结尾<br><span class="hljs-number">3.</span>命令比较长，可以缩进换行<br>建议 <span class="hljs-keyword">SELECT</span><br>  <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span><br>  sss<br><span class="hljs-number">4.</span>注释<br>单行注释：#注释文字<br>单行注释：<span class="hljs-comment">--注释文字</span><br>多行注释：<span class="hljs-comment">/*文字*/</span><br></code></pre></div></td></tr></table></figure><h3 id="1-10MySQL图形化客户端"><a href="#1-10MySQL图形化客户端" class="headerlink" title="1.10MySQL图形化客户端"></a>1.10MySQL图形化客户端</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">root<span class="hljs-variable">@locallhost</span>  表示通过root链接到localhost<br>询问保存的文件的格式是 .<span class="hljs-keyword">sql</span><br></code></pre></div></td></tr></table></figure><p>MySQL库内容</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------------------+</span><br>| information<span class="hljs-emphasis">_schema |原数据信息</span><br><span class="hljs-emphasis">| mysql              |保存用户信息</span><br><span class="hljs-emphasis">| performance_</span>schema |收集性能信息参数<br><span class="hljs-section">| sys                |测试数据，空的，可以建表，删除其他三个不要动 </span><br><span class="hljs-section">+--------------------+</span><br></code></pre></div></td></tr></table></figure><h3 id="1-11主键"><a href="#1-11主键" class="headerlink" title="1.11主键"></a>1.11主键</h3><p>主键（primary key） 一列（或一组列），其值能够唯一区分表中每个行</p><p>唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行  </p><p>表中的任何列都可以作为主键，只要它满足以下条件：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.任意两行都不具有相同的主键值；<br><span class="hljs-number">2</span>.每个行都必须具有一个主键值（主键列不允许<span class="hljs-literal">NULL</span>值）。  <br></code></pre></div></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">主键的最好习惯 除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为：<br>1.不更新主键列中的值；<br>2.不重用主键列的值；<br>3.不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。）  <br></code></pre></div></td></tr></table></figure><h2 id="二、DQL语言"><a href="#二、DQL语言" class="headerlink" title="二、DQL语言"></a>二、DQL语言</h2><p>(Data Query Language 数据查询语言)     用于查询数据</p><h4 id="2-1-select查询"><a href="#2-1-select查询" class="headerlink" title="2.1 select查询"></a>2.1 select查询</h4><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>查询字段：<br><span class="hljs-keyword">select</span> 查询列表（逗号隔开）<br><span class="hljs-keyword">from</span>表名；<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sss     *代表所有的字段  <br><span class="hljs-number">2.</span>查询常量值：<br><span class="hljs-keyword">select</span> <span class="hljs-number">100</span>；<br><span class="hljs-number">3.</span>查询表达式：<br><span class="hljs-keyword">select</span> <span class="hljs-number">100</span>*<span class="hljs-number">9</span>；<br><span class="hljs-number">4.</span>查询函数：<br><span class="hljs-keyword">select</span> VERSION();<br><br><span class="hljs-keyword">limit</span>：限制条数，放在最后<br><span class="hljs-keyword">limit</span> <span class="hljs-number">5</span> ，只输出<span class="hljs-number">5</span>行 ， linit <span class="hljs-number">5</span>,<span class="hljs-number">5</span>  ，从第<span class="hljs-number">6</span>行开始输出<span class="hljs-number">5</span>行（<span class="hljs-keyword">limit</span>从<span class="hljs-number">0</span>开始）<br><span class="hljs-keyword">distinct</span>：去重<br>查询去重： <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 查询列表 <span class="hljs-keyword">from</span> sss；<br><br>特点：<br><span class="hljs-number">1.</span>查询列表可以是：表中的字段、常量值、表达式、函数<br><span class="hljs-number">2.</span>查询的结果是一个虚拟的表格<br></code></pre></div></td></tr></table></figure><h4 id="2-2-起别名"><a href="#2-2-起别名" class="headerlink" title="2.2 起别名"></a>2.2 起别名</h4><p>起别名&#x3D;&#x3D;单引号双引号都行&#x3D;&#x3D;,建议双引号,而且有特殊符号必须要加引号，并且可以解决查询字段有重名的情况，对于别名中冲突关键字的用双引号（AS） 或者省略</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span>*<span class="hljs-number">99</span> <span class="hljs-keyword">AS</span> 结果；<br><span class="hljs-keyword">select</span> last_name <span class="hljs-keyword">AS</span> 姓 <span class="hljs-keyword">from</span> sss <br></code></pre></div></td></tr></table></figure><h4 id="2-3-concat连接"><a href="#2-3-concat连接" class="headerlink" title="2.3 concat连接"></a>2.3 concat连接</h4><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">连接字段 CONCAT(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-keyword">AS</span>  结果<br>如果是<span class="hljs-keyword">null</span>+任意，结果都是<span class="hljs-keyword">null</span><br>concat 可以有ifnull<br>mysql的+只做加法运算功能<br>如果是字符+数字，字符能转换成整数的，转换成整数加，不能则是<span class="hljs-number">0</span>+数字。<br><br>判断空  IFNULL（要判断的字段，要取代的值）<br></code></pre></div></td></tr></table></figure><blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada"><span class="hljs-number">1</span>.要先打开库  <span class="hljs-keyword">USE</span> myemployees<br><span class="hljs-number">2</span>.对与不想成为关键字的要用~~抱住，着重号<br><span class="hljs-number">3</span>.执行的时候，选中谁执行谁<br><span class="hljs-number">4</span>.F12格式化<br><span class="hljs-number">5</span>.单引号代表字符，对于别名中冲突关键字的用双引号<br></code></pre></div></td></tr></table></figure></blockquote><h4 id="2-4条件查询"><a href="#2-4条件查询" class="headerlink" title="2.4条件查询"></a>2.4条件查询</h4><h5 id="2-4-1-where筛选"><a href="#2-4-1-where筛选" class="headerlink" title="2.4.1 where筛选"></a>2.4.1 where筛选</h5><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas">语法<br><span class="hljs-keyword">select</span> 查询列表     执行顺序： 3<br><span class="hljs-keyword">from</span>   表明  1<br><span class="hljs-keyword">where</span>  筛选条件；2<br><br>条件运算符筛选：&gt;    &lt;   =     !=  &lt;&gt;不等     &gt;=  &lt;=  <br>逻辑表达式筛选： <span class="hljs-variable">&amp;&amp;</span>  || ！    推荐  <span class="hljs-keyword">and</span>  <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <br></code></pre></div></td></tr></table></figure><h5 id="2-4-2-模糊查询like"><a href="#2-4-2-模糊查询like" class="headerlink" title="2.4.2 模糊查询like"></a>2.4.2 模糊查询like</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">like</span><br><span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>；包含a的字段<br><span class="hljs-keyword">like</span>一般和通配符使用<br><span class="hljs-operator">%</span>通配符 任意多个字符，包含<span class="hljs-number">0</span>个字符<br>_通配符 任意单个字符  可以多个连用  比如    <span class="hljs-string">&#x27;_ _ n _ 1&#x27;</span>没有空格<br>转义字符：  如何像查询<span class="hljs-operator">%</span> 或者_的字段，用转移字符 加\     如 \<span class="hljs-operator">%</span><br>      推荐用<span class="hljs-keyword">WHERE</span>  last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_$_%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;$&#x27;</span>，指用任意的$代表转义字符 <br></code></pre></div></td></tr></table></figure><p>&#x3D;&#x3D;ESCAPE ‘$’&#x3D;&#x3D;   必须%  _  这样的才可以escape  其他 一律\</p><h5 id="2-4-3-between-and筛选"><a href="#2-4-3-between-and筛选" class="headerlink" title="2.4.3 between and筛选"></a>2.4.3 between and筛选</h5><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">between </span><span class="hljs-keyword">and </span>语法<br>select <br>* <br>from <br>where  ...  <span class="hljs-keyword">between </span> <span class="hljs-number">100</span> <span class="hljs-keyword">and </span><span class="hljs-number">200</span>    等价于 &gt;=<span class="hljs-number">100</span>  <span class="hljs-keyword">and </span>&lt;=<span class="hljs-number">200</span><br><span class="hljs-number">1</span>.包含临界值<br><span class="hljs-number">2</span>.提高简洁<br><span class="hljs-number">3</span>.不能换顺序<br></code></pre></div></td></tr></table></figure><h5 id="2-4-4-in筛选"><a href="#2-4-4-in筛选" class="headerlink" title="2.4.4 in筛选"></a>2.4.4 in筛选</h5><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">in</span> 语法<br>判断是否属于<br><span class="hljs-keyword">select</span> <br>* <br><span class="hljs-keyword">from</span> <br><span class="hljs-keyword">where</span>  ...  <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;100&#x27;</span>,<span class="hljs-string">&#x27;200&#x27;</span>)    等价于 =<span class="hljs-number">100</span>  and =<span class="hljs-number">200</span><br><br></code></pre></div></td></tr></table></figure><h5 id="2-4-5-ifnull（a-9）判断空"><a href="#2-4-5-ifnull（a-9）判断空" class="headerlink" title="2.4.5 ifnull（a,9）判断空"></a>2.4.5 ifnull（a,9）判断空</h5><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span>  <span class="hljs-built_in">ifnull</span>(asss,<span class="hljs-number">0</span>)  如果ASSS是<span class="hljs-literal">null</span>，则为<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h5 id="2-4-6-is-null和-isnull（a）"><a href="#2-4-6-is-null和-isnull（a）" class="headerlink" title="2.4.6 is null和 isnull（a）"></a>2.4.6 is null和 isnull（a）</h5><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">is</span> (<span class="hljs-keyword">not</span>) <span class="hljs-literal">null</span> 语法     不能直接whrere  ...=<span class="hljs-literal">null</span><br><span class="hljs-keyword">select</span> <br>* <br><span class="hljs-keyword">from</span> <br><span class="hljs-keyword">where</span>  ...  <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>    判断是否为<span class="hljs-function"><span class="hljs-literal">null</span></span><br><span class="hljs-function"><span class="hljs-title">isnull</span>(<span class="hljs-params">dddd</span>) 判断是否<span class="hljs-literal">null</span>  是dddd</span> = <span class="hljs-number">1</span>，否<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">&lt;=&gt;安全等于<br>=或者!= 或者&lt;&gt; 不能判断<span class="hljs-keyword">null</span><br>安全等于既可以判断是否等于，也可以判断是否<span class="hljs-keyword">null</span>，但可读性低<br><span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>则只能判断<span class="hljs-keyword">null</span>，可读性较高<br></code></pre></div></td></tr></table></figure><h4 id="2-5-排序查询order-by"><a href="#2-5-排序查询order-by" class="headerlink" title="2.5 排序查询order by"></a>2.5 排序查询order by</h4><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">from</span><span class="hljs-number">1</span><br>whrer<span class="hljs-number">2</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序列表【<span class="hljs-keyword">asc</span>|<span class="hljs-keyword">desc</span>】  不写默认是升序<span class="hljs-number">4</span><br>          排序列表可以是函数，别名，表达式，也可以是多个排序方式 <br>        多个排序： ordey <span class="hljs-keyword">by</span> aaa <span class="hljs-keyword">ASC</span> ， bbb <span class="hljs-keyword">DESC</span>；<br>       <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 一般在最后面，除了Linit子句<br></code></pre></div></td></tr></table></figure><h4 id="2-6-常见函数"><a href="#2-6-常见函数" class="headerlink" title="2.6 常见函数"></a>2.6 常见函数</h4><p>类似JAVA中的方法，隐藏了实现细节，提高代码重用性</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">调用方式：<br><span class="hljs-keyword">select</span> 函数名（实参列表） 【<span class="hljs-keyword">from</span>表】<span class="hljs-punctuation">;</span><br>分类<br><span class="hljs-number">1</span>.单行函数    返回一个值<br>如<span class="hljs-keyword">concat</span> length ifnull<span class="hljs-punctuation">;</span>  <br><span class="hljs-number">2</span>.分组函数（统计使用，又称统计函数，聚合函数，组函数）<br>返回一组值<br></code></pre></div></td></tr></table></figure><h5 id="2-6-1-单行函数"><a href="#2-6-1-单行函数" class="headerlink" title="2.6.1 单行函数"></a>2.6.1 单行函数</h5><h6 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h6><p>① length函数   获取参数值字节个数</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">length</span></span>(<span class="hljs-string">&#x27;ddd&#x27;</span>)   <span class="hljs-number">3</span>  <span class="hljs-title"><span class="hljs-built_in">length</span></span>(<span class="hljs-string">&#x27;啊啊&#x27;</span>)   <span class="hljs-number">6</span></span><br></code></pre></div></td></tr></table></figure><p>② 显示所用字符集 </p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%char%&#x27;</span>   <br></code></pre></div></td></tr></table></figure><blockquote><p>UTF-8 汉字3个字节       GBK 汉字2个字节</p></blockquote><p>③ concat函数    拼接字符串</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">concat</span>(<span class="hljs-params">last_name,<span class="hljs-string">&#x27;_&#x27;</span>,first_name</span>) 姓名 <span class="hljs-keyword">from</span> employees</span>;<br></code></pre></div></td></tr></table></figure><p>④upper、lower函数  变大写小写</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">SELECT</span> <span class="hljs-function"><span class="hljs-title">UPPER</span>(<span class="hljs-string">&#x27;asdf&#x27;</span>)</span><br></code></pre></div></td></tr></table></figure><p>⑤ substr\substring  截取字符串     sql中索引都是从1开始</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">substr</span>(&#x27;asdffd&#x27;,<span class="hljs-number">4</span>);截取第四个（包括）后边字符<br><span class="hljs-built_in">substr</span>(&#x27;asdffd&#x27;,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); 截取第一个(包括)后边<span class="hljs-number">2</span>个字符(字符,不是字节)<br></code></pre></div></td></tr></table></figure><p>⑥ instr 函数 返回子字符串出现的第一次所以，如果找不到，返回0</p><figure class="highlight hsp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs hsp"><span class="hljs-keyword">instr</span>(<span class="hljs-string">&#x27;acccc&#x27;</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>)<span class="hljs-comment">;    2</span><br></code></pre></div></td></tr></table></figure><p>⑦ trim 函数   去空格&#x2F;其他的东西</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-string">&#x27;   cc   &#x27;</span>)</span></span>    cc<br><span class="hljs-function"><span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-string">&#x27;a&#x27;</span> from <span class="hljs-string">&#x27;aa啊aa卡aa&#x27;</span> )</span></span>  啊aa卡   去前后，不去中间 <br></code></pre></div></td></tr></table></figure><p>⑦ lpad 函数 用指定的字符左填充到指定长度，超过右边截断</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lpad</span><span class="hljs-params">(<span class="hljs-string">&#x27;aab&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;*&#x27;</span>)</span></span>   aa<br><span class="hljs-function"><span class="hljs-title">lpad</span><span class="hljs-params">(<span class="hljs-string">&#x27;ac&#x27;</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;*&#x27;</span>)</span></span>  *******ac<br></code></pre></div></td></tr></table></figure><p>⑨  rpad 函数 用指定的字符右填充到指定长度，超过左边截断</p><p>⑩ replace 函数   替换</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">&#x27;啊我啊我嗷呜&#x27;</span>,<span class="hljs-string">&#x27;啊&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)</span></span>  <span class="hljs-number">1</span>我<span class="hljs-number">1</span>我嗷呜<br></code></pre></div></td></tr></table></figure><p>⑩count（subject） 函数，统计个数多少个subject</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) ,  <span class="hljs-built_in">count</span>(*)<br></code></pre></div></td></tr></table></figure><h6 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h6><p>① round函数  四舍五入</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">round</span>(-<span class="hljs-number">1</span>.<span class="hljs-number">55</span>)   -<span class="hljs-number">2</span><br><span class="hljs-attribute">round</span>(<span class="hljs-number">1</span>.<span class="hljs-number">456</span>,<span class="hljs-number">2</span>)  <span class="hljs-number">1</span>.<span class="hljs-number">46</span><br></code></pre></div></td></tr></table></figure><p>② ceil 函数  向上取整</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">ceil</span>(-<span class="hljs-number">1</span>.<span class="hljs-number">02</span>) -<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>③ floor 向x取整</p><p>④ truncate 直接截断 </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">truncate</span>(<span class="hljs-number">1</span>.<span class="hljs-number">699999</span>,<span class="hljs-number">1</span>)  <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>⑤ mod 取余数   和被除数符号一致</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">mod(<span class="hljs-number">10</span>，-<span class="hljs-number">3</span>) <span class="hljs-number">1</span>        被除数为正，余数为正，被除数负数，余数为负     <br>    算法mod(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)  <span class="hljs-selector-tag">a</span>-<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>*<span class="hljs-selector-tag">b</span>;<br></code></pre></div></td></tr></table></figure><h6 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h6><p>① now 返回现在的日期+时间</p><p>② curdate 返回当前系统日期，不包含时间</p><p>③ curtime 返回当前时间，不包含日期</p><p>④ 可以获取指定的部分，年月日，时分秒<br>        year  month(monthname英文名) day  hour minuit second </p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">select</span> <span class="hljs-function"><span class="hljs-title">year</span>(<span class="hljs-title"><span class="hljs-built_in">now</span></span>()) <span class="hljs-variable">as</span> 年</span><br></code></pre></div></td></tr></table></figure><p>⑤ datediff 返回两个日期相差的天数</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> DATEDIFF(NOW(),&#x27;<span class="hljs-number">2021</span>-<span class="hljs-number">09</span>-<span class="hljs-number">04</span>&#x27;);<br></code></pre></div></td></tr></table></figure><p>⑥ str_to_date  将字符转换成指定格式的日期</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">str_to_date</span><span class="hljs-params">(<span class="hljs-string">&#x27;9-13-1999&#x27;</span>,<span class="hljs-string">&#x27;%m-%d-%Y&#x27;</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>⑦ date_format   将日期转换成字符</p><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">date_format(&#x27;2018/6/6&#x27;,&#x27;%Y年%m月%d日&#x27;)  2018年6月6日<br><span class="hljs-tag">%<span class="hljs-selector-tag">Y</span></span>   四位年份<br><span class="hljs-tag">%<span class="hljs-selector-tag">y</span></span>  2位年份<br><span class="hljs-tag">%<span class="hljs-selector-tag">m</span></span>月份（01，02）<br><span class="hljs-tag">%<span class="hljs-selector-tag">c</span></span>  月份（1，2）<br><span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span>   日（01，02）<br><span class="hljs-tag">%<span class="hljs-selector-tag">H</span></span> 小时（24小时）<br><span class="hljs-tag">%<span class="hljs-selector-tag">h</span></span>12小时<br><span class="hljs-tag">%<span class="hljs-selector-tag">i</span></span>分钟（00，01）<br><span class="hljs-tag">%<span class="hljs-selector-tag">s</span></span>  秒（00.01）<br></code></pre></div></td></tr></table></figure><h6 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h6><p>①version（） 版本</p><p>②database()当前位置</p><p>③user()查询当前用户</p><p>④password(‘字符’)         加密sql8.0之后弃用  </p><p>​MD5(字符)返回字符MD5加密的结果</p><h6 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h6><p>① if函数   if（10&gt;5,1,2）   1 三运运算符</p><p>② case函数可以无else  ，不能无end</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang"><span class="hljs-keyword">case</span> 要判断的量<br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">1</span>  then   ...<br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">3</span>  then   ...<br><span class="hljs-keyword">when</span> 常量<span class="hljs-number">2</span>  then   ...<br>else   ...<br><span class="hljs-keyword">end</span> <br>或者<br><span class="hljs-keyword">case</span><br><span class="hljs-keyword">when</span>  条件<span class="hljs-number">1</span>   then   ...<br><span class="hljs-keyword">when</span>  条件<span class="hljs-number">2</span>   then   ...<br>else   ....<br><span class="hljs-keyword">end</span> <br></code></pre></div></td></tr></table></figure><h5 id="2-6-2-分组函数"><a href="#2-6-2-分组函数" class="headerlink" title="2.6.2 分组函数"></a>2.6.2 分组函数</h5><p>功能：统计使用，又称为聚合函数或者统计函数、组函数 有 sum、avg、max、min、count</p><p>sun（工资）     求的是一列的工资总和  count     统计的是非空的个数</p><p>①参数类型</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q"><span class="hljs-built_in">avg</span>,<span class="hljs-built_in">sum</span>,一般就用数值型，<br><span class="hljs-built_in">max</span>，<span class="hljs-built_in">min</span>，<span class="hljs-built_in">count</span>可任何类型，比如名字排序，日期<br></code></pre></div></td></tr></table></figure><p>②是否忽略null </p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q"><span class="hljs-built_in">null</span> + 任何==<span class="hljs-built_in">null</span><br><span class="hljs-built_in">sum</span> <span class="hljs-built_in">avg</span> <span class="hljs-built_in">max</span>,<span class="hljs-built_in">min</span> <span class="hljs-built_in">count</span>  全部忽略<span class="hljs-built_in">null</span><br></code></pre></div></td></tr></table></figure><p>④都可以和distinct搭配 </p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">sum</span>（<span class="hljs-built_in">distinct</span>  salary）<br></code></pre></div></td></tr></table></figure><p>⑤count函数</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"> <span class="hljs-built_in">count</span>(*) 统计所有行        <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)    加了一列<span class="hljs-number">1</span> 统计<span class="hljs-number">1</span>的个数，即统计行<br>效率<br>    MYISAM存储引擎下，<span class="hljs-built_in">COUNT</span>(*)效率高   以前的存储引擎<br>    INNODB存储引擎下，<span class="hljs-built_in">count</span>(*)和<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)差不多，比<span class="hljs-built_in">count</span>(字段)要高<br></code></pre></div></td></tr></table></figure><h4 id="2-7-分组查询-group-by"><a href="#2-7-分组查询-group-by" class="headerlink" title="2.7 分组查询 group by"></a>2.7 分组查询 group by</h4><p>和分组函数一同查询的字段，要求是group by后出现的字段</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">分组查询格式:<br> <span class="hljs-keyword">select</span>     分组函数，分组后的字段  <span class="hljs-number">5</span><br> <span class="hljs-keyword">from</span>       表<span class="hljs-number">1</span><br>【<span class="hljs-keyword">where</span>     筛选条件】     <span class="hljs-number">2</span><br> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>    分组的字段  <span class="hljs-number">3</span><br>【<span class="hljs-keyword">having</span>      分组后筛选】<span class="hljs-number">4</span><br>【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>    排序列表】     <span class="hljs-number">6</span><br> <br> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>  也可以是函数表达式.<br> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>  可以是多个字段分组,逗号隔开<br><br> 分组查询<br> 分组前筛选      原始表      <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 子句前边，  whrer<br> 分组后筛选分组后的结果集 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 子句后边   <span class="hljs-keyword">having</span><br><span class="hljs-number">1</span> 分组函数做条件放在<span class="hljs-keyword">having</span>子句中<br><span class="hljs-number">2</span> 能用分组前筛选就用分组前<span class="hljs-keyword">where</span><br></code></pre></div></td></tr></table></figure><p>比如查询有奖金的每个领导手下的最高工资 这里领导要分组</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(工资),领导部门<br><span class="hljs-keyword">from</span>  员工<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 领导部门<br></code></pre></div></td></tr></table></figure><h4 id="2-8-连接查询"><a href="#2-8-连接查询" class="headerlink" title="2.8 连接查询"></a>2.8 连接查询</h4><p>多表查询时,查询的字段来自多个表时,会用到连接查询.</p><p>如果还是直接查询,会发生笛卡尔乘积,结果n*m行 </p><p>如何解决：添加有效的连接条件</p><figure class="highlight nestedtext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">按年代分类,有sql92标准   仅支持内连接  也支持一部分外连接（用于oracle,sqlserver,mysql不支持）</span><br><span class="hljs-attribute">   sql99标准内连接,外连接(左外，右外，全外（mysql不支持全外）),交叉连接</span><br><span class="hljs-attribute">按功能</span><br><span class="hljs-attribute">    内连接</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> 等值连接,非等值连接,自连接</span><br>    <span class="hljs-attribute">外连接</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> 左外连接,右外连接,全外连接</span><br>    交叉连接<br></code></pre></div></td></tr></table></figure><h5 id="2-8-1sql92标准"><a href="#2-8-1sql92标准" class="headerlink" title="2.8.1sql92标准"></a>2.8.1sql92标准</h5><h6 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1.等值连接:"></a>1.等值连接:</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名，表<span class="hljs-number">2</span> 别名<br>        <span class="hljs-keyword">where</span> 表<span class="hljs-number">1.</span><span class="hljs-keyword">key</span> = 表<span class="hljs-number">2.</span><span class="hljs-keyword">key</span><br>        【<span class="hljs-keyword">and</span> 筛选条件】<br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br> <br> 注意可以为表起别名，但是起别名之后原名不能在使用了.<br> 两个表的顺序可以调换<br> 可以加筛选  用<span class="hljs-keyword">and</span><br> 可以加分组<br> 可以加排序<br> 可以多表连接<br> 多表等值连接的结果为多表的交集<br> n个表连接,需要至少N<span class="hljs-number">-1</span>个条件<br> 多表的顺序无要求<br> 可以搭配排序,分组,筛选使用<br></code></pre></div></td></tr></table></figure><h6 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2.非等值连接"></a>2.非等值连接</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名，表<span class="hljs-number">2</span> 别名<br>        <span class="hljs-keyword">where</span> 非等值连接条件             例如 <span class="hljs-keyword">between</span> <span class="hljs-keyword">and</span>  <br>        【<span class="hljs-keyword">and</span> 筛选条件】<br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><h6 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3.自连接"></a>3.自连接</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表 别名<span class="hljs-number">1</span>，表 别名<span class="hljs-number">2</span>同一个表<br>        <span class="hljs-keyword">where</span> 等值连接条件             一般是   <br>        【<span class="hljs-keyword">and</span> 筛选条件】<br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">比如查询员工的上级,是根据员工的上级ID来匹配新的员工表,一张表当成两张用<br>           <span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.employee_id,<span class="hljs-built_in">e</span>.last_name,  m.employee_id,m.last_name<br>           <span class="hljs-keyword">from</span> employees <span class="hljs-built_in">e</span> , employees m<br>           <span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.manager_id = m.employee_id<br></code></pre></div></td></tr></table></figure><h5 id="2-8-2-sql99语法"><a href="#2-8-2-sql99语法" class="headerlink" title="2.8.2 sql99语法"></a>2.8.2 sql99语法</h5><p>内连接、外连接（左外、右外、全外(mysql不支持)）、交叉连接</p><h6 id="1-内连接inner"><a href="#1-内连接inner" class="headerlink" title="1.内连接inner"></a>1.内连接inner</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">inner</span>（可以省略）查询两表共有的    交集<br>格式<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表A<br>        【<span class="hljs-keyword">inner</span>】<span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span> 连接条件n个表连接,需要至少N<span class="hljs-number">-1</span>个条件<br>        【<span class="hljs-keyword">where</span>  筛选条件】<br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><h6 id="2-左外连接left"><a href="#2-左外连接left" class="headerlink" title="2.左外连接left"></a>2.左外连接left</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式查询的是A的内容,包括a和b的交集<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表AA是主表，从表不匹配显示<span class="hljs-literal">Null</span><br>        <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> 表B  <span class="hljs-keyword">on</span> 连接条件a.<span class="hljs-keyword">key</span>=b.<span class="hljs-keyword">key</span><br>        【<span class="hljs-keyword">where</span>  筛选条件】要查询A但不含交集，<span class="hljs-keyword">where</span> b.<span class="hljs-keyword">key</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span><br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><h6 id="3-右外链接"><a href="#3-右外链接" class="headerlink" title="3.右外链接"></a>3.右外链接</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式查询的是B的内容<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表AB是主表<br>        <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 表B  <span class="hljs-keyword">on</span> 连接条件a.<span class="hljs-keyword">key</span>=b.<span class="hljs-keyword">key</span><br>        【<span class="hljs-keyword">where</span>  筛选条件】要查询B但不含交集，<span class="hljs-keyword">where</span> a.<span class="hljs-keyword">key</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span><br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><blockquote><p>特点：<br>    1.外连接查询的结果为主表中所有的记录<br>    2.如果表中没有和他匹配的，显示NULL<br>    3.如果匹配则显示匹配的值。</p></blockquote><h6 id="4-全外连接"><a href="#4-全外连接" class="headerlink" title="4.全外连接"></a>4.全外连接</h6><p>   内连接的结果+第一个有第二个没有的+第二个有第一个没有的</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">格式查询的是A+B的内容<br>        <span class="hljs-keyword">select</span>  查询列表<br>        <span class="hljs-keyword">from</span> 表A<br>        full <span class="hljs-keyword">join</span> 表B  <span class="hljs-keyword">on</span> 连接条件a.<span class="hljs-keyword">key</span>=b.<span class="hljs-keyword">key</span><br>        【<span class="hljs-keyword">where</span>  筛选条件】要查询A+B但不含交集，<span class="hljs-keyword">where</span> a.<span class="hljs-keyword">key</span>/b.<span class="hljs-keyword">key</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span><br>        【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>        【<span class="hljs-keyword">having</span> 分组后的筛选】<br>        【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><h6 id="5-交叉连接"><a href="#5-交叉连接" class="headerlink" title="5.交叉连接"></a>5.交叉连接</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  查询列表<br><span class="hljs-keyword">from</span> 表A<br><span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> 表B <br>【<span class="hljs-keyword">where</span>  筛选条件】<br>【<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段】<br>【<span class="hljs-keyword">having</span> 分组后的筛选】<br>【<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段 】<br></code></pre></div></td></tr></table></figure><h5 id="2-8-3-sql92-和sql99对比"><a href="#2-8-3-sql92-和sql99对比" class="headerlink" title="2.8.3 sql92 和sql99对比"></a>2.8.3 sql92 和sql99对比</h5><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">sql99支持较多，可读性较高，sql99实现连接条件和筛选条件的分离<br></code></pre></div></td></tr></table></figure><h5 id="2-9子查询"><a href="#2-9子查询" class="headerlink" title="2.9子查询"></a>2.9子查询</h5><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">出现在其他语句中的<span class="hljs-keyword">select</span>语句，称为子查询或内查询。<br>内部嵌套其他<span class="hljs-keyword">select</span>语句的查询，成为主查询或者外查询。<br></code></pre></div></td></tr></table></figure><h6 id="2-9-1-子查询的分类"><a href="#2-9-1-子查询的分类" class="headerlink" title="2.9.1 子查询的分类"></a>2.9.1 子查询的分类</h6><p>按子查询出现的位置分类：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span>后面                    仅支持标量子查询<br><span class="hljs-keyword">from</span>后面                支持表子查询<br><span class="hljs-keyword">where</span>或<span class="hljs-keyword">having</span>后面       标量子查询  列子查询  行子查询<br><span class="hljs-keyword">exists</span>（叫做相关子查询）后面    表子查询<br>          <br>         <br>  返回<span class="hljs-number">1</span> 有，<span class="hljs-number">0</span>无，不管几行几列，都可以，查询是不有值<br>表子查询<br></code></pre></div></td></tr></table></figure><p>按结果集的行列数不同分类：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">标量子查询（ 结果只有一行一列）    一般搭配着单行操作符使用 &gt;  &lt;  &gt;<span class="hljs-operator">=</span>  &lt;<span class="hljs-operator">=</span>  <span class="hljs-operator">=</span>  &lt;&gt;<br>列子查询（结果集只有一列多行）一般搭配多行操作符使用， in amy/some all<br>行子查询（结果集有一行多列）<br>表子查询（结果集一般为多行多列）<br></code></pre></div></td></tr></table></figure><h6 id="2-9-2-子查询在where或having后面"><a href="#2-9-2-子查询在where或having后面" class="headerlink" title="2.9.2 子查询在where或having后面"></a>2.9.2 子查询在where或having后面</h6><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">标量子查询  列子查询  行子查询<br>特点：<br><span class="hljs-number">1</span>.子查询都会放在小括号内<br><span class="hljs-number">2</span>.子查询一般放在条件的右侧<br><span class="hljs-number">3</span>.标量子查询，一般搭配着单行操作符使用    &gt;   &lt;   &gt;<span class="hljs-operator">=</span>   &lt;<span class="hljs-operator">=</span>   <span class="hljs-operator">=</span>   &lt;&gt;   <br>标量子查询只要子查询不是一行一列，都是非法，没结果也是非法<br></code></pre></div></td></tr></table></figure><p>1.多行子查询，返回多行，使用多行比较操作符</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">in</span><span class="hljs-operator">/</span><span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> 等于列表中的任意一个<br><span class="hljs-keyword">any</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">some</span>和子查询返回的耨一个值比较<br><span class="hljs-keyword">all</span>     和子查询返回的所有值比较<br></code></pre></div></td></tr></table></figure><p>例子</p><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas">1.查询location_id在1400-1700<br>            <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> department_id<br>            <span class="hljs-keyword">from</span> departments<br>            <span class="hljs-keyword">where</span> location_id i<span class="hljs-meta">n</span>(1400,1700);<br> 2.查询员工姓名，要求部门号是1中列表某一个<br> <span class="hljs-keyword">select</span> lase_name<br> <span class="hljs-keyword">from</span> employees<br> <span class="hljs-keyword">where</span> department_id i<span class="hljs-meta">n</span>(<br>             <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> department_id<br>            <span class="hljs-keyword">from</span> departments<br>           <span class="hljs-keyword">where</span> location_id i<span class="hljs-meta">n</span>(1400,1700)<br> );<br></code></pre></div></td></tr></table></figure><p>2.行子查询，多个字段查询（结果是一行多列，或者多行多列）不常用</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">例子：  查询工资最少并且销售额最高的员工信息<br><br><span class="hljs-keyword">select</span> *<br><span class="hljs-keyword">from</span> employees<br><span class="hljs-keyword">where</span> (employee_id,salary)=(<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(employee_id),<span class="hljs-built_in">max</span>(salary)<br><span class="hljs-keyword">from</span> employees<br>)<br></code></pre></div></td></tr></table></figure><h6 id="2-9-3子查询在select后面"><a href="#2-9-3子查询在select后面" class="headerlink" title="2.9.3子查询在select后面"></a>2.9.3子查询在select后面</h6><p>仅仅支持标量子查询</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">例如，查询每个部门的员工个数<br><span class="hljs-keyword">select</span> d.*,(<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(*)<br><span class="hljs-keyword">from</span> employee <span class="hljs-built_in">e</span><br><span class="hljs-keyword">where</span> <span class="hljs-built_in">e</span>.department_id = d.department_id<br>)  个数<br><span class="hljs-keyword">from</span> departments d;<br><br>也可以用左外连接<br><span class="hljs-keyword">SELECT</span> d.*,<span class="hljs-keyword">IF</span>(<span class="hljs-built_in">e</span>.<span class="hljs-symbol">`employee_id`</span>,<span class="hljs-built_in">COUNT</span>(d.department_id),<span class="hljs-number">0</span>)<br><span class="hljs-keyword">FROM</span> departments d<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees <span class="hljs-built_in">e</span> <span class="hljs-keyword">ON</span> d.<span class="hljs-symbol">`department_id`</span> = <span class="hljs-built_in">e</span>.department_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> d.department_id;<br>注意if对空的判断，该操作是先把有部门的员工取出来，然后根据主表来分组，在计数，这个时候，因为分组之后count的计数，实际是对主表的每个部门的计数，因为每个部门都有记录，所以即使有的部门没有员工，但是由于count的是部门id，主表中一定有记录，但是该部门没有员工，所以会记录成1.<br>我们需要在这时判断没有有员工，没有直接给他清0<br>为什么不能where，是因为where直接过滤掉了部门没有员工的<br></code></pre></div></td></tr></table></figure><h6 id="2-9-4-子查询在from后面"><a href="#2-9-4-子查询在from后面" class="headerlink" title="2.9.4 子查询在from后面"></a>2.9.4 子查询在from后面</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">例如：查询每个部门的平均工资的工资等级<br>1.查询每个部门的平均工资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary),department_id<br><span class="hljs-keyword">from</span> employees<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> department_id<br><span class="hljs-number">2.</span>连接<span class="hljs-number">1</span>的结果和job_grades表，筛选条件平均工资<span class="hljs-keyword">between</span> lowest_sal <span class="hljs-keyword">and</span> highest_sal<br><span class="hljs-keyword">select</span> ag_dep.*,g.grade_level<br><span class="hljs-keyword">from</span> (<br>            <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary),department_id<br>            <span class="hljs-keyword">from</span> employees<br>            <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> department_id<br>) ag_dep<span class="hljs-comment">/*注意必须起别名*/</span><br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> job_grades g <br><span class="hljs-keyword">on</span> ag_dep.ag <span class="hljs-keyword">between</span> lowest_sal <span class="hljs-keyword">and</span> highest_sal;<br></code></pre></div></td></tr></table></figure><h6 id="2-9-5-exists后面（相关子查询）"><a href="#2-9-5-exists后面（相关子查询）" class="headerlink" title="2.9.5 exists后面（相关子查询）"></a>2.9.5 exists后面（相关子查询）</h6><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">select</span> exists(完成的查询语句)   结果<span class="hljs-number">1</span>/<span class="hljs-number">0</span>       先执行著查询，到了位置执行子查询<br></code></pre></div></td></tr></table></figure><h5 id="2-10-分页查询"><a href="#2-10-分页查询" class="headerlink" title="2.10 分页查询"></a>2.10 分页查询</h5><p>​应用场景，对于显示数据，一页显示不全，需要分页提交sql请求</p><p>语法： 放在查询最后</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> 查询列表  <span class="hljs-number">7</span><br><span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span><br>【jion <span class="hljs-keyword">type</span>】 jion 表<span class="hljs-number">2</span><span class="hljs-number">2</span><br><span class="hljs-keyword">on</span>  连接条件  <span class="hljs-number">3</span><br>【<span class="hljs-keyword">where</span> 筛选条件】<span class="hljs-number">4</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段     <span class="hljs-number">5</span><br><span class="hljs-keyword">having</span> 分组后的筛选<span class="hljs-number">6</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序字段  <span class="hljs-number">8</span><br><span class="hljs-keyword">limit</span>【<span class="hljs-keyword">offset</span>】, size;<span class="hljs-keyword">offset</span>要显示条目的起始索引（从<span class="hljs-number">0</span>索引开始） size显示条目个数<br></code></pre></div></td></tr></table></figure><p>例如</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">显示前5条信息<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">5</span>       <span class="hljs-number">0</span>可以省略<br></code></pre></div></td></tr></table></figure><p>分页公式</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-built_in">linit</span> (page<span class="hljs-number">-1</span>)*size,sizepage 要分的页数，  size 每页的条数<br></code></pre></div></td></tr></table></figure><h5 id="2-11-联合查询-union"><a href="#2-11-联合查询-union" class="headerlink" title="2.11 联合查询  union"></a>2.11 联合查询  union</h5><p>应用场景：查询的结果来自多个表，但是多个表没有联系，而需要查询的信息是一致</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">语法：<br>        查询语句<span class="hljs-number">1</span><br>        <span class="hljs-keyword">union</span><br>        查询语句<span class="hljs-number">2</span><br>        <span class="hljs-keyword">union</span><br>        .....<br>        <span class="hljs-keyword">select</span><br>       <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> email <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%a%&#x27;</span> <span class="hljs-keyword">or</span> department_id<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>   <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> email <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%a%&#x27;</span><br>   <span class="hljs-keyword">union</span>  <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span>  department_id<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span><br>   <br><span class="hljs-number">1.</span>将查询条件拆分出来，其查询目的都是一样，就是把筛选条件分开了<br><span class="hljs-number">2.</span>将不同表查询目的一样的联合起来，其表名和第一个表一致<br><br>注意：<br><span class="hljs-number">1.</span>联合查询中多个联合的列数要一致<br><span class="hljs-number">2.</span><span class="hljs-keyword">union</span>关键联合多个表时，会自动将一样的去重，如果不想去重，使用 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-number">3.</span>查询的字段名，默认是第一个列的名字<br></code></pre></div></td></tr></table></figure><h3 id="三、DML语言"><a href="#三、DML语言" class="headerlink" title="三、DML语言"></a>三、DML语言</h3><p>数据操作语言DML</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">插入 <span class="hljs-keyword">insert</span><br>修改 <span class="hljs-keyword">update</span><br>删除 <span class="hljs-keyword">delete</span><br></code></pre></div></td></tr></table></figure><h4 id="3-1-插入语句-insert"><a href="#3-1-插入语句-insert" class="headerlink" title="3.1 插入语句 insert"></a>3.1 插入语句 insert</h4><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">方式一：<br>insert <span class="hljs-keyword">into</span> 表名（列名，<span class="hljs-params">...</span>）values(值<span class="hljs-number">1</span>，<span class="hljs-params">...</span>)；<br><span class="hljs-number">1.</span>插入的值的类型要与列的类型一致或兼容<br><span class="hljs-number">2.</span>不可以为<span class="hljs-built_in">null</span>的列必须插入值，可以为<span class="hljs-built_in">null</span>的值，可以不写列明插入<br><span class="hljs-number">3.</span>列的顺序可以调换<br><span class="hljs-number">4.</span>列数和值的个数必须一致<br><span class="hljs-number">5.</span>可以省略列明，默认是所有的列，都需要有值<br><br>方式二：<br>insert <span class="hljs-keyword">into</span> 表明<br><span class="hljs-built_in">set</span> 列名=值，列名=值<span class="hljs-params">...</span>.<br><br>方式一可以插入多行，方式二不支持<br>方式一支持子查询，方式二不支持   可以把查询结果当插入值<br><br></code></pre></div></td></tr></table></figure><h4 id="3-2修改语句-update"><a href="#3-2修改语句-update" class="headerlink" title="3.2修改语句 update"></a>3.2修改语句 update</h4><p>1.修改单表的记录</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">语法<br>        update 表名<span class="hljs-number">1</span>  别名<br>        <span class="hljs-built_in">set</span> 列=新值，列=新值，<span class="hljs-params">...</span>.<br>        <span class="hljs-keyword">where</span> 筛选条件<br></code></pre></div></td></tr></table></figure><p>2.修改多表的记录</p><p>92语法</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">update 表<span class="hljs-number">1</span>  别名，表<span class="hljs-number">2</span>  别名<br><span class="hljs-keyword">set</span>  列=值，....<br>where 连接条件<br>and 筛选条件<br></code></pre></div></td></tr></table></figure><p>&#x3D;&#x3D;99语法&#x3D;&#x3D;</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> 表<span class="hljs-number">1</span> 别名<br><span class="hljs-keyword">inner</span>|<span class="hljs-keyword">left</span>|<span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名<br><span class="hljs-keyword">on</span> 连接条件<br><span class="hljs-keyword">set</span> 列=值，...<br><span class="hljs-keyword">where</span> 筛选条件<br></code></pre></div></td></tr></table></figure><p>例子</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">修改张无忌女朋友的手机号为<span class="hljs-number">114</span><br>update <span class="hljs-keyword">boys </span><span class="hljs-keyword">bo</span><br><span class="hljs-keyword"></span>innner <span class="hljs-keyword">join </span><span class="hljs-keyword">beauty </span><span class="hljs-keyword">b </span>on <span class="hljs-keyword">bo.id </span>= <span class="hljs-keyword">b.boyfriend_id</span><br><span class="hljs-keyword"></span>set <span class="hljs-keyword">b.phone </span>= <span class="hljs-number">114</span><br>where <span class="hljs-keyword">bo.boyName </span>= <span class="hljs-string">&#x27;张无忌&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="3-3-删除语句-delete"><a href="#3-3-删除语句-delete" class="headerlink" title="3.3 删除语句 delete"></a>3.3 删除语句 delete</h4><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">方式一：<br>1.单表删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 【<span class="hljs-keyword">where</span> 筛选条件】   【<span class="hljs-keyword">limit</span>  条目数】<br><span class="hljs-number">2.</span>多表删除<br>        <span class="hljs-number">92</span>语法<br>            <span class="hljs-keyword">delete</span> 别名<br>            <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span>，别名，表<span class="hljs-number">2</span>，别名<br>            <span class="hljs-keyword">where</span> 连接条件<br>            <span class="hljs-keyword">and</span> 筛选条件；<br><br><span class="hljs-number">99</span>语法<br>            <span class="hljs-keyword">delete</span> 表<span class="hljs-number">1</span> 别名 ，表<span class="hljs-number">2</span> 别名删除谁写谁，两个都删除都写<br>            <span class="hljs-keyword">from</span> 表<span class="hljs-number">1</span> 别名<br>            <span class="hljs-keyword">inner</span>|<span class="hljs-keyword">left</span>|<span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span> 别名 <span class="hljs-keyword">on</span> 连接条件<br>            <span class="hljs-keyword">where</span> 筛选条件<br><br>方式二：<span class="hljs-keyword">truncate</span><br><span class="hljs-keyword">truncate</span> table 表名<br><span class="hljs-keyword">truncate</span>  也叫清空表，不能用<span class="hljs-keyword">where</span><br><br>两种方式对比<br>   <span class="hljs-number">1.</span> <span class="hljs-keyword">truncate</span> 效率高<br>   <span class="hljs-number">2.</span> 要删除的表中有自增长列，再插入<span class="hljs-keyword">delete</span>从断点开始，<span class="hljs-keyword">truncate</span>从<span class="hljs-number">1</span>开始<br>   <span class="hljs-number">3.</span> <span class="hljs-keyword">delete</span> 删除有返回值，<span class="hljs-keyword">truncate</span> 无返回值<br>   <span class="hljs-number">4.</span> <span class="hljs-keyword">truncate</span>删除，不能回滚，<span class="hljs-keyword">delete</span>可以回滚<br></code></pre></div></td></tr></table></figure><h3 id="四、DDL语言"><a href="#四、DDL语言" class="headerlink" title="四、DDL语言"></a>四、DDL语言</h3><p>数据定义语言 Data Define Language</p><h5 id="4-1库的管理和操作：创建、修改、删除"><a href="#4-1库的管理和操作：创建、修改、删除" class="headerlink" title="4.1库的管理和操作：创建、修改、删除"></a>4.1库的管理和操作：创建、修改、删除</h5><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">创建：<span class="hljs-keyword">create</span><br>修改：<span class="hljs-keyword">alter</span>   修改表的结构<br>删除：<span class="hljs-keyword">drop</span><br></code></pre></div></td></tr></table></figure><h6 id="4-1-1-库的创建"><a href="#4-1-1-库的创建" class="headerlink" title="4.1.1 库的创建"></a>4.1.1 库的创建</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">语法：<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 库名  【<span class="hljs-type">character</span> <span class="hljs-keyword">set</span> 字符集】；也可以加存储引擎等<br>重复的话不能在创建了，会报错<br>推荐使用  creat <span class="hljs-keyword">database</span> （<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>） 库名 【<span class="hljs-type">character</span> <span class="hljs-keyword">set</span> 字符集】；<br></code></pre></div></td></tr></table></figure><h6 id="4-1-2-库的修改（不建议）"><a href="#4-1-2-库的修改（不建议）" class="headerlink" title="4.1.2 库的修改（不建议）"></a>4.1.2 库的修改（不建议）</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">rename</span> <span class="hljs-keyword">database</span> books <span class="hljs-keyword">to</span> 新库名；（废弃了）<br>要修改库名可以直接改文件夹名子  要关库改，之后重启库<br><br>更改字符集<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> books <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> gbk  ,默认utf<span class="hljs-number">-8</span><br></code></pre></div></td></tr></table></figure><h6 id="4-1-3-库的删除"><a href="#4-1-3-库的删除" class="headerlink" title="4.1.3 库的删除"></a>4.1.3 库的删除</h6><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> books 不存在删除会报错<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> books   存在的时候删除<br></code></pre></div></td></tr></table></figure><h5 id="4-2-表的创建、修改、删除"><a href="#4-2-表的创建、修改、删除" class="headerlink" title="4.2 表的创建、修改、删除"></a>4.2 表的创建、修改、删除</h5><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">创建：creat<br>修改：<span class="hljs-keyword">alter</span>   <br>删除：<span class="hljs-keyword">drop</span><br></code></pre></div></td></tr></table></figure><h6 id="4-2-1-表的创建"><a href="#4-2-1-表的创建" class="headerlink" title="4.2.1 表的创建"></a>4.2.1 表的创建</h6><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">语法：<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> (if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>)表名(<br>列名  类型的类型【（长度）约束】，<br>列名  类型的类型【（长度）约束】，<br>列名  类型的类型【（长度）约束】，<br>....<br>列名  类型的类型【（长度）约束】<br>);<br></code></pre></div></td></tr></table></figure><h6 id="4-2-2-表的修改"><a href="#4-2-2-表的修改" class="headerlink" title="4.2.2 表的修改"></a>4.2.2 表的修改</h6><p>alter table 表名 add|drop|modify|change  column 列名  【列类型 约束】</p><ol><li>修改列名</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book(表名) change &#123;<span class="hljs-keyword">column</span>可省略&#125; aa（旧列名） bb（新列名） datetime（类型要带上）<br></code></pre></div></td></tr></table></figure><ol start="2"><li>修改列的类型或约束</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 新类型(<span class="hljs-type">timestamp</span>)<br></code></pre></div></td></tr></table></figure><ol start="3"><li>添加新列</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 类型 【<span class="hljs-keyword">first</span><span class="hljs-operator">|</span>after 字段名】;  添加的位置可选<br></code></pre></div></td></tr></table></figure><ol start="4"><li>删除列</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列名；（不能判断是否存在，不能if <span class="hljs-keyword">exists</span>）<br></code></pre></div></td></tr></table></figure><ol start="5"><li>修改表名</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> 新表名<br></code></pre></div></td></tr></table></figure><h6 id="4-2-3-表的删除"><a href="#4-2-3-表的删除" class="headerlink" title="4.2.3 表的删除"></a>4.2.3 表的删除</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名；<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 表名；<br>通用的写法<br>删除库<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 旧库名<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 新库名<br>删除表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> 旧表名<br><span class="hljs-keyword">create</span> tabke 表名（）; <br></code></pre></div></td></tr></table></figure><h6 id="4-2-4-表的复制"><a href="#4-2-4-表的复制" class="headerlink" title="4.2.4 表的复制"></a>4.2.4 表的复制</h6><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名 <span class="hljs-keyword">like</span>  要复制的表名，  这个只复制结构，不复制值<br> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 新表名 <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 要复制的表名    复制全部内容<br> <br><span class="hljs-number">1.</span> 也可以只复制部分列    <br><span class="hljs-number">2.</span> 只复制某些表的结构，不要内容，可以加一个<span class="hljs-keyword">where</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h5 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h5><h6 id="4-3-1-数值型"><a href="#4-3-1-数值型" class="headerlink" title="4.3.1 数值型"></a>4.3.1 数值型</h6><ol><li>整型</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">整型字节<br>Tinyint<span class="hljs-number">1</span>有符号<span class="hljs-number">-128</span><span class="hljs-operator">~</span><span class="hljs-number">127</span>  符号<span class="hljs-number">0</span><span class="hljs-number">-255</span><br><span class="hljs-type">Smallint</span> <span class="hljs-number">2</span><span class="hljs-number">-32768</span><span class="hljs-operator">~</span><span class="hljs-number">32767</span>  <span class="hljs-number">0</span><span class="hljs-operator">~</span><span class="hljs-number">65536</span><br>Mediumint<span class="hljs-number">3</span>百万<br><span class="hljs-type">Int</span>\<span class="hljs-type">integer</span><span class="hljs-number">4</span>十亿<br><span class="hljs-type">Bigint</span><span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>如何设置无符号和有符号    int  unsigned </p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.不设置无符号还是有符号，默认有符号<br><span class="hljs-attribute">2</span>.插入值超出整型范围，会报out of range 异常，并且插入的是临界值<br><span class="hljs-attribute">3</span>.如果不设置长度，会有默认的长度 也可以设置长度， 长度由类型决定<br><span class="hljs-attribute">4</span>. int(<span class="hljs-number">7</span>)<span class="hljs-number">7</span>是显示宽度， 但是想要显示<span class="hljs-number">0</span>，还需要用到 zerofill,<br> <span class="hljs-attribute">int</span>(<span class="hljs-number">7</span>) zerofill  左边填充<span class="hljs-number">0</span> ，并且自动成为无符号型<br></code></pre></div></td></tr></table></figure><ol start="2"><li>小数</li></ol><p>浮点型</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">   字节<br><span class="hljs-built_in">float</span><span class="hljs-number">4</span><br><span class="hljs-built_in">double</span><span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>定点数类型 （精度更高）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">定点数类型字节范围<br><span class="hljs-type">DEC</span>（M,D）M<span class="hljs-operator">+</span><span class="hljs-number">2</span>范围和<span class="hljs-keyword">double</span>相同，给定<span class="hljs-type">decimal</span>的有效取值范围由M和D决定<br><span class="hljs-type">DECIMAL</span>（M,D）<br></code></pre></div></td></tr></table></figure><p>使用方法</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.浮点型<br><span class="hljs-function"><span class="hljs-title">float</span><span class="hljs-params">(m,d)</span></span>M：整数部分+小数部分  ， D小数点后位数<br><span class="hljs-function"><span class="hljs-title">double</span><span class="hljs-params">(m,d)</span></span>少的话，小数一定，整数<span class="hljs-number">99</span>溢出<br><span class="hljs-number">2</span>.定点型<br><span class="hljs-function"><span class="hljs-title">dec</span><span class="hljs-params">(m,d)</span></span><br><span class="hljs-function"><span class="hljs-title">decimal</span><span class="hljs-params">(m,d)</span></span><br><br>M,D都可以省略，如果是decimal，则M默认是<span class="hljs-number">10</span>，D默认<span class="hljs-number">0</span><br>如果是<span class="hljs-attribute">float</span> 和double，则会根据插入的数值的精度来决定精度<br>定点型精度较高，如果要求插入数值的精度较高如货币运算等可以考虑使用<br><br>使用法则：<br>所选择的类型越简单越好，能保存的数值的类型越小越好<br></code></pre></div></td></tr></table></figure><h6 id="4-3-2-字符型"><a href="#4-3-2-字符型" class="headerlink" title="4.3.2 字符型"></a>4.3.2 字符型</h6><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>较短的文本<br><span class="hljs-type">char</span><br><span class="hljs-type">varchar</span><br><span class="hljs-number">2.</span>较长的文本<br><span class="hljs-type">text</span><br>blob(较大的二进制)<br><br><span class="hljs-type">char</span>(M)M可省，默认<span class="hljs-number">1</span>  最多字符数，不是字节，a是一个字符    M为<span class="hljs-number">0</span><span class="hljs-number">-255</span><br><span class="hljs-type">varchar</span>(M)M不可省略   可变长度<span class="hljs-number">0</span><span class="hljs-number">-65535</span><br>区别：<span class="hljs-type">char</span>的M代表固定长度字符，<span class="hljs-type">varchar</span> M代表可变长度<br>效率：      <span class="hljs-type">char</span>高      <span class="hljs-type">varchar</span>低<br>空间耗费<span class="hljs-type">char</span>耗费<span class="hljs-type">varchar</span>节省<br></code></pre></div></td></tr></table></figure><h6 id="4-3-3-位类型"><a href="#4-3-3-位类型" class="headerlink" title="4.3.3 位类型"></a>4.3.3 位类型</h6><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-type">binary</span> 和<span class="hljs-type">varbinary</span><br>类似<span class="hljs-type">char</span>和<span class="hljs-type">varchar</span> ，他们包含二进制字符串，而不包含非二进制字符串<br></code></pre></div></td></tr></table></figure><h6 id="4-3-4-Enum类型"><a href="#4-3-4-Enum类型" class="headerlink" title="4.3.4 Enum类型"></a>4.3.4 Enum类型</h6><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">枚举类型，要求插入的值必须属于列表中指定的值之一<br>列表成员为1<span class="hljs-string">-255</span>，需要1个字节存储，<br>列表成员为255<span class="hljs-string">-65535</span>，需要两个字节存储<br>最多需要65535个成员<br>枚举不区分大小写，插入大小写都可以 ，可以插入一个枚举，也可以插入多个枚举<br></code></pre></div></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">例如：<br>creat <span class="hljs-selector-tag">table</span> <span class="hljs-built_in">tab_char</span>(<br>c1 <span class="hljs-built_in">enum</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>set 用于保存集合   和枚举一样不区分大小写</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">例如：<br>creat <span class="hljs-keyword">table</span> tab_set(<br>c1 <span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tab_set <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tab_set <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tab_set <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h6 id="4-3-5-日期型"><a href="#4-3-5-日期型" class="headerlink" title="4.3.5 日期型"></a>4.3.5 日期型</h6><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">  字节     最小值<br><span class="hljs-type">date</span>          <span class="hljs-number">4</span>         <span class="hljs-number">1000</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>      <br>datetime      <span class="hljs-number">8</span> <span class="hljs-number">1000</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>   <span class="hljs-number">00</span>：<span class="hljs-number">00</span>：<span class="hljs-number">00</span><br><span class="hljs-type">timestamp</span>   <span class="hljs-number">4</span><span class="hljs-number">19700101080001</span><span class="hljs-number">2038</span>年<br><span class="hljs-type">time</span>   <span class="hljs-number">3</span>          <span class="hljs-number">-838</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><br><span class="hljs-keyword">year</span>           <span class="hljs-number">1</span>   <span class="hljs-number">1901</span>   <br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;time_zone&#x27;</span>   显示时区<br><br><span class="hljs-type">timestamp</span>，记录时区，反应时区信息 ，收mysql版本和sqmode影响大<br>datetime    不受时区影响，只记录当地时区<br></code></pre></div></td></tr></table></figure><h5 id="4-4-常见约束"><a href="#4-4-常见约束" class="headerlink" title="4.4 常见约束"></a>4.4 常见约束</h5><p>一种限制，用于限制表中的数据，为了保证表中的数据准确性和可靠性 比如姓名、学号</p><p>添加约束的时机</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.创建表的时候<br>2.修改表的时候<br></code></pre></div></td></tr></table></figure><p>约束的分类</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">列级约束：六大约束都支持，外键约束没有效果<br>表级约束：除了非空、默认，其他的都支持<br><br>creat <span class="hljs-selector-tag">table</span> 表名（<br>字段名 字段类型 列级约束，<br>字段名 字段类型 列级约束，<br>表级约束<br>）<br></code></pre></div></td></tr></table></figure><p>六大约束</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">1.<span class="hljs-built_in"> not </span>null<span class="hljs-keyword"> :</span>非空，保证该字段的值不能为空<br>2. default <span class="hljs-keyword"> :</span>默认，用于保证该字段有默认值<br>3. primary key<span class="hljs-keyword"> :</span>主键，用于保证该字段的值具有唯一性，并且非空<br>4. unique   ：唯一，用于保证该字段的值具有唯一性，可以为空<br>5.<span class="hljs-built_in"> check </span>  <span class="hljs-keyword"> :</span> 检查约束【mysql中不支持，不报错但没效果】<br>6. foreign key： 外键约束，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值<br>在从表添加外键约束，用于引用主表中某列的值   不能作为列级约束，不生效<br></code></pre></div></td></tr></table></figure><p>1.建表时添加列级约束</p><p>支持持：默认、非空、主键、唯一</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stuinfo(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key ,   #主键<br>stuName vachar(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>，       非空<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">check</span>(gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">or</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>)，  #检查<br>seat <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>，       唯一<br>age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>，    默认约束<br>majorId <span class="hljs-type">int</span>  <span class="hljs-keyword">references</span> major(id)   外键     注意不能加<span class="hljs-keyword">foreign</span> key ,<br>  sql8<span class="hljs-number">.0</span>也不支持<span class="hljs-keyword">references</span><br>)<br>creat <span class="hljs-keyword">table</span> major(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>majorName <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>查看表的所有索引show index from 表名   可以查看主键外键</p><ol start="2"><li>建表时添加表级约束</li></ol><p>【constraint 约束名】  约束类型（字段名）   不起名会有默认名字</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stuinfo(<br>id <span class="hljs-type">int</span>,<br>stuname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>seat <span class="hljs-type">int</span>,<br>age <span class="hljs-type">int</span>,<br>majorid <span class="hljs-type">int</span>,<br><br><span class="hljs-keyword">constraint</span> pk <span class="hljs-keyword">primary</span> key(id),    主键<br><span class="hljs-keyword">constraint</span> uo <span class="hljs-keyword">primary</span> key(id),  唯一键<br><span class="hljs-keyword">constraint</span> ck <span class="hljs-keyword">check</span>(gender <span class="hljs-operator">=</span> ‘男’ <span class="hljs-keyword">or</span> dender <span class="hljs-operator">=</span> ’女‘)   检查   没效果<br><span class="hljs-keyword">constraint</span> ff freign key(majorid) <span class="hljs-keyword">references</span> major(id)<br>)<br>主键就算改名子，他也是<span class="hljs-keyword">primary</span><br></code></pre></div></td></tr></table></figure><p>通用的写法：默认、非空、主键、唯一列级约束，外键表级约束</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> stuinfo(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,主键<br>stuname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,非空<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>seat <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>,唯一<br>age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>,默认<br>majorid <span class="hljs-type">int</span>,<br><br><span class="hljs-keyword">constraint</span> ck_stuinfo_major <span class="hljs-keyword">foreign</span> key (majorid) <span class="hljs-keyword">references</span> major(id) <br>)<br>可以一下设置多个<br>stuname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span>,非空 唯一<br></code></pre></div></td></tr></table></figure><p>主键约束和唯一对比</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">保证唯一性 是否允许空一个表中有几个    是否允许组合<br>主键是否最多<span class="hljs-number">1</span>个是，不推荐<br>唯一是是多个是，不推荐<br><br>组合<span class="hljs-keyword">constraint</span> pk <span class="hljs-keyword">primary key</span>(id，stuname),  两个同同时一样才算一样 <br></code></pre></div></td></tr></table></figure><p>外键的特点</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl"><span class="hljs-number">1</span>.要求在从表设置外键关系<br><span class="hljs-number">2</span>.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br><span class="hljs-number">3</span>.主表中的关联列必须是一个<span class="hljs-function"><span class="hljs-title">key</span>(一般是主键或唯一)</span><br><span class="hljs-number">4</span>.插入数据是时，应该先插入主表，在插入从表<br>删除数据时，先删除从表，在删除主表<br></code></pre></div></td></tr></table></figure><ol start="3"><li>修改表时添加约束</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>添加列级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 新约束；<br><span class="hljs-number">2.</span>添加表级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 【<span class="hljs-keyword">constraint</span> 约束名】约束类型（字段名）【外键的引用】；<br></code></pre></div></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>添加非空约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-number">2.</span>添加默认约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo modify <span class="hljs-keyword">column</span> age <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span><br><span class="hljs-number">3.</span>添加主键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo modify <span class="hljs-keyword">column</span> id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key   列级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">add</span>  <span class="hljs-keyword">primary</span> key(id)表级约束<br><span class="hljs-number">4.</span>添加唯一键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo modify <span class="hljs-keyword">column</span> seat <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>   列级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">add</span>  <span class="hljs-keyword">unique</span>(seat)表级约束<br><span class="hljs-number">5.</span>添加Y键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">add</span> [<span class="hljs-keyword">constraint</span> 新名字] <span class="hljs-keyword">foreign</span> key(majorid) referencts major(id);<br></code></pre></div></td></tr></table></figure><ol start="4"><li>修改表时删除约束</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>删除非空约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">null</span> <br><span class="hljs-number">2.</span>删除默认约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo modify <span class="hljs-keyword">column</span> age <span class="hljs-type">int</span><br><span class="hljs-number">3.</span>删除主键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">drop</span>  <span class="hljs-keyword">primary key</span>  <br><span class="hljs-number">4.</span>删除唯一键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> seat   列级约束<br><span class="hljs-number">5.</span>删除外键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stuinfo <span class="hljs-keyword">drop</span>  <span class="hljs-keyword">foreign key</span> 新名字;     <span class="hljs-keyword">constraint</span>起的新名字<br></code></pre></div></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">位置支持的约束类型是否能起约束名<br>列级约束列的后面语法都支持，但外键没有效果否<br>表级约束所有列的下面默认和非空不支持，其他支持可以，但是主键没效果<br></code></pre></div></td></tr></table></figure><h5 id="4-5标识列（自增长列）"><a href="#4-5标识列（自增长列）" class="headerlink" title="4.5标识列（自增长列）"></a>4.5标识列（自增长列）</h5><p>可以不用手动的插入值，系统提供默认的序列值</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用法：<br>id <span class="hljs-built_in">int</span> unique <span class="hljs-built_in">auto</span>_increment <br></code></pre></div></td></tr></table></figure><p>特点</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-number">1.</span>标识列不一定和主键搭配，但要求必须时一个key<br><span class="hljs-number">2.</span>一个表最多一个增长列<br><span class="hljs-number">3.</span>类型只能时数值型<br><span class="hljs-number">4.</span>标识列可以通过<span class="hljs-keyword">set</span> auto_increment_increment <span class="hljs-comment">= 2 ,</span>设置步长<br>可以通过手动插入值来设置初始值<br></code></pre></div></td></tr></table></figure><p>修改表时设置表示列</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">添加标识列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> auto_increment;<br>删除标识列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> ;<br></code></pre></div></td></tr></table></figure><h3 id="五、TCL语言"><a href="#五、TCL语言" class="headerlink" title="五、TCL语言"></a>五、TCL语言</h3><h5 id="5-1-事务控制语言（-transaction-control-language-）"><a href="#5-1-事务控制语言（-transaction-control-language-）" class="headerlink" title="5.1 事务控制语言（ transaction control language ）"></a>5.1 事务控制语言（ transaction control language ）</h5><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">有一个或者一组<span class="hljs-keyword">sql</span>语句组成一个执行单元，这个执行单元要么全部执行，要不全部不执行。<br>在这个单元中，每个mysql语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果某单元中某条<span class="hljs-keyword">sql</span>语句一旦执行失败或者产生错误，整个单元将会回滚，所有受到影响的数据将返回到事务开始以前的状态，如果单元中的所有<span class="hljs-keyword">sql</span>语句均执行成功，则事务被顺利执行。<br></code></pre></div></td></tr></table></figure><p>事务的ACID(acid)属性</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.原子性（Atomicity)<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生<br><span class="hljs-number">2</span>.一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态，就是事务执行后，仍然是一个整体<br><span class="hljs-number">3</span>.隔离性（<span class="hljs-attribute">Isolation</span>）<br>事务的隔离性是指一个事务的执行不能被其他的事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰<br><span class="hljs-number">4</span>.持久性（Durability）<br>持久性是指 一个事务一旦被提交，他对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响，执行后不能回退<br><br></code></pre></div></td></tr></table></figure><h5 id="5-2-存储引擎"><a href="#5-2-存储引擎" class="headerlink" title="5.2 存储引擎"></a>5.2 存储引擎</h5><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel"><span class="hljs-number">1.</span>在mysql中的数据用各种不同的技术存储在文件（或内存）中<br><span class="hljs-number">2.</span>通过show engines 来查看mysql支持的存储引擎<br><span class="hljs-number">3.</span>在mysql中用的最多的存储引擎有：innode myisam <span class="hljs-keyword">memory</span> 。其中innode支持事务，而myisam、<span class="hljs-keyword">memory</span> 等不支持事务<br></code></pre></div></td></tr></table></figure><h5 id="5-3-事务的创建"><a href="#5-3-事务的创建" class="headerlink" title="5.3 事务的创建"></a>5.3 事务的创建</h5><p>隐式的事务：</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">隐式的事务：事务没有明显的开启和结束的标记<br>比如：<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>语句    一句就代表一个事务<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span>；<br></code></pre></div></td></tr></table></figure><p>显式事务：事务具有明显的开启和结束的标记</p><p>比如两个insert语句要合成一个事务，但前提：必须先设置自动提交功能为禁用</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;autocommit&#x27;</span>; 自动提交功能默认开启<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-comment">= 0</span>;   只针对当前<br></code></pre></div></td></tr></table></figure><p>开启事务步骤</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>先禁用自动提交功能<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">start</span> transaction;   开启事务，可以省略<br><span class="hljs-number">2.</span>编写事务<span class="hljs-keyword">sql</span>语句（一般是<span class="hljs-keyword">select</span>、<span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>）<br>语句<span class="hljs-number">1</span>；<br>语句<span class="hljs-number">2</span>；<br>.....<br><span class="hljs-number">3.</span>结束事务<br><span class="hljs-keyword">commit</span>;提交事务<br><span class="hljs-keyword">rollback</span>;回滚事务    <br>例如：<br> 开启事务<br>        <span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">start</span> transaction;   开启事务，可以省略<br>    一组事务的语句<br>        <span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> &quot;aaa&quot;<br>        <span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">1500</span> <span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> &quot;bbb&quot;<br>     结束事务<br>     <span class="hljs-keyword">commit</span><span class="hljs-operator">/</span><span class="hljs-keyword">rollback</span>;   结束<span class="hljs-operator">/</span>回滚<br></code></pre></div></td></tr></table></figure><h5 id="5-4-数据并发问题"><a href="#5-4-数据并发问题" class="headerlink" title="5.4 数据并发问题"></a>5.4 数据并发问题</h5><p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.脏读：对于两个事务<span class="hljs-built_in">t1</span>,<span class="hljs-built_in">t2</span>，<span class="hljs-built_in">t1</span>读取了已经被<span class="hljs-built_in">t2</span>更新但是还没有提交的字段之后，若<span class="hljs-built_in">t2</span>回滚，<span class="hljs-built_in">t1</span>读取的内容就是临时并且无效的<br><span class="hljs-number">2</span>.不可重复度：对于两个事务<span class="hljs-built_in">t1</span>,<span class="hljs-built_in">t2</span>，<span class="hljs-built_in">t1</span>读取了一个字段，然后<span class="hljs-built_in">t2</span>更新了该字段之后，<span class="hljs-built_in">t1</span>再次读取同一个字段，值就不同了<br><span class="hljs-number">3</span>.幻读：对于两个事务<span class="hljs-built_in">t1</span>,<span class="hljs-built_in">t2</span>，<span class="hljs-built_in">t1</span>从一个表中读取了一个字段，然后<span class="hljs-built_in">t2</span>在该表中插入了一些新的行之后，如果<span class="hljs-built_in">t1</span>再次读取同一个表，就会多出几行<br></code></pre></div></td></tr></table></figure><p>&#x3D;&#x3D;数据库事务的隔离性&#x3D;&#x3D;：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题</p><p>一个事务与其他事务隔离的程度称为&#x3D;&#x3D;隔离级别&#x3D;&#x3D; 数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱</p><p>数据库提供的4种隔离级别</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">隔离级别<br><span class="hljs-keyword">read</span> <span class="hljs-keyword">uncommitted</span> 允许事务读取未被其他事务提交的变更，脏读，不可重复和幻读的问题都会出现<br>（读未提交数据）<br><span class="hljs-keyword">read</span> commited   只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻<br>（读已提交数据）   读问题仍可能出现<br><span class="hljs-keyword">repeatable</span> <span class="hljs-keyword">read</span>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事物对这<br>（可重复读）个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在<br><span class="hljs-keyword">serializable</span>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他的事务对该表执（串行化）      行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下<br></code></pre></div></td></tr></table></figure><p>Oracle支持的2种事务隔离级别：read commited，serializable。 Oracle默认的事务隔离级别为：read commited</p><p>mysql支持4种事务隔离级别，mysql默认的隔离级别：repeatable read</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">mysql查看默认事务隔离级别<br><span class="hljs-keyword">select</span> @@tx_isolation    sql8<span class="hljs-number">.0</span>用的是   <span class="hljs-keyword">select</span> @@transaction_isolation <br>更改事务隔离级别<br><span class="hljs-keyword">set</span> （<span class="hljs-keyword">session</span>马上生效） <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">uncommitted</span>;<br>更改全局的隔离级别，重启生效<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">uncommitted</span>;<br></code></pre></div></td></tr></table></figure><h5 id="5-5-savepoint的使用"><a href="#5-5-savepoint的使用" class="headerlink" title="5.5 savepoint的使用"></a>5.5 savepoint的使用</h5><p> 需要搭配rollback使用</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> autocommit = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id = <span class="hljs-number">25</span>;<br><span class="hljs-keyword">savepoint</span> a;    # 设置保存点<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id = <span class="hljs-number">29</span>;<br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> a；  #回滚到保存点a<br></code></pre></div></td></tr></table></figure><p>题</p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821155220641.png" alt="image-20210821155220641"></p><p>conca可以用于like模糊判定中的连接来用</p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821155254544.png" alt="image-20210821155254544"></p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821155316135.png" alt="image-20210821155316135"></p><p>注意CASE的两种用法， CASE when 条件，then        else           end</p><p>​case 判定的值   when  常量1  then  </p><p>​when  常量2 then    else  end </p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821161055512.png" alt="image-20210821161055512"></p><p>注意CASE 的嵌套用法， end结尾 </p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821161427422.png" alt="image-20210821161427422"></p><p>排序，某种特定的东西需要放在最后或者前边，</p><p><img src="/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210821225751104.png" alt="image-20210821225751104"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2022/04/28/JavaWeb/"/>
    <url>/2022/04/28/JavaWeb/</url>
    
    <content type="html"><![CDATA[<p>​</p><h3 id="一、web概念概述"><a href="#一、web概念概述" class="headerlink" title="一、web概念概述"></a>一、web概念概述</h3><p>JavaWeb：使用Java语言开发基于互联网的项目</p><h4 id="1-软件架构"><a href="#1-软件架构" class="headerlink" title="1.软件架构"></a>1.软件架构</h4><p>C&#x2F;S: Client&#x2F;Server 客户端&#x2F;服务器端</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">在用户本地有一个客户端程序，在远程有一个服务器端程序<br>如：QQ，迅雷...<br>优点：<br>用户体验好<br>缺点：<br>开发、安装，部署，维护 麻烦<br></code></pre></div></td></tr></table></figure><p>B&#x2F;S: Browser&#x2F;Server 浏览器&#x2F;服务器端</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">只需要一个浏览器，用户通过不同的网址<span class="hljs-comment">(URL)</span>，客户访问不同的服务器端程序<br>优点：<br>开发、安装，部署，维护 简单<br>缺点：<br>如果应用过大，用户的体验可能会受到影响<br>对硬件要求过高<br></code></pre></div></td></tr></table></figure><h4 id="2-B-x2F-S架构资源分类"><a href="#2-B-x2F-S架构资源分类" class="headerlink" title="2.B&#x2F;S架构资源分类"></a>2.B&#x2F;S架构资源分类</h4><p>(1) 静态资源：使用静态网页开发技术发布的资源。</p><p>特点：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">所有用户访问，得到的结果是一样的。<br>如：文本，图片，音频、视频, <span class="hljs-selector-tag">HTML</span>,CSS,JavaScript<br><br>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源<br></code></pre></div></td></tr></table></figure><p>(2) 动态资源：使用动态网页及时发布的资源。</p><p>特点：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">所有用户访问，得到的结果可能不一样。<br>如：jsp/servlet,php,asp...<br><br>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">* 我们要学习动态资源，必须先学习静态资源！<br>* 静态资源分工：<br>* <span class="hljs-variable constant_">HTML</span>：用于搭建基础网页，展示页面的内容<br>* <span class="hljs-variable constant_">CSS</span>：用于美化页面，布局页面<br>* <span class="hljs-title class_">JavaScript</span>：控制页面的元素，让页面有一些动态的效果<br></code></pre></div></td></tr></table></figure><h3 id="二、HTML"><a href="#二、HTML" class="headerlink" title="二、HTML"></a>二、HTML</h3><p>Hyper Text Markup Language 超文本标记语言，是最基础的网页开发语言</p><p>超文本:</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.<br></code></pre></div></td></tr></table></figure><p>标记语言:</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">由标签构成的语言。<span class="hljs-tag">&lt;标签名称&gt;</span> 如 html，<span class="hljs-keyword">xml</span><br><span class="hljs-title">标记语言不是编程语言</span><br></code></pre></div></td></tr></table></figure><p>快速入门：</p><h4 id="1-语法："><a href="#1-语法：" class="headerlink" title="1.语法："></a>1.语法：</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">1.html文档后缀名   .html 或者 .htm<br>2. 标签分为<br> 1. 围堵标签：有开始标签和结束标签。如 <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>2. 自闭和标签：开始标签和结束标签在一起。如 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>3. 标签可以嵌套：<br>需要正确嵌套，不能你中有我，我中有你<br>错误：<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>正确：<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来<br>5. html的标签不区分大小写，但是建议使用小写。<br><br><br>例如<br>* 代码：<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">meat</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--开始标签中定义的属性，不区分大小写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FONT</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;green&#x27;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="2-标签学习：根据功能学习"><a href="#2-标签学习：根据功能学习" class="headerlink" title="2.标签学习：根据功能学习"></a>2.标签学习：根据功能学习</h4><p>本功能参考链接<a href="https://www.w3school.com.cn/tags/html_ref_byfunc.asp">https://www.w3school.com.cn/tags/html_ref_byfunc.asp</a></p><h5 id="1-文件标签html最基本的标签"><a href="#1-文件标签html最基本的标签" class="headerlink" title="(1) 文件标签html最基本的标签"></a>(1) 文件标签html最基本的标签</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">html:html文档的根标签     即<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-comment">&lt;!--在最外边 --&gt;</span><br>head：头标签。用于指定html文档的一些属性。引入外部的资源 <br>title：标题标签。<br>body：体标签<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>：html5中定义该文档是html文档<br></code></pre></div></td></tr></table></figure><h5 id="2-文本标签和文本有关的标签"><a href="#2-文本标签和文本有关的标签" class="headerlink" title="(2) 文本标签和文本有关的标签"></a>(2) 文本标签和文本有关的标签</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">1.注释：<span class="hljs-comment">&lt;!-- 注释内容 --&gt;</span><br>2.<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> to <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>：标题标签<br>h1~h6:字体大小逐渐递减<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>：段落标签<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>：换行标签浏览器里的制表符，换行并不换行，需要换行标签<br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>：展示一条水平线<br>属性：<span class="hljs-comment">&lt;!-- 不赞成使用 --&gt;</span><br>* color：颜色<br>* width：宽度<br>* size：高度<br>* align：对其方式<br>* center：居中<br>* left：左对齐<br>* right：右对齐<br>格式化<br> <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>：字体加粗<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>这是粗体文本<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>：字体斜体<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span> 标签一定要和结束标签 <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span>:文本居中<br><span class="hljs-tag">&lt;<span class="hljs-name">font</span>&gt;</span>:字体标签<br>* 属性：<br>* color：颜色<br>* size：大小<br>* face：字体<br>    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;楷体&quot;</span>&gt;</span>This is some text!<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>    <br>* 属性定义：<br>* color：<br>1. 英文单词：red,green,blue<br>2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)<br>3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF<br>* width： <br>1. 数值：width=&#x27;20&#x27; ,数值的单位，默认是 px(像素)<br>2. 数值%：占比相对于父元素的比例<br></code></pre></div></td></tr></table></figure><h5 id="3-图片标签："><a href="#3-图片标签：" class="headerlink" title="(3) 图片标签："></a>(3) 图片标签：</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">* img：展示图片<br>* 属性：<br>* src：指定图片的位置<br>* 代码：<br> <span class="hljs-comment">&lt;!--展示一张图片 img--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/jingxuan_2.jpg&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;古镇&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span>/&gt;</span><br><br>        相对路径<br>             以.开头的路径<br>     <span class="hljs-comment">&lt;!--     * ./：代表当前目录  ./image/1.jpg    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./image/jiangwai_1.jpg&quot;</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--           * ../:代表上一级目录 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../image/jiangwai_1.jpg&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="4-列表标签："><a href="#4-列表标签：" class="headerlink" title="(4) 列表标签："></a>(4) 列表标签：</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">* 有序列表：<br>* ol:<br>* li:<br>* 无序列表：<br>* ul:<br>* li:<br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="5-链接标签："><a href="#5-链接标签：" class="headerlink" title="(5) 链接标签："></a>(5) 链接标签：</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">a:定义一个超链接<br> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>属性：<br> href：指定访问资源的URL(统一资源定位符)<br> target：指定打开资源的方式<br> _self:默认值，在当前页面打开<br> _blank：在空白页面打开<br><br>代码：<br> <span class="hljs-comment">&lt;!--超链接  a--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./5_列表标签.html&quot;</span>&gt;</span>列表标签<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:itcast@itcast.cn&quot;</span>&gt;</span>联系我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/jiangwai_1.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="6-块标签"><a href="#6-块标签" class="headerlink" title="(6) 块标签"></a>(6) 块标签</h5><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">div</span>和<span class="hljs-selector-tag">span</span>：没有样式，结合<span class="hljs-selector-tag">CSS</span>用的<br><span class="hljs-selector-tag">div</span>:每一个<span class="hljs-selector-tag">div</span>占满一整行。块级标签<br>   <span class="hljs-selector-tag">span</span>：文本信息在一行展示，行内标签 内联标签<br></code></pre></div></td></tr></table></figure><h5 id="7-语义化标签"><a href="#7-语义化标签" class="headerlink" title="(7) 语义化标签"></a>(7) 语义化标签</h5><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">html5中为了提高程序的可读性，提供了一些标签。 结合CSS<br>1. <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>：页眉 <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span> <br>2. <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>：页脚<br></code></pre></div></td></tr></table></figure><h5 id="8-表格标签"><a href="#8-表格标签" class="headerlink" title="(8) 表格标签"></a>(8) 表格标签</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>：定义表格<br> <span class="hljs-attribute">width</span>：宽度<br> <span class="hljs-attribute">border</span>：边框<br> cellpadding：定义内容和单元格的距离<br> cellspacing：定义单元格之间的距离。如果指定为<span class="hljs-number">0</span>，则单元格的线会合为一条、<br> bgcolor：背景色<br> align：对齐方式<br> <span class="hljs-selector-tag">tr</span>：定义行<br>* bgcolor：背景色<br>* align：对齐方式<br> <span class="hljs-selector-tag">td</span>：定义单元格<br>* colspan：合并列<br>* rowspan：合并行<br> <span class="hljs-selector-tag">th</span>：定义表头单元格<br> &lt;<span class="hljs-selector-tag">caption</span>&gt;：表格标题<br> &lt;<span class="hljs-selector-tag">thead</span>&gt;：表示表格的头部分<br> &lt;<span class="hljs-selector-tag">tbody</span>&gt;：表示表格的体部分<br> &lt;<span class="hljs-selector-tag">tfoot</span>&gt;：表示表格的脚部分<br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>200<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>300<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="(9) 表单标签"></a>(9) 表单标签</h5><p>概念：用于采集用户输入的数据的。用于和服务器进行交互。</p><p>form标签</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">表单项中的数据要想被提交：必须指定其name属性form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围<br>        属性：<br>             action：指定提交数据的URL<br>             <span class="hljs-keyword">method</span>:指定提交方式<br>                 分类：一共<span class="hljs-number">7</span>种，<span class="hljs-number">2</span>种比较常用<br>                    get：<br>                        <span class="hljs-number">1</span>. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。<br>                        <span class="hljs-number">2</span>. 请求参数大小是有限制的。<br>                        <span class="hljs-number">3</span>. 不太安全。<br>                    post：<br>                        <span class="hljs-number">2</span>. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)<br>                        <span class="hljs-number">2</span>. 请求参数的大小没有限制。<br>                        <span class="hljs-number">3</span>. 较为安全。<br>                        <br>表单项中的数据要想被提交：必须指定其name属性                 <br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;form_action.asp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>input标签</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">input：可以通过type属性值，改变元素展示的样式<br>type属性：<br>text：文本输入框，默认值<br>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息<br>password：密码输入框<br>radio:单选框<br>注意：<br>1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。<br>2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值<br>3. checked属性，可以指定默认值<br>checkbox：复选框<br>注意：<br>1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值<br>2. checked属性，可以指定默认值<br><br>file：文件选择框<br>hidden：隐藏域，用于提交一些信息。<br>按钮：<br>submit：提交按钮。可以提交表单<br>button：普通按钮<br>image：图片提交按钮<br> src属性指定图片的路径<br><br>label：指定输入项的文字描述信息<br>注意：<br>label的for属性一般会和input的id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。<br><br>select: 下拉列表<br>子元素：option，指定列表项<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;saab&quot;</span>&gt;</span>Saab<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;opel&quot;</span>&gt;</span>Opel<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;audi&quot;</span>&gt;</span>Audi<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>textarea：文本域（一个文本框）<br>cols：指定列数，每一行有多少个字符<br>rows：默认多少行。<br></code></pre></div></td></tr></table></figure><p>例如案例：公司简介</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>黑马程序员简介<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>公司简介<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#ffd700&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#FF0000&quot;</span>&gt;</span>&quot;黑马程序员&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>是由<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>传智播客<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>联合中关村<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#ffd700&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;gray&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br>        江苏传智播客教育科技股份有限公司<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        版权所有Copyright 2006-2018<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>​</p><h3 id="三、CSS：页面美化和布局控制"><a href="#三、CSS：页面美化和布局控制" class="headerlink" title="三、CSS：页面美化和布局控制"></a>三、CSS：页面美化和布局控制</h3><p>CSS全拼：Cascading Style Sheets 层叠样式表</p><p>层叠：多个样式可以作用在同一个html的元素上，同时生效</p><p>好处：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.功能强大<br>2.将内容展示和样式控制分离<br>降低耦合度。解耦<br>让分工协作更容易<br>提高开发效率<br></code></pre></div></td></tr></table></figure><h4 id="1-CSS与html结合方式-3种"><a href="#1-CSS与html结合方式-3种" class="headerlink" title="1.CSS与html结合方式(3种)"></a>1.CSS与html结合方式(3种)</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">1. 内联样式<br> * 在标签内使用style属性指定css代码<br> * 如：<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;&quot;</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>2. 内部样式<br>* 在head标签内，定义style标签，style标签的标签体内容就是css代码<br>* 如：<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>:blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>3. 外部样式<br>1. 定义css资源文件。<br>2. 在head标签内，定义link标签，引入外部的资源文件<br>* 如：<br>    * a.css文件：<br>div&#123;<br>    color:green;<br>&#125;<br>第二个文件引入：<br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/a.css&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>* 注意：<br>* 1,2,3种方式 css作用范围越来越大<br>* 1方式不常用，后期常用2,3<br>* 3种格式可以写为：<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;css/a.css&quot;</span>;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="2-css语法"><a href="#2-css语法" class="headerlink" title="2.css语法"></a>2.css语法</h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">格式：<br>选择器 &#123;<br>属性名<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>;<br>属性名<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>;<br>...<br>&#125;<br> 选择器:筛选具有相似特征的元素<br> 注意：<br> 每一对属性需要使用；隔开，最后一对属性可以不加；这里说的是在一个选择器内<br></code></pre></div></td></tr></table></figure><h4 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3.选择器"></a>3.选择器</h4><p>筛选具有相似特征的元素</p><p> 分类：</p><h5 id="1-基础选择器"><a href="#1-基础选择器" class="headerlink" title="(1) 基础选择器"></a>(1) 基础选择器</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>. id选择器：选择具体的id属性值的元素.建议在一个<span class="hljs-selector-tag">html</span>页面中id值唯一<br>    语法：<span class="hljs-selector-id">#id</span>属性值&#123;&#125;<br>                        比如<br>                        &lt;style&gt;<br>                            <span class="hljs-selector-id">#div1</span>&#123;<br>                                <span class="hljs-attribute">color</span>:#<span class="hljs-number">000</span>FF;<br>                            &#125;<br>                        &lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span> id=&quot;div1&quot;&gt;<span class="hljs-selector-tag">dd</span>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></div></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">2</span>. 元素选择器：选择具有相同标签名称的元素<br>    语法： 标签名称&#123;&#125;<br>    注意：id选择器优先级高于元素选择器<br>                        &lt;style&gt;<br>                            <span class="hljs-selector-id">#div</span>&#123;<br>                                <span class="hljs-attribute">color</span>:#<span class="hljs-number">000</span>FF;<br>                            &#125;<br>                        &lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span> id=&quot;div1&quot;&gt;<span class="hljs-selector-tag">dd</span>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></div></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">3</span>. 类选择器：选择具有相同的class属性值的元素。<br>    语法：<span class="hljs-selector-class">.class</span>属性值&#123;&#125;<br>    注意：类选择器选择器优先级高于元素选择器,id选择器最高<br>                        &lt;style&gt;<br>                            <span class="hljs-selector-class">.cls1</span>&#123;<br>                                <span class="hljs-attribute">color</span>:#<span class="hljs-number">000</span>FF;<br>                            &#125;<br>                        &lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">p</span> class=&quot;cls1&quot;&gt;<span class="hljs-selector-tag">dd</span>&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></div></td></tr></table></figure><h5 id="2-扩展选择器"><a href="#2-扩展选择器" class="headerlink" title="(2) 扩展选择器"></a>(2) 扩展选择器</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>. 选择所有元素：<br> 语法： *&#123;&#125;<br><span class="hljs-number">2</span>. 并集选择器：<br> 选择器<span class="hljs-number">1</span>,选择器<span class="hljs-number">2</span>&#123;&#125;<br><br><span class="hljs-number">3</span>. 子选择器：筛选选择器<span class="hljs-number">1</span>元素下的选择器<span class="hljs-number">2</span>元素<br> 语法：  选择器<span class="hljs-number">1</span> 选择器<span class="hljs-number">2</span>&#123;&#125;<br><span class="hljs-number">4</span>. 父选择器：选择父元素是 &lt;<span class="hljs-selector-tag">div</span>&gt; 的所有 &lt;<span class="hljs-selector-tag">p</span>&gt; 元素。<br> 语法：  <span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">p</span> &#123;&#125;<br>例如<br>                          &lt;style&gt;<br>                          <span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><br>                          &#123;<br>                          <span class="hljs-attribute">background-color</span>:yellow;<br>                          &#125;<br>                          &lt;/style&gt;<br><br>                      &lt;<span class="hljs-selector-tag">div</span>&gt;<br>                      &lt;<span class="hljs-selector-tag">p</span>&gt;我是唐老鸭。&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>                      &lt;<span class="hljs-selector-tag">p</span>&gt;我住在 Duckburg。&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>                      &lt;/<span class="hljs-selector-tag">div</span>&gt;<br><br><span class="hljs-number">5</span>. 属性选择器：选择元素名称，属性名=属性值的元素<br> 语法：  元素名称<span class="hljs-selector-attr">[属性名=<span class="hljs-string">&quot;属性值&quot;</span>]</span>&#123;&#125;<br>                          &lt;style&gt;<br>                          <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[target=_blank]</span><br>                          &#123;<br>                          <span class="hljs-attribute">background-color</span>:yellow;<br>                          &#125;<br>                          &lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">a</span> href=&quot;http://www.disney.com<span class="hljs-string">&quot; target=&quot;</span>_blank<span class="hljs-string">&quot;&gt;disney.com&lt;/a&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">6. 伪类选择器：选择一些元素具有的状态</span><br><span class="hljs-string"> 语法： 元素:状态&#123;&#125;</span><br><span class="hljs-string"> 如： &lt;a&gt;</span><br><span class="hljs-string"> 状态：</span><br><span class="hljs-string"> link：初始化的状态</span><br><span class="hljs-string"> visited：被访问过的状态</span><br><span class="hljs-string"> active：正在访问状态</span><br><span class="hljs-string"> hover：鼠标悬浮状态</span><br><span class="hljs-string">                  a:hover</span><br><span class="hljs-string">                  &#123;</span><br><span class="hljs-string">                  background-color:yellow;</span><br><span class="hljs-string">                  &#125;</span><br><span class="hljs-string">&lt;a href=&quot;</span>http://www.google.com<span class="hljs-string">&quot;&gt;Google&lt;/a&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="4-属性"><a href="#4-属性" class="headerlink" title="4.属性"></a>4.属性</h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>. 字体、文本<br>* <span class="hljs-attribute">font-size</span>：字体大小<br>* <span class="hljs-attribute">color</span>：文本颜色<br>* <span class="hljs-attribute">text-align</span>：对其方式<br>* <span class="hljs-attribute">line-height</span>：行高 <br><span class="hljs-number">2</span>. 背景<br>* <span class="hljs-attribute">background</span>：<br><span class="hljs-number">3</span>. 边框<br>* <span class="hljs-attribute">border</span>：设置边框，符合属性<br><span class="hljs-number">4</span>. 尺寸<br>* <span class="hljs-attribute">width</span>：宽度<br>* <span class="hljs-attribute">height</span>：高度<br><span class="hljs-number">5</span>. 盒子模型：控制布局<br>* <span class="hljs-attribute">margin</span>：外边距<br>* <span class="hljs-attribute">padding</span>：内边距<br>* 默认情况下内边距会影响整个盒子的大小<br>* <span class="hljs-attribute">box-sizing</span>: border-box;  设置盒子的属性，让<span class="hljs-attribute">width</span>和<span class="hljs-attribute">height</span>就是最终盒子的大小<br>* <span class="hljs-attribute">float</span>：浮动<br>* <span class="hljs-attribute">left</span><br>* <span class="hljs-attribute">right</span><br></code></pre></div></td></tr></table></figure><h3 id="四、JavaScript"><a href="#四、JavaScript" class="headerlink" title="四、JavaScript"></a>四、JavaScript</h3><p>JavaScript：一门客户端脚本语言，运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p><p>脚本语言：不需要编译，直接就可以被浏览器解析执行了</p><p> 功能：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">可以来增强用户和<span class="hljs-selector-tag">html</span>页面的交互过程，可以来控制<span class="hljs-selector-tag">html</span>元素，让页面有一些动态的效果，增强用户的体验。<br></code></pre></div></td></tr></table></figure><p> JavaScript发展史：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">1992</span>年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为：C--,后来更名为：ScriptEase<br><span class="hljs-attribute">2</span>.<span class="hljs-number">1995</span>年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，重新命名为JavaScript<br><span class="hljs-attribute">3</span>.<span class="hljs-number">1996</span>年，微软抄袭JavaScript开发出JScript语言<br><span class="hljs-attribute">4</span>.<span class="hljs-number">1997</span>年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。<br><span class="hljs-attribute">JavaScript</span> = ECMAScript + JavaScript自己特有的东西(BOM+DOM)<br></code></pre></div></td></tr></table></figure><h4 id="1-ECMAScript：客户端脚本语言的标准"><a href="#1-ECMAScript：客户端脚本语言的标准" class="headerlink" title="1.ECMAScript：客户端脚本语言的标准"></a>1.ECMAScript：客户端脚本语言的标准</h4><h5 id="1-基本语法："><a href="#1-基本语法：" class="headerlink" title="(1) 基本语法："></a>(1) 基本语法：</h5><ol><li>与html结合方式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 内部<span class="hljs-variable constant_">JS</span>：<br>定义&lt;script&gt;，标签体内容就是js代码<br>&lt;script&gt;&lt;/script&gt;<br><span class="hljs-number">2.</span> 外部<span class="hljs-variable constant_">JS</span>：<br>定义&lt;script&gt;，通过src属性引入外部的js文件<br>&lt;script src=<span class="hljs-string">&quot;js/a.js&quot;</span>&gt;&lt;/script&gt;<br> 注意：<br><span class="hljs-number">1.</span> &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。<br><span class="hljs-number">2.</span> &lt;script&gt;可以定义多个。 <br></code></pre></div></td></tr></table></figure><ol start="2"><li>注释</li></ol><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span>. 单行注释：<span class="hljs-regexp">//</span>注释内容<br><span class="hljs-number">2</span>. 多行注释：<span class="hljs-regexp">/*注释内容*/</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li>数据类型</li></ol><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-number">1.</span> 原始数据类型(基本数据类型)：<br><span class="hljs-number">1.</span> <span class="hljs-built_in">number</span>：数字。 整数/小数/<span class="hljs-literal">NaN</span>(not a <span class="hljs-built_in">number</span> 一个不是数字的数字类型)<br><span class="hljs-number">2.</span> string：字符串。 字符串  <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-string">&#x27;abc&#x27;</span>  单双都可以<br><span class="hljs-number">3.</span> <span class="hljs-built_in">boolean</span>: <span class="hljs-literal">true</span>和<span class="hljs-literal">false</span><br><span class="hljs-number">4.</span> <span class="hljs-literal">null</span>：一个对象为空的占位符<br><span class="hljs-number">5.</span> <span class="hljs-literal">undefined</span>：未定义。如果一个变量没有给初始化值，则会被默认赋值为<span class="hljs-literal">undefined</span><br><br><span class="hljs-number">2.</span> 引用数据类型：对象<br></code></pre></div></td></tr></table></figure><ol start="4"><li>变量</li></ol><p>一小块存储数据的内存空间</p><p>Java语言是强类型语言，而JavaScript是弱类型语言。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据<br>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。<br></code></pre></div></td></tr></table></figure><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> 变量名 = 初始化值;<br>或者<span class="hljs-keyword">var</span> 变量名;<br><br>例如： <br>        &lt;script&gt;<br>            <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(a+<span class="hljs-title function_">typeof</span>(a)+<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>)1number<br>        &lt;/script&gt;<br><br><span class="hljs-keyword">typeof</span>运算符：获取变量的类型。<br> 注：<span class="hljs-literal">null</span>运算后得到的是object<br></code></pre></div></td></tr></table></figure><ol start="5"><li>运算符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 一元运算符：只有一个运算数的运算符<br>++，-- ， +(正号)  <br>++(--) 在前，先自增(自减)，再运算<br>++(--) 在后，先运算，再自增(自减)<br>+(-)：正负号<br>注意：在<span class="hljs-variable constant_">JS</span>中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换<br>     其他类型转number：<br>     string转number：按照字面值转换。如果字面值不是数字，则转为<span class="hljs-title class_">NaN</span>（不是数字的数字）<br>     boolean转number：<span class="hljs-literal">true</span>转为<span class="hljs-number">1</span>，<span class="hljs-literal">false</span>转为<span class="hljs-number">0</span><br>     <span class="hljs-title class_">NaN</span>加任何数字都是<span class="hljs-title class_">NaN</span><br>     <br><span class="hljs-number">2.</span> 算数运算符<br>+ - * / % ...<br><br><span class="hljs-number">3.</span> 赋值运算符<br>= +=  -=<br><span class="hljs-number">4.</span> 比较运算符<br>&gt; &lt; &gt;= &lt;= == ===(全等于)<br> 比较方式<br>         <span class="hljs-number">1.</span> 类型相同：直接比较<br>              字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。<br>         <span class="hljs-number">2.</span> 类型不同：先进行类型转换，再比较<br> ==和===:<br>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回<span class="hljs-literal">false</span><br><br><br><span class="hljs-number">5.</span> 逻辑运算符<br>&amp;&amp; || !<br><br>其他类型转boolean：<br>                   <span class="hljs-number">1.</span> number：<span class="hljs-number">0</span>或<span class="hljs-title class_">NaN</span>为假，其他为真<br>                   <span class="hljs-number">2.</span> string：除了空字符串(<span class="hljs-string">&quot;&quot;</span>)，其他都是<span class="hljs-literal">true</span><br>                   <span class="hljs-number">3.</span> <span class="hljs-literal">null</span>&amp;<span class="hljs-attr">undefined</span>:都是<span class="hljs-literal">false</span><br>                   <span class="hljs-number">4.</span> 对象：所有对象都为<span class="hljs-literal">true</span><br><br><span class="hljs-number">6.</span> 三元运算符<br>? : 表达式<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">var</span> c = a &gt; b ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>语法：<br>表达式? 值<span class="hljs-number">1</span>:值<span class="hljs-number">2</span>;<br>判断表达式的值，如果是<span class="hljs-literal">true</span>则取值<span class="hljs-number">1</span>，如果是<span class="hljs-literal">false</span>则取值<span class="hljs-number">2</span>；<br></code></pre></div></td></tr></table></figure><ol start="6"><li>流程控制语句：</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-keyword">if</span>...<span class="hljs-keyword">else</span>...<br><br><span class="hljs-number">2.</span> <span class="hljs-attr">switch</span>:<br>在java中，<span class="hljs-keyword">switch</span>语句可以接受的数据类型：byte int shor char,枚举(<span class="hljs-number">1.5</span>) ,<span class="hljs-title class_">String</span>(<span class="hljs-number">1.7</span>)<br>在<span class="hljs-variable constant_">JS</span>中,<span class="hljs-keyword">switch</span>语句可以接受任意的原始数据类型<br><span class="hljs-keyword">switch</span>(变量)&#123;<br><span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:...;<span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:...;<span class="hljs-keyword">break</span>; <br>&#125;<br><br><span class="hljs-number">3.</span> <span class="hljs-keyword">while</span><br><span class="hljs-number">4.</span> <span class="hljs-keyword">do</span>...<span class="hljs-keyword">while</span><br><span class="hljs-number">5.</span> <span class="hljs-keyword">for</span><br></code></pre></div></td></tr></table></figure><ol start="7"><li>JS特殊语法：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span> 语句以;结尾，如果一行只有一条语句则;可以省略 (不建议)<br><span class="hljs-number">2.</span> 变量的定义使用<span class="hljs-keyword">var</span>关键字，也可以不使用<br>   用： 定义的变量是局部变量<br>      不用：定义的变量是全局变量(不建议)<br>       <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;b=<span class="hljs-number">4</span>&#125;;alert(b);    不建议，在外边直接定义就行<br></code></pre></div></td></tr></table></figure><p>习题：99乘法表</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;99乘法表&lt;/title&gt;<br>    &lt;style&gt;<br>        td&#123;<br>            border: 1px solid;<br>        &#125;<br>    &lt;/style&gt;<br><br>    &lt;script&gt;<br>        document.write(&quot;&lt;table  align=&#x27;center&#x27;&gt;&quot;);<br>        //1.完成基本的for循环嵌套，展示乘法表<br>        for (var i = 1; i &lt;= 9 ; i++) &#123;<br>            document.write(&quot;&lt;tr&gt;&quot;);<br>            for (var j = 1; j &lt;=i ; j++) &#123;<br>                document.write(&quot;&lt;td&gt;&quot;);<br>                        <br>                //输出  1 * 1 = 1<br>                document.write(i + &quot; * &quot; + j + &quot; = &quot; +(i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);//&amp;nbsp空格<br>                document.write(&quot;&lt;/td&gt;&quot;);<br>            &#125;<br>            /*//输出换行<br>            document.write(&quot;&lt;br&gt;&quot;);*/<br>            document.write(&quot;&lt;/tr&gt;&quot;);<br>        &#125;<br><br>        //2.完成表格嵌套<br>        document.write(&quot;&lt;/table&gt;&quot;);<br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><h5 id="2-基本对象："><a href="#2-基本对象：" class="headerlink" title="(2) 基本对象："></a>(2) 基本对象：</h5><p>① Function：函数(方法)对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">3</span>种创建方式：<br>       <span class="hljs-number">1.</span> <span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(形式参数列表,方法体);  <span class="hljs-comment">//忘掉吧</span><br>       <span class="hljs-number">2.</span> <br>               <span class="hljs-keyword">function</span> 方法名称(形式参数列表)&#123;<br>                    方法体<br>                &#125;<br><br>        <span class="hljs-number">3.</span> <br>              <span class="hljs-keyword">var</span> 方法名 = <span class="hljs-keyword">function</span>(<span class="hljs-params">形式参数列表</span>)&#123;<br>                    方法体<br>               &#125;<br>               <br><br>属性：<br>         函数.<span class="hljs-property">length</span>:代表形参的个数<br>         <span class="hljs-title function_">fun</span>(a,b)fun.<span class="hljs-property">length</span>    <span class="hljs-number">2</span> <br>         <br>特点：<br>         <span class="hljs-number">1.</span> 方法定义是，形参的类型不用写,返回值类型也不写。<br>         <span class="hljs-number">2.</span> 方法是一个对象，如果定义名称相同的方法，会覆盖<br>         <span class="hljs-number">3.</span> 在<span class="hljs-variable constant_">JS</span>中，方法的调用只与方法的名称有关，和参数列表无关<br>         <span class="hljs-number">4.</span> 在方法声明中有一个隐藏的内置对象（数组），<span class="hljs-variable language_">arguments</span>,封装所有的实际参数<br>      所以对于重载，比如add<br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;i++)&#123;<br>              sum+=<span class="hljs-variable language_">arguments</span>[i];<br>          &#125;<br>          <span class="hljs-keyword">return</span> sum;<br>      &#125;<br>         <br>调用：<br>                方法名称(实际参数列表);<br></code></pre></div></td></tr></table></figure><p> ② Array:数组对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 创建（<span class="hljs-number">3</span>种方式）：<br>           <span class="hljs-number">1.</span> <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(元素列表);<br>           <span class="hljs-number">2.</span> <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(默认长度);<br>           <span class="hljs-number">3.</span> <span class="hljs-keyword">var</span> arr = [元素列表];<br><span class="hljs-number">2.</span> 方法<br>          <span class="hljs-title function_">join</span>(参数):将数组中的元素按照指定的分隔符拼接为字符串<br>           arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;--&quot;</span>),   <span class="hljs-number">1</span>--<span class="hljs-number">2</span>--<span class="hljs-number">3</span>--<span class="hljs-number">4</span>    空代表默认逗号<br>           <br>          <span class="hljs-title function_">push</span>()向数组的末尾添加一个或更多元素，并返回新的长度。<br><span class="hljs-number">3.</span> 属性<br>          <span class="hljs-attr">length</span>:数组的长度    <br><span class="hljs-number">4.</span> 特点：<br>          <span class="hljs-number">1.</span> <span class="hljs-variable constant_">JS</span>中，数组元素的类型可变的。<br>          <span class="hljs-number">2.</span> <span class="hljs-variable constant_">JS</span>中，数组长度可变的。<br>          <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,a,<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-literal">true</span>]<br></code></pre></div></td></tr></table></figure><p>③ Boolean</p><p> ④Date：日期对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">创建：<br>        <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-title class_">Thu</span><span class="hljs-title class_">May</span> <span class="hljs-number">17</span> <span class="hljs-number">2021</span> <span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">11</span> <span class="hljs-variable constant_">GTM</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br>方法：<br>        <span class="hljs-title function_">toLocaleString</span>()：返回当前date对象对应的时间本地字符串格式<br>        <span class="hljs-title function_">getTime</span>():获取毫秒值。返回当前如期对象描述的时间到<span class="hljs-number">1970</span>年<span class="hljs-number">1</span>月<span class="hljs-number">1</span>日零点的毫秒值差    <br></code></pre></div></td></tr></table></figure><p>⑤ Math：数学对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">创建：<br>          特点：<span class="hljs-title class_">Math</span>对象不用创建，直接使用。  <span class="hljs-title class_">Math</span>.方法名();<br><br>方法：<br>           <span class="hljs-title function_">random</span>():返回 <span class="hljs-number">0</span> ~ <span class="hljs-number">1</span> 之间的随机数。 含<span class="hljs-number">0</span>不含<span class="hljs-number">1</span><br>           <span class="hljs-title function_">ceil</span>(x)：对数进行上舍入。<br>           <span class="hljs-title function_">floor</span>(x)：对数进行下舍入。<br>           <span class="hljs-title function_">round</span>(x)：把数四舍五入为最接近的整数。<br>属性：<br>                <span class="hljs-variable constant_">PI</span><span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span><br></code></pre></div></td></tr></table></figure><p>⑥ Number</p><p>⑦ String</p><p>⑧ RegExp：正则表达式对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">正则表达式：定义字符串的组成规则。<br><span class="hljs-number">1.</span> 单个字符:[]<br>如： [a] [ab]<span class="hljs-comment">/*a或者b*/</span>  [a-zA-<span class="hljs-variable constant_">Z0</span>-9_]<span class="hljs-comment">/*a到z，A到Z*/</span><br>特殊符号代表特殊含义的单个字符:<br>\<span class="hljs-attr">d</span>:单个数字字符 [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]<span class="hljs-comment">/*这里是一个字符，d表数字*/</span><br>\<span class="hljs-attr">w</span>:单个单词字符[a-zA-<span class="hljs-variable constant_">Z0</span>-9_]<br><span class="hljs-number">2.</span> 量词符号：<br>?：表示出现<span class="hljs-number">0</span>次或<span class="hljs-number">1</span>次<br>*：表示出现<span class="hljs-number">0</span>次或多次<br>+：出现<span class="hljs-number">1</span>次或多次 <br>&#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n<br> m如果缺省： &#123;,n&#125;:最多n次<br> n如果缺省：&#123;m,&#125; 最少m次<br><span class="hljs-number">3.</span> 开始结束符号<br> ^:开始<br> <span class="hljs-attr">$</span>:结束<br>正则对象：<br><span class="hljs-number">1.</span> 创建<br><span class="hljs-number">1.</span> <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;正则表达式&quot;</span>);<br>字符串转义了<br>比如： <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;\\w&#123;6,12&#125;&quot;</span>);<br><span class="hljs-number">2.</span> <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/正则表达式/</span>;<br>加入开始结束符号比如： <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\w&#123;6,12&#125;$/</span>;<br><span class="hljs-number">2.</span> 方法<br><span class="hljs-number">1.</span> <span class="hljs-title function_">test</span>(参数):验证指定的字符串是否符合正则定义的规范<br>                比如：<br>                <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\w&#123;6,12&#125;$/</span>;<br><span class="hljs-keyword">var</span> usernames = <span class="hljs-string">&quot;asdasdasdsada&quot;</span>;<br><span class="hljs-keyword">var</span> flag = reg.<span class="hljs-title function_">test</span>(usernames);<span class="hljs-literal">false</span>;<br>              <br></code></pre></div></td></tr></table></figure><p>⑨ Global </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">特点：全局对象，这个<span class="hljs-title class_">Global</span>中封装的方法不需要对象就可以直接调用。  <br>方法名(); 直接调用<br><br>方法：<br><span class="hljs-built_in">encodeURI</span>():url编码<br><span class="hljs-built_in">decodeURI</span>():url解码<br><br><span class="hljs-built_in">encodeURIComponent</span>():url编码,编码的字符更多，url也会被编码<br><span class="hljs-built_in">decodeURIComponent</span>():url解码<br><br><span class="hljs-built_in">parseInt</span>():将字符串转为数字<br>逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number，没有<span class="hljs-title class_">NaN</span><br><span class="hljs-built_in">isNaN</span>():判断一个值是否是<span class="hljs-title class_">NaN</span><br> <span class="hljs-title class_">NaN</span>六亲不认，连自己都不认。<span class="hljs-title class_">NaN</span>参与的==比较全部问<span class="hljs-literal">false</span><br>只能<span class="hljs-built_in">isNaN</span>(a)<br><span class="hljs-built_in">eval</span>():讲 <span class="hljs-title class_">JavaScript</span> 字符串，并把它作为脚本代码来执行。<br>        vara jscode = <span class="hljs-string">&quot;alert(1)&quot;</span><br>        <span class="hljs-built_in">eval</span>(jscode);<br><br></code></pre></div></td></tr></table></figure><h4 id="2-DOM简单学习：为了满足案例要求"><a href="#2-DOM简单学习：为了满足案例要求" class="headerlink" title="2.DOM简单学习：为了满足案例要求"></a>2.DOM简单学习：为了满足案例要求</h4><p>DOM功能：控制html文档的内容</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">知道<span class="hljs-variable constant_">DOM</span>中一个标签：<br><br>获取页面标签(元素)对象：<span class="hljs-title class_">Element</span><br> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;id值&quot;</span>):通过元素的id获取元素对象<br><br>操作<span class="hljs-title class_">Element</span>对象：<br><span class="hljs-number">1.</span> 修改属性值：<br><span class="hljs-number">1.</span> 明确获取的对象是哪一个？<br><span class="hljs-number">2.</span> 查看<span class="hljs-variable constant_">API</span>文档，找其中有哪些属性可以设置<br>        <br>        &lt;img id=<span class="hljs-string">&quot;light&quot;</span> src=<span class="hljs-string">&quot;img/off.gif&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">var</span> light = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;light&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">light.<span class="hljs-property">scr</span> = <span class="hljs-string">&quot;img/on.gif&quot;</span> </span></span><br><span class="language-javascript"><span class="language-xml">         </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-number">2.</span> 修改标签体内容：<br> 属性：innerHTML<br><span class="hljs-number">1.</span> 获取元素对象<br><span class="hljs-number">2.</span> 使用innerHTML属性修改标签体内容<br>        <br>        &lt;h1 id=<span class="hljs-string">&quot;title&quot;</span>&gt;第一个内容&lt;/h1&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">var</span> title = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;title&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">title.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;第二个内容&quot;</span> </span></span><br><span class="language-javascript"><span class="language-xml">         </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>事件简单学习</p><p>功能： 某些组件被执行了某些操作后，触发某些代码的执行。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">造句：  xxx被xxx,我就xxx<br> 我方水晶被摧毁后，我就责备对友。<br> 敌方水晶被摧毁后，我就夸奖自己。<br><br>如何绑定事件<br><span class="hljs-number">1.</span> 直接在html标签上，指定事件的属性(操作)，属性值就是js代码<br><span class="hljs-number">1.</span> 事件：onclick--- 单击事件<br><br><span class="hljs-number">2.</span> 通过js获取元素对象，指定事件属性，设置一个函数<br><br>代码：<br>&lt;body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;light&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/off.gif&quot;</span>  <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun();&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;light2&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/off.gif&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我被点了&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我又被点了&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;咋老点我？&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//1.获取light2对象</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> light2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;light2&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//2.绑定事件</span></span></span><br><span class="language-javascript"><span class="language-xml">    light2.<span class="hljs-property">onclick</span> = fun2;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h4 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3.BOM"></a>3.BOM</h4><p>BOM：Browser Object Model 浏览器对象模型，将浏览器的各个组成部分封装成对象。</p><p>5部分组成：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Window</span>：窗口对象<br><span class="hljs-title class_">Navigator</span>：浏览器对象<br><span class="hljs-title class_">Screen</span>：显示器屏幕对象<br><span class="hljs-title class_">History</span>：历史记录对象<br><span class="hljs-title class_">Location</span>：地址栏对象<br></code></pre></div></td></tr></table></figure><h5 id="1-Window：窗口对象"><a href="#1-Window：窗口对象" class="headerlink" title="(1) Window：窗口对象"></a>(1) Window：窗口对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 创建<br><span class="hljs-number">2.</span> 方法<br>         <span class="hljs-number">1.</span> 与弹出框有关的方法：<br>            <span class="hljs-title function_">alert</span>()显示带有一段消息和一个确认按钮的警告框。<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;弹出一警告框&quot;</span>)<br>            <span class="hljs-title function_">confirm</span>()显示带有一段消息以及确认按钮和取消按钮的对话框。 <br>             <span class="hljs-keyword">var</span> flag = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;是否退出&quot;</span>)<br>                * 如果用户点击确定按钮，则方法返回<span class="hljs-literal">true</span><br>                * 如果用户点击取消按钮，则方法返回<span class="hljs-literal">false</span><br>            <span class="hljs-title function_">prompt</span>()显示可提示用户输入的对话框。<br>            <span class="hljs-keyword">var</span> message =  <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;输入数据，返回数据&quot;</span>)<br>                * 返回值：获取用户输入的值<br>         <span class="hljs-number">2.</span> 与打开关闭有关的方法：<br>            <span class="hljs-title function_">close</span>()关闭浏览器窗口。<br>                * 谁调用我 ，我关谁, 可以使用<span class="hljs-title class_">Open</span>()返回<span class="hljs-variable language_">window</span>对象关闭。<br>            <span class="hljs-title function_">open</span>()打开一个新的浏览器窗口<br>                * 返回新的<span class="hljs-title class_">Window</span>对象 <br>         <span class="hljs-number">3.</span> 与定时器有关的方式<br>            <span class="hljs-built_in">setTimeout</span>()在指定的毫秒数后调用函数或计算表达式 。<br>                * 参数：<br>                    <span class="hljs-number">1.</span> js代码或者方法对象<br>                    <span class="hljs-number">2.</span> 毫秒值<br>                * 返回值：唯一标识，用于取消定时器<br>例如：<span class="hljs-keyword">var</span> timer1 = <span class="hljs-built_in">setTimeout</span>(fun,<span class="hljs-number">2000</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;boom~~&#x27;</span>);&#125; <br>            <span class="hljs-built_in">clearTimeout</span>()取消由 <span class="hljs-built_in">setTimeout</span>() 方法设置的 timeout。<br><br>            <span class="hljs-built_in">setInterval</span>()按照指定的周期（以毫秒计）来调用函数或计算表达式。(循环定时器）<br>            <span class="hljs-built_in">clearInterval</span>()取消由 <span class="hljs-built_in">setInterval</span>() 设置的 timeout。<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">3.</span> 属性：<br>        <span class="hljs-number">1.</span> 获取其他<span class="hljs-variable constant_">BOM</span>对象：<br>            history<br>              例如： <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>;  或者  history;<br>            location<br>            <span class="hljs-title class_">Navigator</span><br>            <span class="hljs-title class_">Screen</span>:<br>        <span class="hljs-number">2.</span> 获取<span class="hljs-variable constant_">DOM</span>对象<br>            <span class="hljs-variable language_">document</span>     <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>也可以，一般省略<span class="hljs-variable language_">window</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;openBtn&quot;</span>);<br><span class="hljs-number">4.</span> 特点<br>        * <span class="hljs-title class_">Window</span>对象不需要创建可以直接使用 <span class="hljs-variable language_">window</span>使用。 <span class="hljs-variable language_">window</span>.方法名();<br>        * <span class="hljs-variable language_">window</span>引用可以省略。  方法名();<br></code></pre></div></td></tr></table></figure><h5 id="2-Location：地址栏对象"><a href="#2-Location：地址栏对象" class="headerlink" title="(2) Location：地址栏对象"></a>(2) Location：地址栏对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 创建(获取)：<br><span class="hljs-number">1.</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span><br><span class="hljs-number">2.</span> location<br><span class="hljs-number">2.</span> 方法：<br>* <span class="hljs-title function_">reload</span>()重新加载当前文档。刷新<br><span class="hljs-number">3.</span> 属性 <br>* href设置或返回完整的 <span class="hljs-variable constant_">URL</span>。<br></code></pre></div></td></tr></table></figure><p> 例子</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刷新&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gobaidu&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;去百度&quot;</span>&gt;</span></span><br><span class="language-xml">    var btn = document.getElenentById(&quot;btn&quot;);</span><br><span class="language-xml">btn.onclick = function()&#123;</span><br><span class="language-xml">        location.reload();</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">var gobaidu = document.getElenentById(&quot;gobaidu&quot;);</span><br><span class="language-xml">gobaidu.onclick = function()&#123;</span><br><span class="language-xml">        location.href = &quot;https:www.baidu.com&quot;;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">    </span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h5 id="2-History：历史记录对象"><a href="#2-History：历史记录对象" class="headerlink" title="(2) History：历史记录对象"></a>(2) History：历史记录对象</h5><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 创建(获取)：<br><span class="hljs-bullet">    1.</span> window.history<br><span class="hljs-bullet">    2.</span> history<br><br><span class="hljs-bullet">2.</span> 方法：<br><span class="hljs-bullet">    *</span> back()加载 history 列表中的前一个 URL。<br><span class="hljs-bullet">    *</span> forward()加载 history 列表中的下一个 URL。<br><span class="hljs-bullet">    *</span> go(参数)加载 history 列表中的某个具体页面。<br><span class="hljs-bullet">        *</span> 参数：<br><span class="hljs-bullet">            *</span> 正数：前进几个历史记录<br><span class="hljs-bullet">            *</span> 负数：后退几个历史记录<br><span class="hljs-bullet">3.</span> 属性：<br><span class="hljs-bullet">    *</span> length返回当前窗口历史列表中的 URL 数量。  注意不是浏览器的全部历史！！！<br></code></pre></div></td></tr></table></figure><p>例如</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br></code></pre></div></td></tr></table></figure><h4 id="4-DOM"><a href="#4-DOM" class="headerlink" title="4.DOM"></a>4.DOM</h4><p>什么是 DOM？</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"> DOM 是一项 W3C (World Wide Web Consortium) 标准。<br> <br> DOM 定义了访问文档的标准：<br>“W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问、更新文档的内容、结构和样式。”<br><br>W3C DOM 标准被分为 <span class="hljs-number">3</span> 个不同的部分：<br>Core DOM - 所有文档类型的标准模型<br><span class="hljs-keyword">XML</span> <span class="hljs-title">DOM</span> - <span class="hljs-keyword">XML</span> <span class="hljs-title">文档的标准模型</span><br><span class="hljs-title">HTML</span> DOM - HTML 文档的标准模型<br></code></pre></div></td></tr></table></figure><p>概念： Document Object Model 文档对象模型</p><p> 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">W3C DOM 标准被分为 <span class="hljs-number">3</span> 个不同的部分：<br><br><span class="hljs-number">1</span>. 核心 DOM - 针对任何结构化文档的标准模型<br>（对DOM修改比较多，XML对DOM修改比较少）<br>* Document：文档对象<br>* Element：元素对象<br>* <span class="hljs-keyword">Attribute</span>：属性对象<br>* Text：文本对象<br>* Comment:注释对象<br><br>* <span class="hljs-keyword">Node</span><span class="hljs-title">：节点对象，其他5</span>个的父对象<br><br><span class="hljs-number">2</span>. <span class="hljs-keyword">XML</span> <span class="hljs-title">DOM</span> - 针对 <span class="hljs-keyword">XML</span> <span class="hljs-title">文档的标准模型</span><br><span class="hljs-title">3</span>. HTML DOM - 针对 HTML 文档的标准模型<br></code></pre></div></td></tr></table></figure><h5 id="1-核心DOM模型"><a href="#1-核心DOM模型" class="headerlink" title="(1) 核心DOM模型"></a>(1) 核心DOM模型</h5><p>​（对DOM修改比较多，XML对DOM修改比较少）</p><h6 id="①-Document：文档对象"><a href="#①-Document：文档对象" class="headerlink" title="① Document：文档对象"></a>① Document：文档对象</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 创建(获取)：在html dom模型中可以使用<span class="hljs-variable language_">window</span>对象来获取<br><span class="hljs-number">1.</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span><br><span class="hljs-number">2.</span> <span class="hljs-variable language_">document</span><br><span class="hljs-number">2.</span> 方法：<br><span class="hljs-number">1.</span> 获取<span class="hljs-title class_">Element</span>对象：<br><span class="hljs-number">1.</span> <span class="hljs-title function_">getElementById</span>()： 根据id属性值获取元素对象。id属性值一般唯一<br><span class="hljs-number">2.</span> <span class="hljs-title function_">getElementsByTagName</span>()：根据元素名称获取元素对象们。返回值是一个数组<br><span class="hljs-number">3.</span> <span class="hljs-title function_">getElementsByClassName</span>():根据<span class="hljs-title class_">Class</span>属性值获取元素对象们。返回值是一个数组<br><span class="hljs-number">4.</span> <span class="hljs-title function_">getElementsByName</span>(): 根据name属性值获取元素对象们。返回值是一个数组<br><span class="hljs-keyword">var</span> names = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">&quot;username&quot;</span>)<br>                <br><span class="hljs-number">2.</span> 创建其他<span class="hljs-variable constant_">DOM</span>对象：<br><span class="hljs-title function_">createAttribute</span>(name)<br>         <span class="hljs-title function_">createComment</span>()<br>         <span class="hljs-title function_">createElement</span>()<br>         <span class="hljs-title function_">createTextNode</span>()<br><span class="hljs-number">3.</span> 属性<br></code></pre></div></td></tr></table></figure><h6 id="②-Element：元素对象"><a href="#②-Element：元素对象" class="headerlink" title="② Element：元素对象"></a>② Element：元素对象</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 获取/创建：通过<span class="hljs-variable language_">document</span>来获取和创建<br><span class="hljs-number">2.</span> 方法：<br><span class="hljs-number">1.</span> <span class="hljs-title function_">removeAttribute</span>()：删除属性<br><span class="hljs-number">2.</span> <span class="hljs-title function_">setAttribute</span>()：设置属性<br><br>例子：<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;sss&quot;</span>);<br>a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>,<span class="hljs-string">&quot;www.baidu.com&quot;</span>)<br>a.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>)<br>    &lt;/script&gt;<br></code></pre></div></td></tr></table></figure><h6 id="③-Node：节点对象"><a href="#③-Node：节点对象" class="headerlink" title="③ Node：节点对象"></a>③ Node：节点对象</h6><p>是其他5个的父对象</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">特点：所有dom对象都可以被认为是一个节点<br>方法：<br> CRUD dom树：<br> <span class="hljs-built_in">appendChild</span>()：向节点的子节点列表的结尾添加新的子节点。<br> <span class="hljs-built_in">removeChild</span>()：删除（并返回）当前节点的指定子节点。<br> <span class="hljs-built_in">replaceChild</span>()：用新节点替换一个子节点。<br>属性：<br>parentNode 返回节点的父节点。<br></code></pre></div></td></tr></table></figure><p>例子</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Node对象&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;div1&quot;&gt;<br>        &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;<br>        div1<br>    &lt;/div&gt;<br><br>    &lt;a href=&quot;javascript:void(0);&quot; id=&quot;del&quot;&gt;删除子节点&lt;/a&gt;<br>    &lt;a href=&quot;javascript:void(0);&quot; id=&quot;add&quot;&gt;添加子节点&lt;/a&gt;<br>    &lt;!--&lt;input type=&quot;button&quot; id=&quot;del&quot; value=&quot;删除子节点&quot;&gt;--&gt;<br>&lt;script&gt;<br>    //1.获取超链接<br>    var element_a = document.getElementById(&quot;del&quot;);<br>    //2.绑定单击事件<br>    element_a.onclick = function()&#123;<br>        var div1 = document.getElementById(&quot;div1&quot;);<br>        var div2 = document.getElementById(&quot;div2&quot;);<br>        div1.removeChild(div2);<br>    &#125;<br><br>    //1.获取超链接<br>    var element_add = document.getElementById(&quot;add&quot;);<br>    //2.绑定单击事件<br>    element_add.onclick = function()&#123;<br>        var div1 = document.getElementById(&quot;div1&quot;);<br>       //给div1添加子节点<br>        //创建div节点<br>        var div3 = document.createElement(&quot;div&quot;);<br>        div3.setAttribute(&quot;id&quot;,&quot;div3&quot;);<br><br>        div1.appendChild(div3);<br>    &#125;<br><br><br>    /*<br>        超链接功能：<br>            1.可以被点击：样式<br>            2.点击后跳转到href指定的url<br><br>        需求：保留1功能，去掉2功能<br>        实现：href=&quot;javascript:void(0);&quot;<br>     */<br>    var div2 = document.getElementById(&quot;div2&quot;);<br>    var div1 = div2.parentNode;<br>    alert(div1);<br><br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><h5 id="2-HTML-DOM"><a href="#2-HTML-DOM" class="headerlink" title="(2) HTML DOM"></a>(2) HTML DOM</h5><p>HTML DOM 是 HTML 的标准<em>对象</em>模型和<em>编程接口</em>。它定义了：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">作为对象的 <span class="hljs-selector-tag">HTML</span> 元素<br>所有 <span class="hljs-selector-tag">HTML</span> 元素的属性<br>访问所有 <span class="hljs-selector-tag">HTML</span> 元素的方法<br>所有 <span class="hljs-selector-tag">HTML</span> 元素的*事件<br></code></pre></div></td></tr></table></figure><p><strong>换言之：HTML DOM 是关于如何获取、更改、添加或删除 HTML 元素的标准</strong>。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 标签体的设置和获取：innerHTML<br>&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(div1)</span></span><br><span class="language-javascript"><span class="language-xml">div.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">&quot;&lt;input type=&#x27;text&#x27;&gt;&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><br><span class="hljs-number">2.</span> 使用html元素对象的属性<br><span class="hljs-number">3.</span> 控制元素样式<br><span class="hljs-number">1.</span> 使用元素的style属性来设置<br>如：<br> <span class="hljs-comment">//修改样式方式1</span><br>        div1.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&quot;1px solid red&quot;</span>;<br>        div1.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;200px&quot;</span>;<br>        <span class="hljs-comment">//font-size--&gt; fontSize</span><br>        div1.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&quot;20px&quot;</span>;<br><span class="hljs-number">2.</span> 提前定义好类选择器的样式，通过元素的className属性来设置其<span class="hljs-keyword">class</span>属性值。<br>    .<span class="hljs-property">di</span>&#123;&#125;.<span class="hljs-property">d2</span>&#123;&#125;<br><span class="hljs-keyword">var</span> div1. = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(div1)<br>            div1.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;d2&quot;</span>;<br></code></pre></div></td></tr></table></figure><h5 id="3-事件监听机制"><a href="#3-事件监听机制" class="headerlink" title="(3) 事件监听机制"></a>(3) 事件监听机制</h5><p>概念：某些组件被执行了某些操作后，触发某些代码的执行。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了<br><span class="hljs-bullet">* </span>事件源：组件。如： 按钮 文本输入框...<br><span class="hljs-bullet">* </span>监听器：代码。<br><span class="hljs-bullet">* </span>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。<br></code></pre></div></td></tr></table></figure><p>常见的事件：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1.</span> 点击事件：<br><span class="hljs-number">1.</span> onclick：单击事件<br><span class="hljs-number">2.</span> ondblclick：双击事件<br><span class="hljs-number">2.</span> 焦点事件<br><span class="hljs-number">1.</span> onblur：失去焦点表单检验<br><span class="hljs-number">2.</span> <span class="hljs-attr">onfocus</span>:元素获得焦点。百度搜索框，点击闪烁<br><br><span class="hljs-number">3.</span> 加载事件：<br><span class="hljs-number">1.</span> onload：一张页面或一幅图像完成加载。<br><br><span class="hljs-number">4.</span> 鼠标事件：<br><span class="hljs-number">1.</span> onmousedown鼠标按钮被按下。<br><span class="hljs-number">2.</span> onmouseup鼠标按键被松开。<br><span class="hljs-number">3.</span> onmousemove鼠标被移动。<br><span class="hljs-number">4.</span> onmouseover鼠标移到某元素之上。<br><span class="hljs-number">5.</span> onmouseout鼠标从某元素移开。<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">5.</span> 键盘事件：<br><span class="hljs-number">1.</span> onkeydown某个键盘按键被按下。<br><span class="hljs-number">2.</span> onkeyup某个键盘按键被松开。<br><span class="hljs-number">3.</span> onkeypress某个键盘按键被按下并松开。<br><br><span class="hljs-number">6.</span> 选择和改变<br><span class="hljs-number">1.</span> onchange域的内容被改变。<br><span class="hljs-number">2.</span> onselect文本被选中。<br><br><span class="hljs-number">7.</span> 表单事件：<br><span class="hljs-number">1.</span> onsubmit确认按钮被点击。<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(div1).<span class="hljs-property">onsubmit</span> = fun&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不提交</span><br>&#125;<br>返回<span class="hljs-literal">false</span>不提交<br>                    <br>                    <br>                对于<br>                &lt;script&gt;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;body&gt;<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;return  checkForm();&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-comment">&lt;!--表单并不会提交，因为内部生成随机函数fun将checkForm封装</span></span><br><span class="hljs-comment"><span class="language-xml">                    function fun()&#123;</span></span><br><span class="hljs-comment"><span class="language-xml">                       checkForm();</span></span><br><span class="hljs-comment"><span class="language-xml">                    &#125;</span></span><br><span class="hljs-comment"><span class="language-xml">                 --&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">2. onreset重置按钮被点击。</span><br></code></pre></div></td></tr></table></figure><h3 id="五、Bootstrap"><a href="#五、Bootstrap" class="headerlink" title="五、Bootstrap"></a>五、Bootstrap</h3><p>概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。</p><p>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">好处：<br><span class="hljs-bullet">1.</span> 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。<br><span class="hljs-bullet">2.</span> 响应式布局。<br><span class="hljs-code"> 同一套页面可以兼容不同分辨率的设备。</span><br></code></pre></div></td></tr></table></figure><h4 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.下载Bootstrap<br><span class="hljs-number">2</span>.在项目中将这三个文件夹复制<br><span class="hljs-number">3</span>.创建<span class="hljs-selector-tag">html</span>页面，引入必要的资源文件<br></code></pre></div></td></tr></table></figure><p>名义一样，一个带min，一个不带min，min是压缩过的，把空格都去掉了，项目上线的时候用</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">bootstrap</span>.css<br><span class="hljs-keyword">bootstrap</span>.min.css<br></code></pre></div></td></tr></table></figure><h4 id="2-响应式布局"><a href="#2-响应式布局" class="headerlink" title="2.响应式布局"></a>2.响应式布局</h4><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 同一套页面可以兼容不同分辨率的设备。<br><span class="hljs-bullet">*</span> 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子<br><span class="hljs-bullet">*</span> 步骤：<br><span class="hljs-bullet">1.</span> 定义容器。相当于之前的table、<br><span class="hljs-bullet">*</span> 容器分类：<br><span class="hljs-bullet">1.</span> container：两边留白<br><span class="hljs-bullet">2.</span> container-fluid：每一种设备都是100%宽度<br><span class="hljs-bullet">2.</span> 定义行。相当于之前的tr   样式：row<br><span class="hljs-bullet">3.</span> 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目<br><span class="hljs-bullet">*</span> 设备代号：<br><span class="hljs-bullet">1.</span> xs：超小屏幕 手机 (&lt;768px)：col-xs-12<br><span class="hljs-bullet">2.</span> sm：小屏幕 平板 (≥768px)<br><span class="hljs-bullet">3.</span> md：中等屏幕 桌面显示器 (≥992px)<br><span class="hljs-bullet">4.</span> lg：大屏幕 大桌面显示器 (≥1200px)<br><br><span class="hljs-bullet">*</span> 注意：<br><span class="hljs-bullet">1.</span> 一行中如果格子数目超过12，则超出部分自动换行。<br><span class="hljs-bullet">2.</span> 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。<br><span class="hljs-bullet">3.</span> 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。<br></code></pre></div></td></tr></table></figure><p>CSS样式和JS插件</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">1. 全局CSS样式：<br>* 按钮：<span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;btn btn-default&quot;</span><br>* 图片：<br>*  <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-responsive&quot;</span>：图片在任意尺寸都占100%<br>*  图片形状<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-rounded&quot;</span>&gt;：方形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-circle&quot;</span>&gt; ： 圆形<br>*  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;img-thumbnail&quot;</span>&gt; ：相框<br>* 表格<br>* table<br>* table-bordered<br>* table-hover<br>* 表单<br>* 给表单项添加：<span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <br>2. 组件：<br>* 导航条<br>* 分页条<br>3. 插件：<br>* 轮播图<br></code></pre></div></td></tr></table></figure><h3 id="六、XML"><a href="#六、XML" class="headerlink" title="六、XML"></a>六、XML</h3><p>概念：Extensible Markup Language 可扩展标记语言，代替properties配置文件</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可扩展：标签都是自定义的。 <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span></span>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span></span><br><br><span class="hljs-bullet">*</span> 功能<br><span class="hljs-bullet">*</span> 存储数据<br><span class="hljs-bullet">1.</span> 配置文件<br><span class="hljs-bullet">2.</span> 在网络中传输<br><span class="hljs-bullet">*</span> xml与html的区别<br><span class="hljs-bullet">1.</span> xml标签都是自定义的，html标签是预定义。<br><span class="hljs-bullet">2.</span> xml的语法严格，html语法松散<br><span class="hljs-bullet">3.</span> xml是存储数据的，html是展示数据<br><br><span class="hljs-bullet">*</span> w3c:万维网联盟<br></code></pre></div></td></tr></table></figure><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">* 基本语法：<br>1. xml文档的后缀名 .xml<br>2. xml第一行必须定义为文档声明<br>3. xml文档中有且仅有一个根标签<br>4. 属性值必须使用引号(单双都可)引起来<br>5. 标签必须正确关闭<br>6. xml标签名称区分大小写<br><br>* 快速入门：<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span>     //文档声明<br><span class="hljs-tag">&lt;<span class="hljs-name">users</span>&gt;</span>//根标签<br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;1&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>male<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>female<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span><br><br><br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">* 组成部分：<br>1. 文档声明<br>1. 格式：<span class="hljs-meta">&lt;?xml 属性列表 ?&gt;</span><br>2. 属性列表：<br>* version：版本号，必须的属性<br>* encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1<br>* standalone：是否独立<br>* 取值：<br>* yes：不依赖其他文件<br>* no：依赖其他文件<br>2. 指令(了解)：结合css的<br>* <span class="hljs-meta">&lt;?xml-stylesheet type=<span class="hljs-string">&quot;text/css&quot;</span> href=<span class="hljs-string">&quot;a.css&quot;</span> ?&gt;</span><br>3. 标签：标签名称自定义的<br>* 规则：<br>* 名称可以包含字母、数字以及其他的字符 <br>* 名称不能以数字或者标点符号开始 <br>* 名称不能以字母 xml（或者 XML、Xml 等等）开始 <br>* 名称不能包含空格 <br><br>4. 属性：<br>id属性值唯一<br>5. 文本：<br>* CDATA区：在该区域中的数据会被原样展示<br>* 格式：  &lt;![CDATA[ 数据 ]]&gt;<br>比如对于 if(a<span class="hljs-tag">&lt;<span class="hljs-name">b</span> &amp;&amp; <span class="hljs-attr">a</span>&gt;</span>c)&#123;&#125;<br>转义   if(a<span class="hljs-symbol">&amp;lt;</span> b <span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;amp;</span> a <span class="hljs-symbol">&amp;gt;</span> c)&#123;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-约束"><a href="#2-约束" class="headerlink" title="2.约束"></a>2.约束</h4><p>规定xml文档的书写规则</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 作为框架的使用者(程序员)：<br><span class="hljs-bullet">1.</span> 能够在xml中引入约束文档<br><span class="hljs-bullet">2.</span> 能够简单的读懂约束文档<br><span class="hljs-code"></span><br><span class="hljs-code">* 分类：</span><br><span class="hljs-code">1. DTD:一种简单的约束技术</span><br><span class="hljs-code">2. Schema:一种复杂的约束技术</span><br></code></pre></div></td></tr></table></figure><p>DTD约束技术：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">* 引入dtd文档到xml文档中<br>* 内部dtd：将约束规则定义在xml文档中<br>* 外部dtd：将约束的规则定义在外部的dtd文件中<br>* 本地：<span class="hljs-meta">&lt;!DOCTYPE 根标签名 <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;dtd文件的位置&quot;</span>&gt;</span><br>* 网络：<span class="hljs-meta">&lt;!DOCTYPE 根标签名 <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;dtd文件名字&quot;</span> <span class="hljs-string">&quot;dtd文件的位置URL&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Schema约束技术：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">引入：<br>1.填写xml文档的根元素<br>2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>3.引入xsd文件命名空间.  <br>xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;<br>4.为每一个xsd约束声明一个前缀,作为标识 <br>    xmlns=&quot;http://www.itcast.cn/xml&quot; <br>    <br> 例如<br><span class="hljs-tag">&lt;<span class="hljs-name">students</span>   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3.解析"></a>3.解析</h4><p>操作xml文档，将文档中的数据读取到内存中</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 操作xml文档<br><span class="hljs-bullet">1.</span> 解析(读取)：将文档中的数据读取到内存中<br><span class="hljs-bullet">2.</span> 写入：将内存中的数据保存到xml文档中。持久化的存储<br><br><span class="hljs-bullet">*</span> 解析xml的方式：<br><span class="hljs-bullet">1.</span> DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<br><span class="hljs-bullet">*</span> 优点：操作方便，可以对文档进行CRUD的所有操作<br><span class="hljs-bullet">*</span> 缺点：占内存<br><span class="hljs-bullet">2.</span> SAX：逐行读取，基于事件驱动的。<br><span class="hljs-bullet">*</span> 优点：不占内存。<br><span class="hljs-bullet">*</span> 缺点：只能读取，不能增删改<br></code></pre></div></td></tr></table></figure><p>xml常见的解析器：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> JAXP：sun公司提供的解析器，支持dom和sax两种思想,比较烂，没人用<br><span class="hljs-bullet">2.</span> DOM4J：一款非常优秀的解析器<br><span class="hljs-bullet">3.</span> Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<br><span class="hljs-bullet">4.</span> PULL：Android操作系统内置的解析器，sax方式的。<br></code></pre></div></td></tr></table></figure><p> Jsoup</p><p>jsoup 是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">快速入门：<br>* 步骤：<br><span class="hljs-number">1.</span> 导入jar包<br><span class="hljs-number">2.</span> 获取Document对象<br><span class="hljs-number">3.</span> 获取对应的标签Element对象<br><span class="hljs-number">4.</span> 获取数据<br><br>* 代码：<br><span class="hljs-comment">//2.1获取student.xml的path</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> JsoupDemo1.class.getClassLoader().getResource(<span class="hljs-string">&quot;student.xml&quot;</span>).getPath();<br><span class="hljs-comment">//2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> Jsoup.parse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path), <span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-comment">//3.获取元素对象 Element</span><br>        <span class="hljs-type">Elements</span> <span class="hljs-variable">elements</span> <span class="hljs-operator">=</span> document.getElementsByTag(<span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(elements.size());<br>  <span class="hljs-comment">//3.1获取第一个name的Element对象</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> elements.get(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//3.2获取数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> element.text();<br>        System.out.println(name);<br><br></code></pre></div></td></tr></table></figure><p> 对象的使用：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> Jsoup：工具类，可以解析html或xml文档，返回Document<br>* parse：解析html或xml文档，返回Document<br>* parse (File in, String charsetName)：解析xml或html文件的。<br>* parse (String html)：解析xml或html字符串(整个xml文档当作字符串)<br>* parse (URL url, <span class="hljs-type">int</span> timeoutMillis)：通过网络路径获取指定的html或xml的文档对象<span class="hljs-comment">/**爬虫***/</span><br><span class="hljs-number">2.</span> Document：文档对象。代表内存中的dom树<br>* 获取Element对象<br>* getElementById (String id)：根据id属性值获取唯一的element对象<br>* getElementsByTag (String tagName)：根据标签名称获取元素对象集合<br>* getElementsByAttribute (String key)：根据属性名称获取元素对象集合<br>* getElementsByAttributeValue (String key, String value)：根据对应的属性名和属性值获取元素对象集合<br><span class="hljs-number">3.</span> Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用<br><span class="hljs-number">4.</span> Element：元素对象<br>注意获取Element是获取的DOM树上的任意一个，下边这个是获取的子标签<br><span class="hljs-number">1.</span> 获取子元素对象<br>* getElementById (String id)：根据id属性值获取唯一的element对象<br>* getElementsByTag (String tagName)：根据标签名称获取元素对象集合<br>* getElementsByAttribute (String key)：根据属性名称获取元素对象集合<br>* getElementsByAttributeValue (String key, String value)：根据对应的属性名和属性值获取元素对象集合<br><br><span class="hljs-number">2.</span> 获取属性值<br>* String <span class="hljs-title function_">attr</span><span class="hljs-params">(String key)</span>：根据属性名称获取属性值<br><span class="hljs-number">3.</span> 获取文本内容<br>* String <span class="hljs-title function_">text</span><span class="hljs-params">()</span>:获取文本内容<br>* String <span class="hljs-title function_">html</span><span class="hljs-params">()</span>:获取标签体的所有内容(包括字标签的字符串内容)<br><span class="hljs-number">5.</span> Node：节点对象<br>* 是Document和Element的父类<br></code></pre></div></td></tr></table></figure><p>快捷查询方式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> selector:选择器<br>* 使用的方法：Elements<span class="hljs-title function_">select</span><span class="hljs-params">(String cssQuery)</span><br>* 语法：参考Selector类中定义的语法<br><span class="hljs-number">2.</span> XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<br>* 使用Jsoup的Xpath需要额外导入jar包。<br>* 查询w3cshool参考手册，使用xpath的语法完成查询<br>* 代码：<br><span class="hljs-comment">//1.获取student.xml的path</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> JsoupDemo6.class.getClassLoader().getResource(<span class="hljs-string">&quot;student.xml&quot;</span>).getPath();<br>        <span class="hljs-comment">//2.获取Document对象,是jsoup的，不支持xpath</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> Jsoup.parse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path), <span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//3.根据document对象，创建JXDocument对象</span><br>        <span class="hljs-type">JXDocument</span> <span class="hljs-variable">jxDocument</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JXDocument</span>(document);<br><br>        <span class="hljs-comment">//4.结合xpath语法查询</span><br>        <span class="hljs-comment">//4.1查询所有student标签</span><br>        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="hljs-string">&quot;//student&quot;</span>);<br>        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes) &#123;<br>            System.out.println(jxNode);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br><br>        <span class="hljs-comment">//4.2查询所有student标签下的name标签</span><br>        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="hljs-string">&quot;//student/name&quot;</span>);<br>        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes2) &#123;<br>            System.out.println(jxNode);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br><br>        <span class="hljs-comment">//4.3查询student标签下带有id属性的name标签</span><br>        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="hljs-string">&quot;//student/name[@id]&quot;</span>);<br>        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes3) &#123;<br>            System.out.println(jxNode);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>        <span class="hljs-comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span><br><br>        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="hljs-string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>);<br>        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes4) &#123;<br>            System.out.println(jxNode);<br>        &#125;<br></code></pre></div></td></tr></table></figure><h3 id="七、Servlet和tomcat"><a href="#七、Servlet和tomcat" class="headerlink" title="七、Servlet和tomcat"></a>七、Servlet和tomcat</h3><h4 id="1-web相关概念回顾"><a href="#1-web相关概念回顾" class="headerlink" title="1.web相关概念回顾"></a>1.web相关概念回顾</h4><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 软件架构<br><span class="hljs-bullet">1.</span> C/S：客户端/服务器端<br><span class="hljs-bullet">2.</span> B/S：浏览器/服务器端<br><br><span class="hljs-bullet">2.</span> 资源分类<br><span class="hljs-bullet">1.</span> 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析<br><span class="hljs-bullet">*</span> 如： html,css,JavaScript<br><span class="hljs-bullet">2.</span> 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器<br><span class="hljs-bullet">*</span> 如：servlet/jsp,php,asp....<br></code></pre></div></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">3.</span> 网络通信三要素<br><span class="hljs-bullet">1.</span> IP：电子设备(计算机)在网络中的唯一标识。<br><span class="hljs-bullet">2.</span> 端口：应用程序在计算机中的唯一标识。 0~65536<br><span class="hljs-bullet">3.</span> 传输协议：规定了数据传输的规则<br><span class="hljs-bullet">1.</span> 基础协议：<br><span class="hljs-bullet">1.</span> tcp:安全协议，三次握手。 速度稍慢<br><span class="hljs-bullet">2.</span> udp：不安全协议。 速度快<br></code></pre></div></td></tr></table></figure><h4 id="2-web服务器软件："><a href="#2-web服务器软件：" class="headerlink" title="2.web服务器软件："></a>2.web服务器软件：</h4><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 服务器：安装了服务器软件的计算机<br><span class="hljs-bullet">*</span> 服务器软件：接收用户的请求，处理请求，做出响应<br><span class="hljs-bullet">*</span> web服务器软件：接收用户的请求，处理请求，做出响应。<br><span class="hljs-bullet">*</span> 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目<br><span class="hljs-bullet">*</span> web容器<br></code></pre></div></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">* 常见的<span class="hljs-keyword">java相关的web服务器软件：</span><br><span class="hljs-keyword"></span>* webLogic：<span class="hljs-keyword">oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</span><br><span class="hljs-keyword"></span>* webSphere：IBM公司，大型的<span class="hljs-keyword">JavaEE服务器，支持所有的JavaEE规范，收费的。</span><br><span class="hljs-keyword"></span>* <span class="hljs-keyword">JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</span><br><span class="hljs-keyword"></span>* Tomcat：Apache基金组织，中小型的<span class="hljs-keyword">JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">JavaEE是什么？</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</span><br><span class="hljs-keyword"></span><br></code></pre></div></td></tr></table></figure><h5 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="(1) Tomcat"></a>(1) Tomcat</h5><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">Tomcat：web服务器软件    <br>1. 下载：http:<span class="hljs-comment">//tomcat.apache.org/    </span><br>2. 安装：解压压缩包即可。     * 注意：安装目录建议不要有中文和空格    <br>3. 卸载：删除目录就行了    <br>4. 启动：        <br><span class="hljs-comment">* bin/startup.bat ,双击运行该文件即可        </span><br><span class="hljs-comment">* 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人               </span><br><span class="hljs-comment">    * 可能遇到的问题：            </span><br>    1. 黑窗口一闪而过：               <br><span class="hljs-comment">    * 原因： 没有正确配置JAVA_HOME环境变量                </span><br><span class="hljs-comment">    * 解决方案：正确配置JAVA_HOME环境变量           </span><br>   2. 启动报错：                <br>   1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -<span class="hljs-keyword">ano</span>      找到PID，去任务管理器关闭          <br>   2. 温柔：修改自身的端口号                    <br><span class="hljs-comment">   * 在tocmcat/conf/server.xml                    </span><br><span class="hljs-comment">   * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    </span><br>   一般会将tomcat的默认端口号修改为80。80端口是http协议的默认端口。      * 好处：在访问时，就不用输入端口号    <br>   5. 关闭：        <br>   1. 正常关闭：            <br><span class="hljs-comment">   * 打开bin/shutdown.bat           </span><br><span class="hljs-comment">   * ctrl+c        </span><br>   2. 强制关闭：            <br><span class="hljs-comment">   * 点击启动窗口的×    </span><br>   6. 配置:        <br><span class="hljs-comment">   * 部署项目的方式：            </span><br>   1. 直接将项目放到webapps目录下即可。         <br><span class="hljs-comment">        * /hello：项目的访问路径--&gt;虚拟目录                </span><br><span class="hljs-comment">        * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩，删除war包也会自动删除            </span><br>        2. 不想把war包放过去，想指定路径，(这里直接修改配置文件不安全，建议3)<br>           配置<span class="hljs-keyword">conf</span>/server.xml文件,在&lt;Host&gt;标签体中配置               <br>            &lt;Context docBase=<span class="hljs-string">&quot;D:\hello&quot;</span> path=<span class="hljs-string">&quot;/hehe&quot;</span> /&gt;                <br><span class="hljs-comment">           * docBase:项目存放的路径                </span><br><span class="hljs-comment">            * path：虚拟目录           </span><br>        3. 在<span class="hljs-keyword">conf</span>\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=<span class="hljs-string">&quot;D:\hello&quot;</span> /&gt;                <br><span class="hljs-comment">        * 虚拟目录：xml文件的名称   </span><br>               <br>               <br>     静态项目和动态项目：<br><span class="hljs-comment">       * 目录结构    </span><br><span class="hljs-comment">            * java动态项目的目录结构：                    </span><br>                -- 项目的根目录                        <br>            -- WEB-<span class="hljs-keyword">INF</span>目录（有就是动态项目）：                         <br>            -- web.xml：web项目的核心配置文件                     <br>            -- classes目录：放置字节码文件的目录             <br>            -- lib目录：放置依赖的jar包<br></code></pre></div></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。<br>IDEA乱码，改下125位置的GBK就行<br></code></pre></div></td></tr></table></figure><h4 id="3-Servlet"><a href="#3-Servlet" class="headerlink" title="3.Servlet"></a>3.Servlet</h4><p> 全称呼 server applet</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 概念：运行在服务器端的小程序<br><span class="hljs-bullet">*</span> Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。<br><span class="hljs-bullet">*</span> 将来我们自定义一个类，实现Servlet接口，复写方法。<br></code></pre></div></td></tr></table></figure><h5 id="1-快速入门-1"><a href="#1-快速入门-1" class="headerlink" title="(1) 快速入门"></a>(1) 快速入门</h5><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">* 快速入门：<br>1. 创建JavaEE项目<br>2. 定义一个类，实现Servlet接口<br>* public class ServletDemo1 implements Servlet<br>3. 实现接口中的抽象方法<br>在service方法打印一句话<br>4. 配置Servlet<br> 在web.xml中配置：<br>    <span class="hljs-comment">&lt;!--配置Servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>demo1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>demo1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/demo1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><br></code></pre></div></td></tr></table></figure><h5 id="2-执行原理"><a href="#2-执行原理" class="headerlink" title="(2) 执行原理"></a>(2) 执行原理</h5><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 执行原理：<br><span class="hljs-bullet">1.</span> 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径<br><span class="hljs-bullet">2.</span> 查找web.xml文件，是否有对应的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span></span>标签体内容。<br><span class="hljs-bullet">3.</span> 如果有，则在找到对应的<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span></span>全类名<br><span class="hljs-bullet">4.</span> tomcat会将字节码文件加载进内存，并且创建其对象<br><span class="hljs-bullet">5.</span> 调用其方法<br></code></pre></div></td></tr></table></figure><h5 id="3-Servlet中的生命周期方法"><a href="#3-Servlet中的生命周期方法" class="headerlink" title="(3) Servlet中的生命周期方法"></a>(3) Servlet中的生命周期方法</h5><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> Servlet中的生命周期方法：<br><span class="hljs-bullet">1.</span> 被创建：执行init方法，只执行一次<br><span class="hljs-bullet">*</span> Servlet什么时候被创建？<br><span class="hljs-bullet">*</span> 默认情况下，第一次被访问时，Servlet被创建<br><span class="hljs-bullet">*</span> 可以配置执行Servlet的创建时机。<br><span class="hljs-bullet">*</span> 在<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span>标签下配置<br><span class="hljs-bullet">1.</span> 第一次被访问时，创建<br><span class="hljs-bullet">                *</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span></span>的值为负数<br><span class="hljs-bullet">            2.</span> 在服务器启动时，创建<br><span class="hljs-bullet">                *</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span></span>的值为0或正整数<br><span class="hljs-bullet">*</span> Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的<br><span class="hljs-bullet">*</span> 多个用户同时访问时，可能存在线程安全问题。<br><span class="hljs-bullet">*</span> 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值<br><span class="hljs-bullet">2.</span> 提供服务：执行service方法，执行多次<br><span class="hljs-bullet">*</span> 每次访问Servlet时，Service方法都会被调用一次。<br><span class="hljs-bullet">3.</span> 被销毁：执行destroy方法，只执行一次<br><span class="hljs-bullet">*</span> Servlet被销毁时执行。服务器关闭时，Servlet被销毁<br><span class="hljs-bullet">*</span> 只有服务器正常关闭时，才会执行destroy方法。<br><span class="hljs-bullet">*</span> destroy方法在Servlet被销毁之前执行，一般用于释放资源<br></code></pre></div></td></tr></table></figure><h4 id="4-Servlet3-0："><a href="#4-Servlet3-0：" class="headerlink" title="4.Servlet3.0："></a>4.Servlet3.0：</h4><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">好处：<br>* 支持注解配置。可以不需要web.<span class="hljs-built_in">xml</span>了。<br>IEDA配置，建立JAVA模块，添加框架和支持，web不勾选<span class="hljs-built_in">XML</span>，运行配置TOMCAT，注意没有servlet可以，文件项目结构模块，导入库<br></code></pre></div></td></tr></table></figure><h5 id="1-使用步骤："><a href="#1-使用步骤：" class="headerlink" title="(1) 使用步骤："></a>(1) 使用步骤：</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">* 步骤：<br><span class="hljs-number">1.</span> 创建JavaEE项目，选择Servlet的版本<span class="hljs-number">3.0</span>以上，可以不创建web.xml<br><span class="hljs-number">2.</span> 定义一个类，实现Servlet接口<br><span class="hljs-number">3.</span> 复写方法<br><span class="hljs-number">4.</span> 在类上使用<span class="hljs-meta">@WebServlet</span>注解，进行配置<br><span class="hljs-meta">@WebServlet(&quot;资源路径&quot;)</span><br><br>    其中value可以省略，直接写资源路径：<span class="hljs-meta">@WebServlet(/demo)</span><br>    <span class="hljs-meta">@WebServlet(&quot;资源路径&quot;)</span>他的内部就是：<br>    <br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WebServlet &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//相当于&lt;Servlet-name&gt;</span><br><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//代表urlPatterns()属性配置</span><br><br>    String[] urlPatterns() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//相当于&lt;url-pattern&gt;</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">loadOnStartup</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//相当于&lt;load-on-startup&gt;</span><br><br>    WebInitParam[] initParams() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">asyncSupported</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>    String <span class="hljs-title function_">smallIcon</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">largeIcon</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    String <span class="hljs-title function_">displayName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-IDEA与tomcat的相关配置"><a href="#5-IDEA与tomcat的相关配置" class="headerlink" title="5.IDEA与tomcat的相关配置"></a>5.IDEA与tomcat的相关配置</h4><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-number">1.</span> IDEA会为每一个tomcat部署的项目单独建立一份配置文件<br>* 查看控制台的<span class="hljs-built_in">log</span>：<span class="hljs-keyword">Using</span> CATALINA_BASE:   <span class="hljs-string">&quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;</span><br><br><span class="hljs-number">2.</span> 工作空间项目 和 tomcat部署的web项目<br>* tomcat真正访问的是“tomcat部署的web项目”，<span class="hljs-string">&quot;tomcat部署的web项目&quot;</span>对应着<span class="hljs-string">&quot;工作空间项目&quot;</span> 的web目录下的所有资源<br>* WEB-<span class="hljs-literal">INF</span>目录下的资源不能被浏览器直接访问。<br><span class="hljs-number">3.</span> 断点调试：使用<span class="hljs-string">&quot;小虫子&quot;</span>启动 dubug 启动<br></code></pre></div></td></tr></table></figure><h4 id="6-Servlet："><a href="#6-Servlet：" class="headerlink" title="6.Servlet："></a>6.Servlet：</h4><div class="hljs code-wrapper"><pre><code class="hljs">1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0 注解配置6. Servlet的体系结构    Servlet -- 接口        |儿子    GenericServlet -- 抽象类（并不用）        |孙子    HttpServlet  -- 抽象类（用它）    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法7. Servlet相关配置    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ：            比如：  @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;，&quot;/*&quot;&#125;)                    2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre></div><h3 id="八、HTTP："><a href="#八、HTTP：" class="headerlink" title="八、HTTP："></a>八、HTTP：</h3><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 传输协议：定义了，客户端和服务器端通信时，发送数据的格式<br><span class="hljs-bullet">*</span> 特点：<br><span class="hljs-bullet">1.</span> 基于TCP/IP的高级协议<br><span class="hljs-bullet">2.</span> 默认端口号:80<br><span class="hljs-bullet">3.</span> 基于请求/响应模型的:一次请求对应一次响应<br><span class="hljs-bullet">4.</span> 无状态的：每次请求之间相互独立，不能交互数据<br><br><span class="hljs-bullet">*</span> 历史版本：<br><span class="hljs-bullet">*</span> 1.0：每一次请求响应都会建立新的连接<br><span class="hljs-bullet">*</span> 1.1：复用连接<br></code></pre></div></td></tr></table></figure><h4 id="1-请求消息数据格式"><a href="#1-请求消息数据格式" class="headerlink" title="1.请求消息数据格式"></a>1.请求消息数据格式</h4><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="(1) 请求行"></a>(1) 请求行</h5><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">请求方式 请求url 请求协议/版本<br>格式： GET /login.htmlHTTP/1.1<br><br><span class="hljs-bullet">*</span> 请求方式：<br><span class="hljs-bullet">*</span> HTTP协议有7中请求方式，常用的有2种<br><span class="hljs-bullet">*</span> GET：<br><span class="hljs-bullet">1.</span> 请求参数在请求行中，在url后。<br><span class="hljs-bullet">2.</span> 请求的url长度有限制的<br><span class="hljs-bullet">3.</span> 不太安全<br><span class="hljs-bullet">*</span> POST：<br><span class="hljs-bullet">1.</span> 请求参数在请求体中<br><span class="hljs-bullet">2.</span> 请求的url长度没有限制的<br><span class="hljs-bullet">3.</span> 相对安全<br></code></pre></div></td></tr></table></figure><h5 id="2-请求头"><a href="#2-请求头" class="headerlink" title="(2) 请求头"></a>(2) 请求头</h5><p>客户端浏览器告诉服务器一些信息</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">格式：<br><span class="hljs-code">请求头名称: 请求头值</span><br><span class="hljs-code"></span><br>常见的请求头：<br><span class="hljs-bullet">1.</span> User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息<br><span class="hljs-bullet">*</span> 可以在服务器端获取该头的信息，解决浏览器的兼容性问题<br><br><span class="hljs-bullet">2.</span> Referer：http://localhost/login.html<br><span class="hljs-bullet">*</span> 告诉服务器，我(当前请求)从哪里来？<br><span class="hljs-bullet">*</span> 作用：<br><span class="hljs-bullet">1.</span> 防盗链：<br><span class="hljs-bullet">2.</span> 统计工作：<br></code></pre></div></td></tr></table></figure><h5 id="3-请求空行"><a href="#3-请求空行" class="headerlink" title="(3) 请求空行"></a>(3) 请求空行</h5><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">空行，就是用于分割<span class="hljs-keyword">POST</span>请求的请求头，和请求体的。<br></code></pre></div></td></tr></table></figure><h5 id="4-请求体-正文"><a href="#4-请求体-正文" class="headerlink" title="(4) 请求体(正文)"></a>(4) 请求体(正文)</h5><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>封装POST请求消息的请求参数的<br></code></pre></div></td></tr></table></figure><h5 id="5-请求数据例子"><a href="#5-请求数据例子" class="headerlink" title="(5)请求数据例子"></a>(5)请求数据例子</h5><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">字符串格式：<br>POST /login.htmlHTTP/1.1/*请求行*/<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>Accept-Encoding: gzip, deflate<br>Referer: http://localhost/login.html<br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1   上边是请求头<br>请求空行<br>username=zhangsan  请求体<br></code></pre></div></td></tr></table></figure><h4 id="2-响应消息数据格式"><a href="#2-响应消息数据格式" class="headerlink" title="2.响应消息数据格式"></a>2.响应消息数据格式</h4><figure class="highlight vbscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vbscript"><span class="hljs-built_in">request</span>对象和<span class="hljs-built_in">response</span>对象的原理<br><span class="hljs-number">1.</span> <span class="hljs-built_in">request</span>和<span class="hljs-built_in">response</span>对象是由服务器创建的。我们来使用它们<br><span class="hljs-number">2.</span> <span class="hljs-built_in">request</span>对象是来获取请求消息，<span class="hljs-built_in">response</span>对象是来设置响应消息<br></code></pre></div></td></tr></table></figure><h5 id="1-Request："><a href="#1-Request：" class="headerlink" title="(1) Request："></a>(1) Request：</h5><p>request对象继承体系结构：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">ServletRequest--接口<br><span class="hljs-string">|继承</span><br>HttpServletRequest-- 接口<br><span class="hljs-string">|实现</span><br>org.apache.catalina.connector.RequestFacade 类(tomcat)<br></code></pre></div></td></tr></table></figure><p>request功能：</p><div class="hljs code-wrapper"><pre><code class="hljs">1. 获取请求消息数据    1. 获取请求行数据        * GET /day14/demo1?name=zhangsan HTTP/1.1        * 方法：            1. 获取请求方式 ：GET                * String getMethod()              2. (*)获取虚拟目录：/day14                * String getContextPath()            3. 获取Servlet路径: /demo1                * String getServletPath()            4. 获取get方式请求参数：name=zhangsan                * String getQueryString()            5. (*)获取请求URI：/day14/demo1                * String getRequestURI():/day14/demo1                * StringBuffer getRequestURL()  :http://localhost/day14/demo1    URL和URI区别：        * URL:统一资源定位符 ： http://localhost/day14/demo1中华人民共和国        * URI：统一资源标识符 : /day14/demo1共和国                            6. 获取协议及版本：HTTP/1.1                * String getProtocol()            7. 获取客户机的IP地址：                * String getRemoteAddr()                    2. 获取请求头数据        * 方法：            * (*)String getHeader(String name):通过请求头的名称获取请求头的值            * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称                3. 获取请求体数据:        * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数        * 步骤：            1. 获取流对象                BufferedReader getReader()：获取字符输入流，只能操作字符数据                ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                * 在文件上传知识点后讲解            2. 再从流对象中拿数据</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">2. 其他功能：    1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数        1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123        2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game        3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称                比如 只能获取xx，不能获取game        4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合                全部获取的到 xx和game        * 中文乱码问题：            * get方式：tomcat 8 已经将get方式乱码问题解决了            * post方式：会乱码                * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">    2. 请求转发：一种在服务器内部的资源跳转方式        1. 步骤：            1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)            2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)         2. 特点：            1. 浏览器地址栏路径不发生变化            2. 只能转发到当前服务器内部资源中。            3. 转发是一次请求（抓包之后只有一个请求）    3. 共享数据：        * 域对象：一个有作用范围的对象，可以在范围内共享数据        * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据        * 方法：            1. void setAttribute(String name,Object obj):存储数据            2. Object getAttitude(String name):通过键获取值            3. void removeAttribute(String name):通过键移除键值对    4. 获取ServletContext：        * ServletContext getServletContext()</code></pre></div><h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><div class="hljs code-wrapper"><pre><code class="hljs">* 用户登录案例需求：    1.编写login.html登录页面        username &amp; password 两个输入框    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表    3.使用JdbcTemplate技术封装JDBC    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误* 分析* 开发步骤    1. 创建项目，导入html页面，配置文件，jar包    2. 创建数据库环境        CREATE DATABASE day14;        USE day14;        CREATE TABLE USER(                    id INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(32) UNIQUE NOT NULL,            PASSWORD VARCHAR(32) NOT NULL        );    3. 创建包cn.itcast.domain,创建类User        package cn.itcast.domain;        /**         * 用户的实体类         */        public class User &#123;                    private int id;            private String username;            private String password;</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">            public int getId() &#123;                return id;            &#125;                    public void setId(int id) &#123;                this.id = id;            &#125;                    public String getUsername() &#123;                return username;            &#125;                    public void setUsername(String username) &#123;                this.username = username;            &#125;                    public String getPassword() &#123;                return password;            &#125;                    public void setPassword(String password) &#123;                this.password = password;            &#125;                    @Override            public String toString() &#123;                return &quot;User&#123;&quot; +                        &quot;id=&quot; + id +                        &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                        &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                        &#39;&#125;&#39;;            &#125;        &#125;    4. 创建包cn.itcast.util,编写工具类JDBCUtils        package cn.itcast.util;        import com.alibaba.druid.pool.DruidDataSourceFactory;                import javax.sql.DataSource;        import javax.xml.crypto.Data;        import java.io.IOException;        import java.io.InputStream;        import java.sql.Connection;        import java.sql.SQLException;        import java.util.Properties;                /**         * JDBC工具类 使用Durid连接池         */        public class JDBCUtils &#123;                    private static DataSource ds ;                    static &#123;                        try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    //使用ClassLoader加载配置文件，获取字节输入流                    InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);                    pro.load(is);                            //2.初始化连接池对象                    ds = DruidDataSourceFactory.createDataSource(pro);                        &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;                    /**             * 获取连接池对象             */            public static DataSource getDataSource()&#123;                return ds;            &#125;</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">            /**             * 获取连接Connection对象             */            public static Connection getConnection() throws SQLException &#123;                return  ds.getConnection();            &#125;        &#125;    5. 创建包cn.itcast.dao,创建类UserDao,提供login方法                package cn.itcast.dao;        import cn.itcast.domain.User;        import cn.itcast.util.JDBCUtils;        import org.springframework.dao.DataAccessException;        import org.springframework.jdbc.core.BeanPropertyRowMapper;        import org.springframework.jdbc.core.JdbcTemplate;                /**         * 操作数据库中User表的类         */        public class UserDao &#123;                    //声明JDBCTemplate对象共用            private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                    /**             * 登录方法             * @param loginUser 只有用户名和密码             * @return user包含用户全部数据,没有查询到，返回null             */            public User login(User loginUser)&#123;                try &#123;                    //1.编写sql                    String sql = &quot;select * from user where username = ? and password = ?&quot;;                    //2.调用query方法                    User user = template.queryForObject(sql,                            new BeanPropertyRowMapper&lt;User&gt;(User.class),                            loginUser.getUsername(), loginUser.getPassword());</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">                    return user;                &#125; catch (DataAccessException e) &#123;                    e.printStackTrace();//记录日志                    return null;                &#125;            &#125;        &#125;        6. 编写cn.itcast.web.servlet.LoginServlet类        package cn.itcast.web.servlet;        import cn.itcast.dao.UserDao;        import cn.itcast.domain.User;                import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">        @WebServlet(&quot;/loginServlet&quot;)        public class LoginServlet extends HttpServlet &#123;</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">            @Override            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                //1.设置编码                req.setCharacterEncoding(&quot;utf-8&quot;);                //2.获取请求参数                String username = req.getParameter(&quot;username&quot;);                String password = req.getParameter(&quot;password&quot;);                //3.封装user对象                User loginUser = new User();                loginUser.setUsername(username);                loginUser.setPassword(password);                        //4.调用UserDao的login方法                UserDao dao = new UserDao();                User user = dao.login(loginUser);                        //5.判断user                if(user == null)&#123;                    //登录失败                    req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp);                &#125;else&#123;                    //登录成功                    //存储数据                    req.setAttribute(&quot;user&quot;,user);                    //转发                    req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp);                &#125;                    &#125;                    @Override            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                this.doGet(req,resp);            &#125;        &#125;    7. 编写FailServlet和SuccessServlet类        @WebServlet(&quot;/successServlet&quot;)        public class SuccessServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //获取request域中共享的user对象                User user = (User) request.getAttribute(&quot;user&quot;);                        if(user != null)&#123;                    //给页面写一句话                            //设置编码                    response.setContentType(&quot;text/html;charset=utf-8&quot;);                    //输出                    response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;);                &#125;</code></pre></div><p>​</p><div class="hljs code-wrapper"><pre><code class="hljs">            &#125;        @WebServlet(&quot;/failServlet&quot;)        public class FailServlet extends HttpServlet &#123;            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                //给页面写一句话                        //设置编码                response.setContentType(&quot;text/html;charset=utf-8&quot;);                //输出                response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);                    &#125;                    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;                this.doPost(request,response);            &#125;        &#125;    8. login.html中form表单的action路径的写法        * 虚拟目录+Servlet的资源路径    9. BeanUtils工具类，简化数据封装        * 用于封装JavaBean的        1. JavaBean：标准的Java类            1. 要求：                1. 类必须被public修饰                2. 必须提供空参的构造器                3. 成员变量必须使用private修饰                4. 提供公共setter和getter方法            2. 功能：封装数据        2. 概念：            成员变量：            属性：setter和getter方法截取后的产物                例如：getUsername() --&gt; Username--&gt; username        3. 方法：            1. setProperty()            2. getProperty()            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识笔记</title>
    <link href="/2022/04/28/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/28/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>第一章 开发前言</p><h3 id="1-1-什么是Java语言"><a href="#1-1-什么是Java语言" class="headerlink" title="1.1 什么是Java语言"></a>1.1 什么是Java语言</h3><p>Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><p>&#x3D;&#x3D;三大特性：封装、继承、多态&#x3D;&#x3D;</p><h3 id="1-2-DOS命令操作符号"><a href="#1-2-DOS命令操作符号" class="headerlink" title="1.2 DOS命令操作符号"></a>1.2 DOS命令操作符号</h3><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos">盘符切换命令盘符名:<br>查看当前文件夹<span class="hljs-built_in">dir</span><br>进入文件夹命令<span class="hljs-built_in">cd</span> 文件夹名<br>退出文件夹命令<span class="hljs-built_in">cd</span>..<br>退出到磁盘根目录    <span class="hljs-built_in">cd</span>\<br>清屏    <span class="hljs-built_in">cls</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-Java虚拟机——JVM"><a href="#1-3-Java虚拟机——JVM" class="headerlink" title="1.3 Java虚拟机——JVM"></a>1.3 Java虚拟机——JVM</h3><p>JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM 之上。</p><p><strong>Java语言特性</strong></p><p>跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</p><p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库 </p><p>JDK (Java Development Kit)：是Java程序开发工具包，&#x3D;&#x3D;包含JRE&#x3D;&#x3D;和开发人员使用的工具。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">编译：javac Java源文件名.后缀名<br>运行：java 类名字<br></code></pre></div></td></tr></table></figure><p>main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。</p><h3 id="1-4-命名规则"><a href="#1-4-命名规则" class="headerlink" title="1.4 命名规则"></a>1.4 命名规则</h3><p>命名规则： 硬性要求</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">标识符可以包含英文字母<span class="hljs-number">26</span>个(区分大小写) 、<span class="hljs-number">0</span>-<span class="hljs-number">9</span>数字 、$（美元符号） 和_（下划线） 。<br>标识符不能以数字开头。<br>标识符不能是关键字。<br></code></pre></div></td></tr></table></figure><p>命名规范： 软性建议</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。<br>方法名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。<br>变量名规范：全部小写。<br></code></pre></div></td></tr></table></figure><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1常量"><a href="#2-1常量" class="headerlink" title="2.1常量"></a>2.1常量</h3><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">整数常量：所有的整数<span class="hljs-number">0</span>，<span class="hljs-number">1</span>， <span class="hljs-number">567</span>， <span class="hljs-number">-9</span><br>小数常量：所有的小数<span class="hljs-number">0.0</span>， <span class="hljs-number">-0.1</span>， <span class="hljs-number">2.55</span><br>字符常量：单引号引起来,只能写一个字符,必须有内容<span class="hljs-string">&#x27;a&#x27;</span> ， <span class="hljs-string">&#x27; &#x27;</span>， <span class="hljs-string">&#x27;好&#x27;</span><br>字符串常量：双引号引起来,可以写多个字符,也可以不写<span class="hljs-string">&quot;A&quot;</span> ，<span class="hljs-string">&quot;Hello&quot;</span> ，<span class="hljs-string">&quot;你好&quot;</span> ，<span class="hljs-string">&quot;&quot;</span><br>布尔常量：只有两个值（流程控制中讲解） <span class="hljs-literal">true</span> ， <span class="hljs-literal">false</span><br>空常量：只有一个值（引用数据类型中讲解） <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure><h3 id="2-2变量"><a href="#2-2变量" class="headerlink" title="2.2变量"></a>2.2变量</h3><p>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">d</span><br></code></pre></div></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java的数据类型分为两大类：</span><br><span class="hljs-keyword"></span>基本数据类型：包括 整数、浮点数、字符、布尔。<br>引用数据类型：包括 类、数组、接口 、枚举、注解。<br></code></pre></div></td></tr></table></figure><p><strong>基本数据类型</strong></p><p>四类八种基本数据类型：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">数据类型关键字内存占用取值范围<br>字节型byte 1个字节<span class="hljs-string">-128</span>~127<br>短整型short  2个字节<span class="hljs-string">-32768</span>~32767<br>整型int（默认）    4个字节   <span class="hljs-string">-231</span>次方~2的31次方<span class="hljs-string">-1</span><br>长整型long 8个字节    <span class="hljs-string">-2</span>的63次方~2的63次方<span class="hljs-string">-1</span><br>单精度浮点数  float  4个字节    1.4013E<span class="hljs-string">-45</span>~3.4028E<span class="hljs-string">+38</span><br>双精度浮点数double（默认）    8个字节      4.9E<span class="hljs-string">-324</span>~1.7977E<span class="hljs-string">+308</span><br>字符型char 2个字节0<span class="hljs-string">-65535</span><br>布尔类型  boolean 1个字节true，false<br></code></pre></div></td></tr></table></figure><p>四类</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">字符型 （<span class="hljs-type">char</span>）<br>整形 (<span class="hljs-type">byte</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">long</span> )<br>布尔型 (<span class="hljs-type">boolean</span>)<br>浮点型(<span class="hljs-type">float</span> <span class="hljs-type">double</span>)<br></code></pre></div></td></tr></table></figure><p> 变量名称：在同一个大括号范围内，变量的名字不可以相同。<br>        变量赋值：定义的变量，不赋值不能使用。</p><p>&#x3D;&#x3D;可以一条语句赋值多个变量，但是不能在定义的时候用&#x3D;&#x3D;</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">int a<span class="hljs-operator">=</span>b<span class="hljs-operator">=</span>c<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">; 错误     应该是  int a,b,c; a=b=c=3;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-3数据类型转换"><a href="#2-3数据类型转换" class="headerlink" title="2.3数据类型转换"></a>2.3数据类型转换</h3><p>范围小的类型向范围大的类型提升， &#x3D;&#x3D;byte、short、char 运算时直接提升为int&#x3D;&#x3D;</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">byte</span>、<span class="hljs-type">short</span>、<span class="hljs-type">char</span>‐‐&gt;<span class="hljs-type">int</span>‐‐&gt;<span class="hljs-type">long</span>‐‐&gt;<span class="hljs-type">float</span>‐‐&gt;<span class="hljs-type">double</span><br></code></pre></div></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> 类型内存<span class="hljs-number">8</span>个字节， <span class="hljs-built_in">int</span> 类型内存<span class="hljs-number">4</span>个字节。<br>想要赋值成功，只有通过强制类型转换，将<span class="hljs-built_in">double</span> 类型强制转换成<span class="hljs-built_in">int</span> 类型才能赋值<br></code></pre></div></td></tr></table></figure><p>强制类型转换：将取值范围大的类型强制转换成取值范围小的类型。</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">数据类型 变量名 <span class="hljs-operator">=</span> （数据类型）被转数据值；<br></code></pre></div></td></tr></table></figure><p>字符数值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">字符数值<br><span class="hljs-number">0</span>   <span class="hljs-number">48</span><br><span class="hljs-number">9</span>   <span class="hljs-number">57</span><br>A   <span class="hljs-number">65</span><br>Z   <span class="hljs-number">90</span><br>a   <span class="hljs-number">97</span><br>z   <span class="hljs-number">122</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">分析： s += <span class="hljs-number">1</span> 逻辑上看作是s = s + <span class="hljs-number">1</span> 计算结果被提升为<span class="hljs-type">int</span>类型，再向<span class="hljs-type">short</span>类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s=s+<span class="hljs-number">1</span>进行两次运算， += 是一个运算符，只运算一次，并带有强制转换的特点，也就是说s += <span class="hljs-number">1</span> 就是s = (<span class="hljs-type">short</span>)(s + <span class="hljs-number">1</span>) ，因此程序没有问题编译通过，运行结果是<span class="hljs-number">2.</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">byte</span> b1=<span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> b2=<span class="hljs-number">2</span>;<br><span class="hljs-type">byte</span> b3=<span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br><span class="hljs-type">byte</span> b4=b1 + b2;<br>&#125;<br>分析：<br>b3 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> ，<span class="hljs-number">1</span>和<span class="hljs-number">2</span>是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了<span class="hljs-number">1</span>+<span class="hljs-number">2</span> 的结果并没有超过<span class="hljs-type">byte</span>类型的取值范围，可以赋值给变量b3 ，因此b3=<span class="hljs-number">1</span> + <span class="hljs-number">2</span> 是正确的。<br><br>b4 = b2 + b3，b2和b3是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什么，因此会将结果以<span class="hljs-type">int</span>类型进行处理，所以<span class="hljs-type">int</span>类型不能赋值给<span class="hljs-type">byte</span>类型，因此编译失败。<br></code></pre></div></td></tr></table></figure><h3 id="2-4方法"><a href="#2-4方法" class="headerlink" title="2.4方法"></a>2.4方法</h3><p>方法：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">修饰符 返回值类型 方法名 （参数列表）｛<br>代码...<br><span class="hljs-keyword">return</span> ;<br>｝<br><br><span class="hljs-keyword">return</span>：方法结束。返回值类型是<span class="hljs-keyword">void</span>，方法大括号内的<span class="hljs-keyword">return</span>可以不写。<br></code></pre></div></td></tr></table></figure><p>方法定义注意事项：</p><ol><li><p>方法必须定义在一类中方法外</p></li><li><p>&#x3D;&#x3D;方法不能定义在另一个方法的里面&#x3D;&#x3D;  比如main方法</p></li></ol><p>JDK9新特性</p><p>JShell脚本工具是JDK9的新特性</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">什么时候会用到JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，<span class="hljs-selector-tag">main</span>方法，也不愿意去编译和运行，这个时候可以使用JShell工具。启动JShell工具，在DOS命令行直接输入JShell命令。<br></code></pre></div></td></tr></table></figure><h2 id="第三章-流程控制"><a href="#第三章-流程控制" class="headerlink" title="第三章 流程控制"></a>第三章 流程控制</h2><h3 id="3-1-判断语句if"><a href="#3-1-判断语句if" class="headerlink" title="3.1 判断语句if"></a>3.1 判断语句if</h3><p> if语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a==b)&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>if else语句</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式) &#123;语句体<span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">else</span> &#123;语句体<span class="hljs-number">2</span>;&#125;<br></code></pre></div></td></tr></table></figure><p>if… else if … else…</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;执行语句<span class="hljs-number">1</span>;&#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">2</span>) &#123;执行语句<span class="hljs-number">2</span>;&#125;<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件n) &#123;执行语句n;&#125; <br><span class="hljs-keyword">else</span> &#123;执行语句n+<span class="hljs-number">1</span>;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-2-选择语句switch"><a href="#3-2-选择语句switch" class="headerlink" title="3.2 选择语句switch"></a>3.2 选择语句switch</h3><p>switch语句中，表达式的数据类型，可以是&#x3D;&#x3D;byte，short，int，char，enum（枚举）&#x3D;&#x3D;，JDK7后可以接收&#x3D;&#x3D;字符串&#x3D;&#x3D;。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:语句体<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:语句体<span class="hljs-number">2</span>;<span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:语句体n+<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br>&#125;<br>在<span class="hljs-keyword">switch</span>语句中，如果<span class="hljs-keyword">case</span>的后面不写<span class="hljs-keyword">break</span>，将出现穿透现象，也就是不会在判断下一个<span class="hljs-keyword">case</span>的值，直接向后运行，直到遇到<span class="hljs-keyword">break</span>，或者整体<span class="hljs-keyword">switch</span>结束<br></code></pre></div></td></tr></table></figure><h3 id="3-3-循环语句"><a href="#3-3-循环语句" class="headerlink" title="3.3 循环语句"></a>3.3 循环语句</h3><p>for循环</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;<br>循环体③<br>&#125;<br></code></pre></div></td></tr></table></figure><p>while循环</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">while</span>(布尔表达式②)&#123;<br>循环体③<br>步进表达式④<br>&#125;<br></code></pre></div></td></tr></table></figure><p>do…while循环</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">初始化表达式①<br><span class="hljs-keyword">do</span>&#123;<br>循环体③<br>步进表达式④<br>&#125;<span class="hljs-keyword">while</span><span class="hljs-comment">(布尔表达式②)</span>;<br></code></pre></div></td></tr></table></figure><p>for 和 while 的小区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span>控制条件语句所控制的那个变量，在<span class="hljs-keyword">for</span>循环结束后，就不能再被访问到了，而<span class="hljs-keyword">while</span>循环结束还可以继续使用，如果你想继续使用，就用<span class="hljs-keyword">while</span>，否则推荐使用<span class="hljs-keyword">for</span>。原因是<span class="hljs-keyword">for</span>循环结束，该变量就从内存中消失，能够提高内存的使用效率。<br><span class="hljs-number">2.</span>在已知循环次数的时候使用推荐使用<span class="hljs-keyword">for</span>，循环次数未知的时推荐使用<span class="hljs-keyword">while</span>。<br><span class="hljs-keyword">while</span>(ture)需要有<span class="hljs-keyword">break</span>,不然如果后边有语句，编译会报错<br></code></pre></div></td></tr></table></figure><p>break和continue</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">break</span>直接跳出去<br><span class="hljs-keyword">continue</span>则是当前循环结束，开始下次循环<br></code></pre></div></td></tr></table></figure><h2 id="第四章-Intelij-IEDA"><a href="#第四章-Intelij-IEDA" class="headerlink" title="第四章 Intelij IEDA"></a>第四章 Intelij IEDA</h2><p>从安装上来看，IntelliJ IDEA 对硬件的要求似乎不是很高。可是实际在开发中其实并不是这样的，因为 IntelliJ IDEA 执行时会有大量的缓存、索引文件</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin：容器，执行文件和启动参数等</span><br><span class="hljs-keyword"></span>help：快捷键文档和其他帮助文档<br><span class="hljs-keyword">jre64：64 </span>位<span class="hljs-keyword">java </span>运行环境<br>lib：idea 依赖的类库<br>license：各个插件许可<br>plugin：插件<br></code></pre></div></td></tr></table></figure><p>64 位操作系统且内存大于 8G 的， 如果你是开发大型项目、 Java 项目或是 Android 项目建议进行修改，常修改的就是下面3个参数</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">-Xms128m，16 G 内存的机器可尝试设置为 -Xms512m<br>(设置初始的内存数，增加该值可以提高 Java 程序的启动速度。<br><br>-Xmx750m，16 G 内存的机器可尝试设置为 -Xmx1500m<br>(设置最大内存数，提高该值，可以减少内存 Garage 收集的频率，提高程序性能 )<br><br>-XX:<span class="hljs-attribute">ReservedCodeCacheSize</span>=240m，16G 内存的机器可尝试设置为 -XX:<span class="hljs-attribute">ReservedCodeCacheSize</span>=500m<br>(保留代码占用的内存容量)<br></code></pre></div></td></tr></table></figure><p>快捷操作</p><figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d">soutp=System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;方法形参名 = + 形参名</span><br><span class="hljs-string">soutv=System.out.println(&quot;</span>变量名 = <span class="hljs-string">&quot; + 变量</span><br><span class="hljs-string">soutm=System.out.println(&quot;</span>当前类名 当前方法<br>“abc”.sout =&gt; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>iter：可 生成增强 <span class="hljs-keyword">for</span> 循环<br>itar：可 生成普通 <span class="hljs-keyword">for</span> 循环<br><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>输入: list.<span class="hljs-keyword">for</span> 即可输出<br><span class="hljs-keyword">for</span>(String s:list)&#123;<br>&#125;<br><br>psf ：可生成 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span><br>psfi ：可生成 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span><br>psfs ：可生成 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String<br></code></pre></div></td></tr></table></figure><h2 id="第五章-数组"><a href="#第五章-数组" class="headerlink" title="第五章 数组"></a>第五章 数组</h2><p>容器：是将多个数据存储到一起，每个数据称为该容器的元素。</p><h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><p>数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。数组有定长特性，长度一旦指定，不可更改。</p><p>定义一</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">数组存储的数据类型[] 数组名字 <span class="hljs-operator">=</span> new 数组存储的数据类型[长度]<span class="hljs-comment">;</span><br>int[] a <span class="hljs-operator">=</span> new int[<span class="hljs-number">10</span>]<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>定义二</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3.</span>..&#125;;<br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>定义三</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="language-xml">数据类型[] 数组名 = </span><span class="hljs-template-variable">&#123;元素1,元素2,元素3...&#125;</span><span class="language-xml">;</span><br><span class="language-xml">int[] arr = </span><span class="hljs-template-variable">&#123;1,2,3,4,5&#125;</span><span class="language-xml">;</span><br></code></pre></div></td></tr></table></figure><p>数组名.length可以获取数组的长度值</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">arr.<span class="hljs-built_in">length</span><br></code></pre></div></td></tr></table></figure><p>数组默认值</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> <span class="hljs-number">0</span><br>浮点 <span class="hljs-number">0.0</span><br>字符 ‘<span class="hljs-number">1</span>u0000’  看不见<br>布尔<span class="hljs-keyword">false</span><br>引用  <span class="hljs-keyword">null</span><br><br><span class="hljs-keyword">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];或者 <span class="hljs-keyword">int</span>[] x； x= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];也是先默认，在赋值<br></code></pre></div></td></tr></table></figure><h3 id="5-2-数组越界异常"><a href="#5-2-数组越界异常" class="headerlink" title="5.2 数组越界异常"></a>5.2 数组越界异常</h3><p>直接用数组不存在的索引，ArrayIndexOutOfBoundsException异常</p><p>数组空指针异常</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>arr = <span class="hljs-literal">null</span>;<br>System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">0</span>]);<br>｝<br></code></pre></div></td></tr></table></figure><p>arr &#x3D; null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出&#x3D;&#x3D;NullPointerException&#x3D;&#x3D; 空指针异常。</p><p>&#x3D;&#x3D;方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值&#x3D;&#x3D;</p><p>&#x3D;&#x3D;所以对于数组作为参数，不用返回值，因为已经把地址传进去了&#x3D;&#x3D;</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">0</span>]);<br>change(arr);<br>System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span> &#123;<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-3-Java内存"><a href="#5-3-Java内存" class="headerlink" title="5.3 Java内存"></a>5.3 Java内存</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">区域名称作用<br>寄存器给CPU使用，和我们开发无关。<br>本地方法栈JVM在使用操作系统功能的时候使用，和我们开发无关。<br>方法区存储可以运行的<span class="hljs-keyword">class</span>文件。<br>堆内存存储对象或者数组，<span class="hljs-symbol">new</span>来创建的，都存储在堆内存。<br>方法栈方法运行时使用的内存，比如<span class="hljs-symbol">main</span>方法运行，进入方法栈中执行。<br></code></pre></div></td></tr></table></figure><p>数组内存，直接打印数组名字即&#x3D;&#x3D;数组的地址&#x3D;&#x3D;</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210916170618237.png" alt="image-20210916170618237"></p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.main方法进栈<br><span class="hljs-number">2</span>.创建数组，<span class="hljs-keyword">JVM在内存中开辟空间，存储数组</span><br><span class="hljs-keyword"></span><span class="hljs-number">3</span>.数组在内存中有地址，十六位进制数表示<br><span class="hljs-number">4</span>.数组中元素默认初始值为<span class="hljs-number">0</span><br><span class="hljs-number">5</span>.<span class="hljs-keyword">JVM将数组的内存地址赋值给引用变量arr</span><br><span class="hljs-keyword"></span><span class="hljs-number">6</span>.变量arr保存的是数组内存中的地址，因此成为引用数据类型<br></code></pre></div></td></tr></table></figure><h2 id="第六章-面向对象"><a href="#第六章-面向对象" class="headerlink" title="第六章 面向对象"></a>第六章 面向对象</h2><p>面向过程：强调步骤。<br>       面向对象：强调对象。</p><p>类：是一组相关&#x3D;&#x3D;属性&#x3D;&#x3D;和&#x3D;&#x3D;行为&#x3D;&#x3D;的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</p><p>属性：就是该事物的状态信息。<br>       行为：就是该事物能够做什么。</p><p>对象：是一类事物的&#x3D;&#x3D;具体体现&#x3D;&#x3D;。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。</p><p>类是对一类事物的描述，是抽象的。<br>       对象是一类事物的实例，是具体的。<br>       类是对象的模板，对象是类的实体。</p><p>成员变量：对应事物的属性 成员方法：对应事物的行为</p><h3 id="6-2-对象的使用"><a href="#6-2-对象的使用" class="headerlink" title="6.2 对象的使用"></a>6.2 对象的使用</h3><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">类名 对象名 <span class="hljs-operator">=</span> new 类名()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>使用对象访问类中的成员:</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">对象名.成员变量；<br>对象名.成员方法<span class="hljs-comment">()</span>；<br></code></pre></div></td></tr></table></figure><p>成员变量的默认值</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj">数据类型默认值<br>基本类型整数（<span class="hljs-keyword">byte</span>，<span class="hljs-keyword">short</span>，<span class="hljs-keyword">int</span>，<span class="hljs-keyword">long</span>）        <span class="hljs-number">0</span><br>浮点数（<span class="hljs-keyword">float</span>，<span class="hljs-keyword">double</span>） <span class="hljs-number">0.0</span><br>字符（<span class="hljs-keyword">char</span>） <span class="hljs-string">&#x27;\u0000&#x27;</span><br>布尔（<span class="hljs-keyword">boolean</span>） <span class="hljs-keyword">false</span><br>引用类型数组，类，接口<span class="hljs-keyword">null</span><br></code></pre></div></td></tr></table></figure><p>定义对象</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br><span class="hljs-comment">// 成员变量</span><br><span class="hljs-title class_">String</span> brand; <span class="hljs-comment">//品牌</span><br><br><span class="hljs-comment">// 成员方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">call</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-3-对象内存"><a href="#6-3-对象内存" class="headerlink" title="6.3 对象内存"></a>6.3 对象内存</h3><p>例如</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span><span class="hljs-selector-class">.main</span>方法先进栈<br><span class="hljs-number">2</span>.在堆中创建对象，把对象的地址值给one, 堆中方法的地址值也指向方法区地址<br><span class="hljs-number">3</span>.调用方法，方法完成后出栈<br><span class="hljs-number">4</span>.全部完成，<span class="hljs-selector-tag">main</span>出栈<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210916203007283.png" alt="image-20210916203007283"></p><h3 id="6-4-局部变量和成员变量"><a href="#6-4-局部变量和成员变量" class="headerlink" title="6.4 局部变量和成员变量"></a>6.4 局部变量和成员变量</h3><p>1.在类中的位置不同</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">成员变量：类中，方法外<br>局部变量：方法中或者方法声明上<span class="hljs-comment">(形式参数)</span><br></code></pre></div></td></tr></table></figure><p>2.作用范围不一样</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">成员变量：类中<br>局部变量：方法中<br></code></pre></div></td></tr></table></figure><p>3.&#x3D;&#x3D;初始化值的不同&#x3D;&#x3D;</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">成员变量：有默认值<br>局部变量：没有默认值。必须先定义，赋值，最后使用<br></code></pre></div></td></tr></table></figure><p>4.&#x3D;&#x3D;在内存中的位置不同&#x3D;&#x3D;</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">成员变量：堆内存<br>局部变量：栈内存<br></code></pre></div></td></tr></table></figure><p>5.&#x3D;&#x3D;生命周期不同&#x3D;&#x3D;</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失<br></code></pre></div></td></tr></table></figure><h2 id="第七章-封装"><a href="#第七章-封装" class="headerlink" title="第七章 封装"></a>第七章 封装</h2><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><p>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p><p>方法</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 使用 private 关键字来修饰成员变量。<br><span class="hljs-bullet">2.</span> 对需要访问的成员变量，提供对应的一对 getXxx 方法 、setXxx 方法。<br></code></pre></div></td></tr></table></figure><h3 id="7-1-this关键字"><a href="#7-1-this关键字" class="headerlink" title="7.1 this关键字"></a>7.1 this关键字</h3><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">记住 ：方法被哪个对象调用，方法中的<span class="hljs-keyword">this</span>就代表那个对象。即谁在调用，<span class="hljs-keyword">this</span>就代表谁。<br></code></pre></div></td></tr></table></figure><h3 id="7-2-构造方法"><a href="#7-2-构造方法" class="headerlink" title="7.2 构造方法"></a>7.2 构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><p>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，&#x3D;&#x3D;Java自动提供的默认无参数构造方法&#x3D;&#x3D;就会失效。</p><p>构造方法的写法上，方法名与它所在的类名相同。&#x3D;&#x3D;它没有返回值&#x3D;&#x3D;，所以不需要返回值类型，甚至不需要void。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">修饰符 构造方法名(参数列表)&#123;<br><span class="hljs-regexp">//</span> 方法体<br>&#125;<br></code></pre></div></td></tr></table></figure><p>&#x3D;&#x3D;推荐的写法：&#x3D;&#x3D;</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">public class ClassName&#123;<br><span class="hljs-regexp">//</span>成员变量<br><span class="hljs-regexp">//</span>构造方法<br><span class="hljs-regexp">//</span>无参构造方法【必须】<br><span class="hljs-regexp">//</span>有参构造方法【建议】<br><span class="hljs-regexp">//</span>成员方法<br><span class="hljs-regexp">//g</span>etXxx()<br><span class="hljs-regexp">//</span>setXxx()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>this的注意使用</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span>构造方法可以有参数，可以重载<br><span class="hljs-number">2.</span>不能有返回值类型声明，不⽤<span class="hljs-keyword">return</span>返回值, 可以⽤<span class="hljs-keyword">return</span>结束<br><span class="hljs-number">3.</span><span class="hljs-keyword">this</span>不能被其他方法调用，但可以被<span class="hljs-keyword">this</span>相互调用<br><span class="hljs-number">4.</span><span class="hljs-keyword">this</span> 调⽤成员⽅法( 可省略<span class="hljs-keyword">this</span>）<br><br><span class="hljs-keyword">this</span> 调⽤其他构造⽅法只能出现在构造⽅法中,并且只能位于第⼀⾏出现一次，不能在两个构造⽅法使⽤<span class="hljs-keyword">this</span>相互调用。可以单向调用<br></code></pre></div></td></tr></table></figure><p>例如       </p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sutdent</span>()</span>&#123;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sutdent</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> name</span>)</span>&#123;<br>          <span class="hljs-keyword">this</span>();<br>          <span class="hljs-keyword">this</span>.name=name;<br>  &#125;<br></code></pre></div></td></tr></table></figure><h2 id="第八章-API"><a href="#第八章-API" class="headerlink" title="第八章 API"></a>第八章 API</h2><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p><h3 id="8-1-Scanner类"><a href="#8-1-Scanner类" class="headerlink" title="8.1 Scanner类"></a>8.1 Scanner类</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><span class="hljs-built_in">int</span> i = sc.next<span class="hljs-constructor">Int()</span>;<br>备注：<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span><span class="hljs-keyword">in</span> 系统输入指的是通过键盘录入数据。<br></code></pre></div></td></tr></table></figure><h3 id="8-2-引用类型使用步骤"><a href="#8-2-引用类型使用步骤" class="headerlink" title="8.2 引用类型使用步骤"></a>8.2 引用类型使用步骤</h3><p>1.导包</p><p>使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 </p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">格式：<br>import 包名.类名<span class="hljs-comment">;</span><br>例如<br>java.util.Scanner<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>2.创建对象</p><p>使用该类的构造方法，创建一个该类的对象。</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">格式：<br>数据类型 变量名 <span class="hljs-operator">=</span> new 数据类型(参数列表)<span class="hljs-comment">;</span><br>例如<br>Scanner sc <span class="hljs-operator">=</span> new Scanner(System.in)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>3.调用方法</p><p>调用该类的成员方法，完成指定功能。 </p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">格式：<br>变量名.方法名()<span class="hljs-comment">;</span><br>例如<br>int i <span class="hljs-operator">=</span> sc.nextInt()<span class="hljs-comment">; // 接收一个键盘录入的整数</span><br></code></pre></div></td></tr></table></figure><h3 id="8-3-scanner使用步骤"><a href="#8-3-scanner使用步骤" class="headerlink" title="8.3 scanner使用步骤"></a>8.3 scanner使用步骤</h3><p>1.查看类</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">java</span>.util.<span class="hljs-type">Scanner</span> ：该类需要<span class="hljs-keyword">import</span>导入后使用。<br></code></pre></div></td></tr></table></figure><p>2.查看构造方法</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> Scanner(InputStream <span class="hljs-keyword">source</span>) : 构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。<br></code></pre></div></td></tr></table></figure><p>3.查看成员方法</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">nextInt</span>() ：将输入信息的下一个标记扫描为一个 <span class="hljs-built_in">int</span> 值。</span><br></code></pre></div></td></tr></table></figure><p>使用Scanner类，完成接收键盘录入数据的操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1. 导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01_Scanner</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//2. 创建键盘录入数据的对象</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//3. 接收数据</span><br>System.out.println(<span class="hljs-string">&quot;请录入一个整数：&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-comment">//4. 输出数据</span><br>System.out.println(<span class="hljs-string">&quot;i:&quot;</span>+i);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="8-4匿名对象"><a href="#8-4匿名对象" class="headerlink" title="8.4匿名对象"></a>8.4匿名对象</h3><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p><p>匿名对象 ：没有变量名的对象</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">格式<br><span class="hljs-keyword">new</span> <span class="hljs-type"></span>类名(参数列表)；<br>例子<br><span class="hljs-keyword">new</span> <span class="hljs-type">Scanner</span>(System.<span class="hljs-keyword">in</span>)；<br></code></pre></div></td></tr></table></figure><p>应用</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>.next<span class="hljs-constructor">Int()</span>;<br>一旦调用两次方法，就是创建了两个对象，造成浪费，请看如下代码。<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>.next<span class="hljs-constructor">Int()</span>;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>.next<span class="hljs-constructor">Int()</span>;<br>一个匿名对象，只能使用一次。<br></code></pre></div></td></tr></table></figure><p>匿名对象可以作为方法的参数和返回值</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">作为参数<br><span class="hljs-keyword">input</span>(<span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>));<br>做为返回值<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>);<br></code></pre></div></td></tr></table></figure><h2 id="第九章-Random类"><a href="#第九章-Random类" class="headerlink" title="第九章 Random类"></a>第九章 Random类</h2><p> 此类的实例用于生成伪随机数。<br>        例如，以下代码使用户能够得到一个随机数：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">Random r <span class="hljs-operator">=</span> new Random()<span class="hljs-comment">;</span><br>int i <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">10</span>)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>使用步骤</p><p>1.查看类</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">java</span>.util.<span class="hljs-type">Random</span> ：该类需要 <span class="hljs-keyword">import</span>导入使后使用。<br></code></pre></div></td></tr></table></figure><p>2.查看构造方法</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Random</span>() ：创建一个新的随机数生成器。</span><br></code></pre></div></td></tr></table></figure><p>3.查看成员方法</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> nextInt(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) ：返回一个伪随机数，范围在<span class="hljs-number">0</span>（包括）和指定值<span class="hljs-built_in">n</span>（不包括）之间的<span class="hljs-built_in">int</span>值。<br></code></pre></div></td></tr></table></figure><h2 id="第十章-ArrayList类"><a href="#第十章-ArrayList类" class="headerlink" title="第十章 ArrayList类"></a>第十章 ArrayList类</h2><p>java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。</p><p>使用步骤</p><p>1.查看类</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">java</span>.util.<span class="hljs-type">ArrayList</span> &lt;<span class="hljs-type">E</span>&gt; ：该类需要 <span class="hljs-keyword">import</span>导入使后使用。<br></code></pre></div></td></tr></table></figure><p>&lt; E &gt; ，表示一种指定的数据类型，叫做泛型。E ，取自Element（元素）的首字母。在出现E的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-built_in">ArrayList</span>&lt;<span class="hljs-built_in">String</span>&gt;，<span class="hljs-built_in">ArrayList</span>&lt;Student&gt;<br></code></pre></div></td></tr></table></figure><p>2.查看构造方法</p><p>public ArrayList() ：构造一个内容为空的集合。</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">格式：<br>ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;();<br></code></pre></div></td></tr></table></figure><p>在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">ArrayList&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br></code></pre></div></td></tr></table></figure><p>3.查看成员方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> ： 将指定的元素添加到此集合的尾部。<br></code></pre></div></td></tr></table></figure><h4 id="10-1-常用方法和遍历"><a href="#10-1-常用方法和遍历" class="headerlink" title="10.1 常用方法和遍历"></a>10.1 常用方法和遍历</h4><p>对于元素的操作,基本体现在——增、删、查。常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> ：将指定的元素添加到此集合的尾部。<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> ：移除此集合中指定位置上的元素。返回被删除的元素。<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> ：返回此集合中指定位置上的元素。返回获取的元素。<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。<br></code></pre></div></td></tr></table></figure><h4 id="10-2包装类"><a href="#10-2包装类" class="headerlink" title="10.2包装类"></a>10.2包装类</h4><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似<int> 不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下：</int></p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">基本类型基本类型包装类<br><span class="hljs-keyword">byte</span> <span class="hljs-keyword">Byte</span><br><span class="hljs-keyword">short</span> <span class="hljs-keyword">Short</span><br><span class="hljs-keyword">int</span> Integer<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">Long</span><br><span class="hljs-keyword">float</span> <span class="hljs-keyword">Float</span><br><span class="hljs-keyword">double</span> <span class="hljs-keyword">Double</span><br><span class="hljs-keyword">char</span> Character<br><span class="hljs-keyword">boolean</span> <span class="hljs-keyword">Boolean</span><br></code></pre></div></td></tr></table></figure><p>我们发现，只有Integer和Character需要特殊记忆，其他基本类型只是首字母大写即可 吧  </p><h2 id="第十一章-String类"><a href="#第十一章-String类" class="headerlink" title="第十一章 String类"></a>第十一章 String类</h2><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如”abc” ）都可以被看作是实现此类的实例。</p><p>类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。</p><p>特点</p><ol><li>字符串不变：字符串的值在创建后不能被更改。</li></ol><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-regexp">//</span> 内存中有<span class="hljs-string">&quot;abc&quot;</span>，<span class="hljs-string">&quot;abcd&quot;</span>两个对象，s1从指向<span class="hljs-string">&quot;abc&quot;</span>，改变指向，指向了<span class="hljs-string">&quot;abcd&quot;</span>。<br></code></pre></div></td></tr></table></figure><ol start="2"><li>因为String对象是不可变的，所以它们可以被共享。</li></ol><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">String s1 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>String s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>// 内存中只有一个<span class="hljs-string">&quot;abc&quot;</span>对象被创建，同时被s1和s2共享。<br></code></pre></div></td></tr></table></figure><ol start="3"><li>“abc” 等效于 char[] data&#x3D;{ ‘a’ , ‘b’ , ‘c’ }</li></ol><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing">例如：<br><span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br>相当于：<br><span class="hljs-type">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(data);<br><span class="hljs-comment">// String底层是靠字符数组实现的。</span><br></code></pre></div></td></tr></table></figure><p>使用方法</p><p>查看类</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> ：此类不需要导入。<br></code></pre></div></td></tr></table></figure><p>查看构造方法</p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-number">1.</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span>() ：初始化新创建的 <span class="hljs-built_in">String</span>对象，以使其表示空字符序列。<br><span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>（）；<br><span class="hljs-number">2.</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span>(<span class="hljs-type">char</span>[] value) ：通过当前参数中的字符数组来构造新的<span class="hljs-built_in">String</span>。<br><span class="hljs-type">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-built_in">String</span> str2 = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(chars);<br><span class="hljs-number">3.</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span>(<span class="hljs-type">byte</span>[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的<span class="hljs-built_in">String</span>。<br>            <span class="hljs-type">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br>            <span class="hljs-built_in">String</span> str3 = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(bytes);<br></code></pre></div></td></tr></table></figure><p>​常用方法</p><p>1.比较大小</p><figure class="highlight vbnet"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">equals</span> (<span class="hljs-type">Object</span> anObject) ：将此字符串与指定对象进行比较。<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> equalsIgnoreCase (<span class="hljs-type">String</span> anotherString) ：将此字符串与指定对象进行比较，忽略大小写。<br></code></pre></div></td></tr></table></figure><p>2.获取功能的方法</p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span>() ：返回此字符串的长度。<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-built_in">concat</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) ：将指定的字符串连接到该字符串的末尾。<br><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span> (<span class="hljs-type">int</span> index) ：返回指定索引处的 <span class="hljs-type">char</span>值。<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) ：返回指定子字符串第一次出现在该字符串内的索引。<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">substring</span> (<span class="hljs-type">int</span> beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">substring</span> (<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。<br></code></pre></div></td></tr></table></figure><p>3.转换功能的方法</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[] toCharArray () ：将此字符串转换为新的字符数组。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBytes()：使用平台的默认字符集将该 String编码转换为新的字节数组。<br><span class="hljs-keyword">public</span> String replace (CharSequence <span class="hljs-keyword">target</span>, CharSequence replacement) ：将与<span class="hljs-keyword">target</span>匹配的字符串使用replacement字符串替换。<br></code></pre></div></td></tr></table></figure><p>4.分割方法</p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span>[] <span class="hljs-built_in">split</span>(<span class="hljs-built_in">String</span> regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。<br></code></pre></div></td></tr></table></figure><h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p><h3 id="定义和使用格式"><a href="#定义和使用格式" class="headerlink" title="定义和使用格式"></a>定义和使用格式</h3><p>类变量</p><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p><p>静态方法</p><p>当static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 访问类变量<br>类名.类变量名；<br><span class="hljs-regexp">//</span> 调用静态方法<br>类名.静态方法名(参数)；<br><br>被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。<br></code></pre></div></td></tr></table></figure><p>静态方法调用的注意事项：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">静态方法可以直接访问类变量和静态方法。<br>静态方法只能访问静态成员。反之，成员方法可以直接访问类变量或静态方法。<br>静态方法中，不能使用<span class="hljs-keyword">this</span>关键字。<br></code></pre></div></td></tr></table></figure><p>static内存图</p><p>static 修饰的内容：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">是随着类的加载而加载的，且只加载一次。<br>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。<br>它优先于对象存在，所以，可以被所有对象共享。<br></code></pre></div></td></tr></table></figure><p>内存示意图</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210917171721996.png" alt="image-20210917171721996"></p><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</p><p>位置：类中方法外。</p><p>执行：随着类的加载而执行且执行一次，&#x3D;&#x3D;优先于main方法&#x3D;&#x3D;和&#x3D;&#x3D;构造方法&#x3D;&#x3D;的执行</p><p>格式</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p><p>操作数组的方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> ：返回指定数组内容的字符串表示形式。<br></code></pre></div></td></tr></table></figure><p>例如</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">4</span>,<span class="hljs-number">657</span>,<span class="hljs-number">8</span>,<span class="hljs-number">69</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 打印数组,输出地址值</span><br>System.out.<span class="hljs-built_in">println</span>(arr); <span class="hljs-comment">// [I@2ac1fdc4</span><br><span class="hljs-comment">// 数组内容转为字符串</span><br><span class="hljs-type">String</span> s = Arrays.<span class="hljs-built_in">toString</span>(arr);<br><span class="hljs-comment">// 打印字符串,输出内容</span><br>System.out.<span class="hljs-built_in">println</span>(s); <span class="hljs-comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>排序方法：</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">sort</span>(<span class="hljs-keyword">int</span>[] a) ：对指定的 <span class="hljs-keyword">int</span> 型数组按数字升序进行排序。<br></code></pre></div></td></tr></table></figure><h3 id="第四章-Math类"><a href="#第四章-Math类" class="headerlink" title="第四章 Math类"></a>第四章 Math类</h3><p>java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单</p><p>public static double abs(double a) ：返回 double 值的绝对值。</p><p>public static double ceil(double a) ：返回大于等于参数的最小的整数。  向下取整</p><p>public static double floor(double a) ：返回小于等于参数最大的整数。   向上取整</p><p>public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。</p><p>其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。</p><p>继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p><p>好处：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">提高代码的复用性。<br>类与类之间产生了关系，是多态的前提。<br></code></pre></div></td></tr></table></figure><p>继承的格式</p><p>通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super 关键字，修饰父类成员变量，类似于之前学过的 this 。</p><p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p><p>&#x3D;&#x3D;父类私有，子类不能直接访问&#x3D;&#x3D;</p><p>成员方法</p><p>对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，&#x3D;&#x3D;若子类中不存在就会执行父类中相应的方法&#x3D;&#x3D;</p><p>如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。</p><ol><li>子类方法覆盖父类方法，必须要保证&#x3D;&#x3D;权限大于等于父类权限&#x3D;&#x3D;。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><p>构造方法</p><ol><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li><li>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</li></ol><h3 id="1-6-super和this"><a href="#1-6-super和this" class="headerlink" title="1.6 super和this"></a>1.6 super和this</h3><p>父类空间优先于子类对象产生</p><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210920144237852.png" alt="image-20210920144237852"></p><p>super ：代表父类的存储空间标识(可以理解为父亲的引用)。<br>        this ：代表当前对象的引用(谁调用就代表谁)。</p><h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><ol><li>Java只支持单继承，不支持多继承。  也就是只能有一个父类，可以多个子类</li><li>Java支持多层继承(继承体系)。    支持孙子</li><li>顶层父类是Object类。所有的类默认继承Object，作为父类。</li><li>子类和父类是一种相对的概念。</li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。</p><p>抽象方法 ： 没有方法体的方法。<br>       抽象类：包含抽象方法的类。如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>抽象方法abstract</p><p>使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">抽象方法格式<br>修饰符 <span class="hljs-class"><span class="hljs-keyword">abstract</span> 返回值类型 方法名 (<span class="hljs-type">参数列表</span>)；</span><br></code></pre></div></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj">抽象类格式<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名字 </span>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>抽象的使用</p><p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<br>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。<br>4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。<br></code></pre></div></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么&#x3D;&#x3D;接口的内部主要就是封装了方法&#x3D;&#x3D;，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p><p>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><p>引用数据类型：数组，类，接口</p><p>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">接口定义格式<br>public interface 接口名称 &#123;<br><span class="hljs-regexp">//</span> 抽象方法<br><span class="hljs-regexp">//</span> 默认方法<br><span class="hljs-regexp">//</span> 静态方法<br><span class="hljs-regexp">//</span> 私有方法<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含有抽象方法：使用abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含有默认方法和静态方法</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">默认方法：使用 <span class="hljs-keyword">default</span> 修饰，不可省略，供子类调用或者子类重写。<br>静态方法：使用 <span class="hljs-keyword">static</span> 修饰，供接口直接调用。<br></code></pre></div></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span> &#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>()</span> &#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含有私有方法和私有静态方法</p><p>私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterFaceName</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span> &#123;<br><span class="hljs-comment">// 执行语句</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接口的实现</p><p>实现的概述</p><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。</p><p>非抽象子类实现接口：</p><ol><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><p>实现格式：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名 </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>抽象方法的使用</p><p>必须全部实现，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">定义接口：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br><span class="hljs-comment">// 定义抽象方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>()</span>;<br>&#125;<br><br>定义实现类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-title">implements</span> <span class="hljs-title">LiveAble</span> &#123;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>&#125;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>默认方法的使用</p><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">定义接口：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>&#125;<br>&#125;<br><br>定义实现类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br><span class="hljs-comment">// 继承，什么都不用写，直接调用</span><br>&#125;<br>重写实现类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态方法的使用</p><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">定义接口：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>&#125;<br>&#125;<br><br>定义实现类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br><span class="hljs-comment">// 无法重写静态方法</span><br>&#125;<br><br>实现类<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><span class="hljs-comment">// Animal.run(); // 【错误】无法继承方法,也无法调用</span><br><span class="hljs-title class_">LiveAble</span>.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">//</span><br>&#125;<br>&#125;<br>输出结果：<br>跑起来~~~<br></code></pre></div></td></tr></table></figure><p>私有方法的使用</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">私有方法：只有默认方法可以调用。<br>私有静态方法：默认方法和静态方法可以调用。<br></code></pre></div></td></tr></table></figure><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲， 私有的方法是对默认方法和静态方法的辅助。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">定义接口：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiveAble</span> &#123;<br><span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>()</span>&#123;<br>func1();<br>func2();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span>()</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-4-接口的多实现"><a href="#1-4-接口的多实现" class="headerlink" title="1.4 接口的多实现"></a>1.4 接口的多实现</h3><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword"><span class="hljs-keyword">extends</span> </span>父类名] <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名1,接口名2,接口名3... </span>&#123;<br><span class="hljs-comment">// 重写接口中抽象方法【必须】</span><br><span class="hljs-comment">// 重写接口中默认方法【不重名时可选】</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>抽象方法</p><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</p><p>默认方法</p><p>  接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 &#x3D;&#x3D;实现类不能再default&#x3D;&#x3D;修饰了</p><p>静态方法</p><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。</p><p>优先级的问题<br>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">定义接口：<br><span class="hljs-keyword">interface</span> A &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;AAAAAAAAAAAA&quot;</span>);<br>&#125;<br>&#125;<br><br>定义父类：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;DDDDDDDDDDDD&quot;</span>);<br>&#125;<br>&#125;<br><br>定义子类：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">D</span> <span class="hljs-keyword">implements</span> A &#123;<br><span class="hljs-comment">// 未重写methodA方法</span><br>&#125;<br><br>定义测试类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>C c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>c.<span class="hljs-title function_">methodA</span>();<br>&#125;<br>&#125;<br>输出结果:<br><span class="hljs-variable constant_">DDDDDDDDDDDD</span><br></code></pre></div></td></tr></table></figure><h3 id="1-5-接口的多继承【了解】"><a href="#1-5-接口的多继承【了解】" class="headerlink" title="1.5 接口的多继承【了解】"></a>1.5 接口的多继承【了解】</h3><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">定义父接口：<br><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAA&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;BBBBBBBBBBBBBBBBBBB&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子接口重写默认方法时，default关键字可以保留。<br>       子类重写默认方法时，default关键字不可以保留。</p><h3 id="其他成员特点"><a href="#其他成员特点" class="headerlink" title="其他成员特点"></a>其他成员特点</h3><p>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</p><p>接口中，没有构造方法，不能创建对象。</p><p>接口中，没有静态代码块。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是继封装、继承之后，面向对象的第三大特性。<br>生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p><p>多态： 是指同一行为，具有多个不同表现形式。</p><p>前提【重点】</p><ol><li>继承或者实现【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li>&#x3D;&#x3D;父类引用指向子类对象&#x3D;&#x3D;【格式体现】</li></ol><p>多态的体现</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">父类类型 变量名 <span class="hljs-operator">=</span> new 子类对象；<br>变量名.方法名()<span class="hljs-comment">;</span><br><br>Fu f <span class="hljs-operator">=</span> new Zi()<span class="hljs-comment">;</span><br>f.method()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</p><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p><h3 id="2-4-引用类型转换"><a href="#2-4-引用类型转换" class="headerlink" title="2.4 引用类型转换"></a>2.4 引用类型转换</h3><p>向上转型<br>向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</p><p>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">父类类型 变量名 <span class="hljs-operator">=</span> new 子类类型()<span class="hljs-comment">;</span><br>如：Animal a <span class="hljs-operator">=</span> new Cat()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。</p><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">子类类型 变量名 = <span class="hljs-comment">(子类类型)</span> 父类变量名;<br>如:Cat c =<span class="hljs-comment">(Cat)</span> a;<br></code></pre></div></td></tr></table></figure><p>​</p><p>为什么要转型</p><p>当使用多态方式调用方法时，&#x3D;&#x3D;首先检查父类中是否有该方法，如果没有，则编译错误&#x3D;&#x3D;。也就是说，&#x3D;&#x3D;不能调用子类拥有，而父类没有的方法&#x3D;&#x3D;。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>这段代码可以通过编译，但是运行时，却报出了 &#x3D;&#x3D;ClassCastException&#x3D;&#x3D; ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。</p><p>为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">变量名 <span class="hljs-keyword">instanceof</span> 数据类型<br>如果变量属于该数据类型，返回<span class="hljs-literal">true</span>。<br>如果变量不属于该数据类型，返回<span class="hljs-literal">false</span>。<br></code></pre></div></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 向上转型</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>a.eat(); <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br><span class="hljs-comment">// 向下转型</span><br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br><span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;<br>c.catchMouse(); <span class="hljs-comment">// 调用的是 Cat 的 catchMouse</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br><span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>d.watchHouse(); <span class="hljs-comment">// 调用的是 Dog 的 watchHouse</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了final 关键字，用于修饰不可改变内容。</p><p>final： 不可改变。可以用于修饰类、方法和变量。重写被 final 修饰的方法，编译时就会报错。</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-number">1.</span>类：被修饰的类，不能被继承。<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> 类名 &#123;<br>&#125;<br><br><span class="hljs-number">2.</span>方法：被修饰的方法，不能被重写。<br>修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br><span class="hljs-comment">//方法体</span><br>&#125;<br><br><span class="hljs-number">3.</span>变量：被修饰的变量，不能被重新赋值。<br>被<span class="hljs-keyword">final</span>修饰的常量名称，一般都有书写规范，所有字母都大写。<br>基本类型的局部变量，被<span class="hljs-keyword">final</span>修饰后，只能赋值一次，不能再更改。<br>引用类型的局部变量，被<span class="hljs-keyword">final</span>修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改<br>对于成员变量，要不构造方法，要不定义时<br></code></pre></div></td></tr></table></figure><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span>：公共的。<br><span class="hljs-keyword">protected</span>：受保护的<br><span class="hljs-keyword">default</span>：默认的<br><span class="hljs-keyword">private</span>：私有的<br></code></pre></div></td></tr></table></figure><p>不同访问权限</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">default</span>（空的） <span class="hljs-keyword">private</span><br>同一类中  √ √   √       √<br>同一包中(子类与无关类) √ √ √<br>不同包的子类  √ √<br>不同包中的无关类√<br></code></pre></div></td></tr></table></figure><p>可见，public具有最大权限。private则是最小权限。<br>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">成员变量使用<span class="hljs-keyword">private</span> ，隐藏细节。<br>构造方法使用<span class="hljs-keyword">public</span> ，方便创建对象。<br>成员方法使用<span class="hljs-keyword">public</span> ，方便调用方法。<br></code></pre></div></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>什么是内部类<br>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><p>成员内部类 ：定义在类中方法外的类。<br>定义格式：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> 外部类 </span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>访问特点</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">内部类可以直接访问外部类的成员，包括私有成员。<br>外部类要访问内部类的成员，必须要建立内部类的对象。<br></code></pre></div></td></tr></table></figure><p>创建内部类对象格式：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>外部类型().<span class="hljs-keyword">new</span> <span class="hljs-type"></span>内部类型()；<br></code></pre></div></td></tr></table></figure><p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$</p><p>比如</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">Person<span class="hljs-built_in">$Heart</span>.<span class="hljs-keyword">class</span><br></code></pre></div></td></tr></table></figure><h3 id="匿名内部类【重点】"><a href="#匿名内部类【重点】" class="headerlink" title="匿名内部类【重点】"></a>匿名内部类【重点】</h3><p>匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 定义子类<br><span class="hljs-bullet">2.</span> 重写接口中的方法<br><span class="hljs-bullet">3.</span> 创建子类对象<br><span class="hljs-bullet">4.</span> 调用重写后的方法<br></code></pre></div></td></tr></table></figure><p>匿名内部类必须继承一个父类或者实现一个父接口。</p><p>格式</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 执行语句</span><br>        &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>例如</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FlyAble</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerDemo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span><br><span class="hljs-comment">    2.等号左边:是多态赋值,接口类型引用指向子类对象</span><br><span class="hljs-comment">        */</span><br>        FlyAble f = <span class="hljs-keyword">new</span> FlyAble()&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>        &#125;<br>        &#125;;<br>    <span class="hljs-comment">//调用 fly方法,执行重写后的方法</span><br>        f.fly();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。</p><p>引用类型用法总结</p><p>实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。</p><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。</p><h3 id="interface作为成员变量"><a href="#interface作为成员变量" class="headerlink" title="interface作为成员变量"></a>interface作为成员变量</h3><p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。</p><p>我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 法术攻击</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">FaShuSkill</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">faShuAttack</span>()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> &#123;<br>FaShuSkill fs;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFaShuSkill</span>(<span class="hljs-params">FaShuSkill fs</span>)</span> &#123;<br><span class="hljs-keyword">this</span>.fs = fs;<br>&#125;<br><span class="hljs-comment">// 法术攻击</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">faShuSkillAttack</span>()</span>&#123;<br>System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;发动法术攻击:&quot;</span>);<br>fs.faShuAttack();<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;攻击完毕&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p><h3 id="interface作为方法参数和返回值类型"><a href="#interface作为方法参数和返回值类型" class="headerlink" title="interface作为方法参数和返回值类型"></a>interface作为方法参数和返回值类型</h3><p>当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见List 接口作为参数或者返回值类型时，当然可以将ArrayList 的对象进行传递或返回。</p><p>接口作为参数时，传递它的子类对象。<br>       接口作为返回值类型时，返回它的子类对象。</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static List&lt;<span class="hljs-type">Integer</span>&gt; getEvenNum(List&lt;<span class="hljs-type">Integer</span>&gt; list) &#123;<br>// 创建保存偶数的集合<br>ArrayList&lt;<span class="hljs-type">Integer</span>&gt; evenList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>// 遍历集合list,判断元素为偶数,就添加到evenList中<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> = list.<span class="hljs-keyword">get</span>(i);<br><span class="hljs-keyword">if</span> (<span class="hljs-type">integer</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>evenList.<span class="hljs-keyword">add</span>(<span class="hljs-type">integer</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回偶数集合</span><br><span class="hljs-comment">因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,</span><br><span class="hljs-comment">所以evenList可以返回</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> evenList;<br>&#125;<br><br><br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>// 创建ArrayList集合,并添加数字<br>ArrayList&lt;<span class="hljs-type">Integer</span>&gt; srcList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>srcList.<span class="hljs-keyword">add</span>(i);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">获取偶数集合</span><br><span class="hljs-comment">因为getEvenNum方法的参数是List,而ArrayList是List的子类,</span><br><span class="hljs-comment">所以srcList可以传递</span><br><span class="hljs-comment">*/</span><br>List list = getEvenNum(srcList);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-comment">/*extends Object*/</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是&#x3D;&#x3D;对象的类型+@+内存地址值&#x3D;&#x3D;。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略构造器与Getter Setter</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210921155234372.png" alt="image-20210921155234372"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 转换为当前类型</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;<br>        <span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= person.age &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。</p><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;  <br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b));  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以 表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Date</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建日期对象，把当前的时间</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// Tue Jan 16 14:37:35 CST 2018</span><br>        <span class="hljs-comment">// 创建日期对象，把当前的毫秒值转成日期对象</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0L</span>)); <span class="hljs-comment">// Thu Jan 01 08:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02SimpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 对应的日期格式如：2018-01-16 15:06:38</span><br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把Date对象转换成String</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03DateFormatMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span><br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> df.format(date);<br>        System.out.println(str); <span class="hljs-comment">// 2008年1月23日</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把String转换成Date对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04DateFormatMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2018年12月11日&quot;</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> df.parse(str);<br>        System.out.println(date); <span class="hljs-comment">// Tue Dec 11 00:00:00 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p><p><strong>思路：</strong></p><p>1.获取当前时间对应的毫秒值</p><p>2.获取自己出生日期对应的毫秒值</p><p>3.两个时间相减（当前时间– 出生日期）</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);<br><span class="hljs-comment">// 获取出生日期,键盘输入</span><br><span class="hljs-type">String</span> <span class="hljs-variable">birthdayString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();<br><span class="hljs-comment">// 将字符串日期,转成Date对象</span><br><span class="hljs-comment">// 创建SimpleDateFormat对象,写日期模式</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><span class="hljs-comment">// 调用方法parse,字符串转成日期对象</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">birthdayDate</span> <span class="hljs-operator">=</span> sdf.parse(birthdayString);<br><span class="hljs-comment">// 获取今天的日期对象</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">todayDate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">// 将两个日期转成毫秒值,Date类的方法getTime</span><br><span class="hljs-type">long</span> <span class="hljs-variable">birthdaySecond</span> <span class="hljs-operator">=</span> birthdayDate.getTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">todaySecond</span> <span class="hljs-operator">=</span> todayDate.getTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">secone</span> <span class="hljs-operator">=</span> todaySecond-birthdaySecond;<br><span class="hljs-keyword">if</span> (secone &lt; <span class="hljs-number">0</span>)&#123;<br>System.out.println(<span class="hljs-string">&quot;还没出生呢&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(secone/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，&#x3D;&#x3D;Calendar类在创建对象时并非直接创建，而是通过静态方法创建&#x3D;&#x3D;，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06CalendarInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-x2F-set方法"><a href="#get-x2F-set方法" class="headerlink" title="get&#x2F;set方法"></a>get&#x2F;set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalendarUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Calendar对象</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-comment">// 设置年 </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        <span class="hljs-comment">// 设置月</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置日</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> cal.get(Calendar.DAY_OF_MONTH);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>);<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07CalendarMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        cal.set(Calendar.YEAR, <span class="hljs-number">2020</span>);<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2020年1月17日</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08CalendarMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2018年1月17日</span><br>        <span class="hljs-comment">// 使用add方法</span><br>        cal.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">2</span>); <span class="hljs-comment">// 加2天</span><br>        cal.add(Calendar.YEAR, -<span class="hljs-number">3</span>); <span class="hljs-comment">// 减3年</span><br>        System.out.print(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + dayOfMonth + <span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">// 2015年1月18日; </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09CalendarMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cal.getTime();<br>        System.out.println(date); <span class="hljs-comment">// Tue Jan 16 16:03:09 CST 2018</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//获取当前时间毫秒值</span><br>        System.out.println(System.currentTimeMillis()); <span class="hljs-comment">// 1516090531144</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;共耗时毫秒：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo11SystemArrayCopy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] src = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>        System.arraycopy( src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/*代码运行后：两个数组中的元素发生了变化</span><br><span class="hljs-comment">         src数组元素[1,2,3,4,5]</span><br><span class="hljs-comment">         dest数组元素[1,2,3,9,10]</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        s += <span class="hljs-string">&quot;World&quot;</span>;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210921164156811.png" alt="image-20210921164156811"></p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210921164218313.png" alt="image-20210921164218313"></p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        System.out.println(sb1); <span class="hljs-comment">// (空白)</span><br>        <span class="hljs-comment">// 使用带参构造</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(sb2); <span class="hljs-comment">// itcast</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02StringBuilder</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建对象</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-comment">//public StringBuilder append(任意类型)</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder2</span> <span class="hljs-operator">=</span> builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//对比一下</span><br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>System.out.println(<span class="hljs-string">&quot;builder2:&quot;</span>+builder2);<br>System.out.println(builder == builder2); <span class="hljs-comment">//true</span><br>    <span class="hljs-comment">// 可以添加 任何类型</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br>builder.append(<span class="hljs-string">&quot;world&quot;</span>);<br>builder.append(<span class="hljs-literal">true</span>);<br>builder.append(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span><br>        <span class="hljs-comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span><br><span class="hljs-comment">//链式编程</span><br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>).append(<span class="hljs-string">&quot;world&quot;</span>).append(<span class="hljs-literal">true</span>).append(<span class="hljs-number">100</span>);<br>System.out.println(<span class="hljs-string">&quot;builder:&quot;</span>+builder);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo16StringBuilder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 链式创建</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot;World&quot;</span>).append(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-comment">// 调用方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(str); <span class="hljs-comment">// HelloWorldJava</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">iii</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></div></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></div></td></tr></table></figure><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></div></td></tr></table></figure><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">基本类型直接与””相连接即可；如：<span class="hljs-number">34</span>+<span class="hljs-string">&quot;&quot;</span><br></code></pre></div></td></tr></table></figure><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo18WrapperParse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote><h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</E></p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，&#x3D;&#x3D;<code>List</code>的特点是元素有序、元素可重复&#x3D;&#x3D;。&#x3D;&#x3D;<code>Set</code>的特点是元素无序，而且不可重复&#x3D;&#x3D;。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923155147885.png" alt="image-20210923155147885"></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1Collection</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建集合对象 </span><br>    <span class="hljs-comment">// 使用多态形式</span><br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-comment">// 使用方法</span><br>    <span class="hljs-comment">// 添加功能  boolean  add(String s)</span><br>    coll.add(<span class="hljs-string">&quot;小李广&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;扫地僧&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;石破天&quot;</span>);<br>    System.out.println(coll);<br><br>    <span class="hljs-comment">// boolean contains(E e) 判断o是否在集合中存在</span><br>    System.out.println(<span class="hljs-string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="hljs-string">&quot;扫地僧&quot;</span>));<br><br>    <span class="hljs-comment">//boolean remove(E e) 删除在集合中的o元素</span><br>    System.out.println(<span class="hljs-string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="hljs-string">&quot;石破天&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+coll);<br>    <br>    <span class="hljs-comment">// size() 集合中有几个元素</span><br>System.out.println(<span class="hljs-string">&quot;集合中有&quot;</span>+coll.size()+<span class="hljs-string">&quot;个元素&quot;</span>);<br><br><span class="hljs-comment">// Object[] toArray()转换成一个Object数组</span><br>    Object[] objects = coll.toArray();<br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>System.out.println(objects[i]);<br>&#125;<br><br><span class="hljs-comment">// void  clear() 清空集合</span><br>coll.clear();<br>System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+coll);<br><span class="hljs-comment">// boolean  isEmpty()  判断是否为空</span><br>System.out.println(coll.isEmpty());  <br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用多态方式 创建对象</span><br>        Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">// 添加元素到集合</span><br>        coll.add(<span class="hljs-string">&quot;串串星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;吐槽星人&quot;</span>);<br>        coll.add(<span class="hljs-string">&quot;汪星人&quot;</span>);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-comment">//  泛型指的是 迭代出 元素的数据类型</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//判断是否有迭代元素</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<span class="hljs-comment">//获取迭代出的元素</span><br>            System.out.println(s);<br>        &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\就业班-day02-Collection、泛型\img\迭代器原理图.bmp"></p><p>&#x3D;&#x3D;在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前&#x3D;&#x3D;，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个&#x3D;&#x3D;Iterator迭代器&#x3D;&#x3D;，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  <span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NBForDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">87</span>&#125;;<br>       <span class="hljs-comment">//使用增强for遍历数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : arr)&#123;<span class="hljs-comment">//a代表数组中的每个元素</span><br>System.out.println(a);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NBFor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br>    Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    coll.add(<span class="hljs-string">&quot;小河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;老河神&quot;</span>);<br>    coll.add(<span class="hljs-string">&quot;神婆&quot;</span>);<br>    <span class="hljs-comment">//使用增强for遍历</span><br>    <span class="hljs-keyword">for</span>(String s :coll)&#123;<span class="hljs-comment">//接收变量s代表 代表被遍历到的集合元素</span><br>    System.out.println(s);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Collection</span> <span class="hljs-variable">coll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> coll.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) it.next();<br>System.out.println(str.length());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        <span class="hljs-comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br>        <span class="hljs-comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> it.next();<br>            <span class="hljs-comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br>            System.out.println(str.length());<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></code></pre></div></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt;&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123; &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123; &#125;<br>   ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;&#123; <br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String e)</span>&#123; &#125;<br><br>     <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;  &#125;<br>     ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt; &#123; <br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Integer e)</span> &#123; &#125;<br><br>     <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  &#125;<br>     ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGenericClass</span>&lt;MVP&gt; &#123;<br><span class="hljs-comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="hljs-keyword">private</span> MVP mvp;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMVP</span><span class="hljs-params">(MVP mvp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mvp = mvp;<br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> MVP <span class="hljs-title function_">getMVP</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericClassDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>         <span class="hljs-comment">// 创建一个泛型为String的类</span><br>         MyGenericClass&lt;String&gt; my = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyGenericClass</span>&lt;String&gt;();    <br>         <span class="hljs-comment">// 调用setMVP</span><br>         my.setMVP(<span class="hljs-string">&quot;大胡子登登&quot;</span>);<br>         <span class="hljs-comment">// 调用getMVP</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">mvp</span> <span class="hljs-operator">=</span> my.getMVP();<br>         System.out.println(mvp);<br>         <span class="hljs-comment">//创建一个泛型为Integer的类</span><br>         MyGenericClass&lt;Integer&gt; my2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyGenericClass</span>&lt;Integer&gt;(); <br>         my2.setMVP(<span class="hljs-number">123</span>);     <br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">mvp2</span> <span class="hljs-operator">=</span> my2.getMVP();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">修饰符 <span class="hljs-attribute">&lt;代表泛型的变量&gt;</span> 返回值类型 方法名(参数)&#123;  &#125;<br></code></pre></div></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGenericMethod</span> &#123;  <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(MVP mvp)</span> &#123;<br>    System.out.println(mvp.getClass());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MVP&gt; MVP <span class="hljs-title function_">show2</span><span class="hljs-params">(MVP mvp)</span> &#123;<br>    <span class="hljs-keyword">return</span> mvp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用格式：&#x3D;&#x3D;<strong>调用方法时，确定泛型的类型</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericMethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">MyGenericMethod</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyGenericMethod</span>();<br>        <span class="hljs-comment">// 演示看方法提示</span><br>        mm.show(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        mm.show(<span class="hljs-number">123</span>);<br>        mm.show(<span class="hljs-number">12.45</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">修饰符 <span class="hljs-keyword">interface</span>接口名&lt;代表泛型的变量&gt; &#123;  &#125;<br></code></pre></div></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyGenericInterface</span>&lt;E&gt;&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title function_">getE</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyGenericInterface</span>&lt;String&gt; &#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String e)</span> &#123;<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getE</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImp2</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyGenericInterface</span>&lt;E&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-comment">// 省略...</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getE</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* * 使用 */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterface</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        MyImp2&lt;String&gt;  my = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyImp2</span>&lt;String&gt;();          my.add(<span class="hljs-string">&quot;aa&quot;</span>);    &#125;&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Collection&lt;Intger&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    getElement(list1);<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    getElement(list2);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(Collection&lt;?&gt; coll)</span>&#123;&#125;<br><span class="hljs-comment">//？代表可以接收任意类型</span><br></code></pre></div></td></tr></table></figure><blockquote><p>tips:&#x3D;&#x3D;泛型不存在继承关系 Collection<Object> list &#x3D; new ArrayList<String>();这种是错误的。&#x3D;&#x3D;</String></Object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> Number&gt; coll)</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</String></p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Poker</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1: 准备牌操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//1.1 创建牌盒 将来存储牌面的 </span><br>        ArrayList&lt;String&gt; pokerBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-comment">//1.2 创建花色集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.3 创建数字集合</span><br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//1.4 分别给花色 以及 数字集合添加元素</span><br>        colors.add(<span class="hljs-string">&quot;♥&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♦&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♠&quot;</span>);<br>        colors.add(<span class="hljs-string">&quot;♣&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            numbers.add(i+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        numbers.add(<span class="hljs-string">&quot;J&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;Q&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;K&quot;</span>);<br>        numbers.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-comment">//1.5 创造牌  拼接牌操作</span><br>        <span class="hljs-comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span><br>        <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>            <span class="hljs-comment">//color每一个花色 </span><br>            <span class="hljs-comment">//遍历数字集合</span><br>            <span class="hljs-keyword">for</span>(String number : numbers)&#123;<br>                <span class="hljs-comment">//结合</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> color+number;<br>                <span class="hljs-comment">//存储到牌盒中</span><br>                pokerBox.add(card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//1.6大王小王</span><br>        pokerBox.add(<span class="hljs-string">&quot;小☺&quot;</span>);<br>        pokerBox.add(<span class="hljs-string">&quot;大☠&quot;</span>);  <br>        <span class="hljs-comment">// System.out.println(pokerBox);</span><br>        <span class="hljs-comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span><br>        <span class="hljs-comment">// Collections类  工具类  都是 静态方法</span><br>        <span class="hljs-comment">// shuffer方法   </span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * static void shuffle(List&lt;?&gt; list) </span><br><span class="hljs-comment">         *     使用默认随机源对指定列表进行置换。 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//2:洗牌</span><br>        Collections.shuffle(pokerBox);<br>        <span class="hljs-comment">//3 发牌</span><br>        <span class="hljs-comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br> <br>        <span class="hljs-comment">//遍历 牌盒  必须知道索引   </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;pokerBox.size();i++)&#123;<br>            <span class="hljs-comment">//获取 牌面</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> pokerBox.get(i);<br>            <span class="hljs-comment">//留出三张底牌 存到 底牌集合中</span><br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">51</span>)&#123;<span class="hljs-comment">//存到底牌集合中</span><br>                dipai.add(card);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//玩家1   %3  ==0</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                  player1.add(card);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//玩家2</span><br>                  player2.add(card);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//玩家3</span><br>                  player3.add(card);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//看看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;田伯光：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;绿竹翁：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);  <br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p><p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p><p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p><h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172348161.png" alt="image-20210923172348161"></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172358048.png" alt="image-20210923172358048"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172405607.png" alt="image-20210923172405607"></p></li><li><p>增删元素慢</p><ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。</li><li>如下图<img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172442791.png" alt="image-20210923172442791"></li><li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172500033.png" alt="image-20210923172500033"></li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</li><li><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172812372.png" alt="image-20210923172812372"></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172842184.png" alt="image-20210923172842184"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172902386.png" alt="image-20210923172902386"></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172914355.png" alt="image-20210923172914355"></p></li></ul></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923172936439.png" alt="image-20210923172936439"></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li><p>节点可以是红色的或者黑色的</p></li><li><p>根节点是黑色的</p></li><li><p>叶子节点(特指空节点)是黑色的</p></li><li><p>每个红色节点的子节点都是黑色的</p></li><li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p></li></ol><p>红黑树的特点:</p><p>​速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建List集合对象</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <br>    <span class="hljs-comment">// 往 尾部添加 指定元素</span><br>    list.add(<span class="hljs-string">&quot;图图&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;小美&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;不高兴&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    list.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;没头脑&quot;</span>);<br>    <br>    System.out.println(list);<br>    <span class="hljs-comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span><br>    <span class="hljs-comment">// 删除索引位置为2的元素 </span><br>    System.out.println(<span class="hljs-string">&quot;删除索引位置为2的元素&quot;</span>);<br>    System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    <br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String set(int index,String s)</span><br>    <span class="hljs-comment">// 在指定位置 进行 元素替代（改） </span><br>    <span class="hljs-comment">// 修改指定位置元素</span><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;三毛&quot;</span>);<br>    System.out.println(list);<br>    <br>    <span class="hljs-comment">// String get(int index)  获取指定位置元素</span><br>    <br>    <span class="hljs-comment">// 跟size() 方法一起用  来 遍历的 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    System.out.println(list.get(i));<br>    &#125;<br>    <span class="hljs-comment">//还可以使用增强for</span><br>    <span class="hljs-keyword">for</span> (String string : list) &#123;<br>System.out.println(string);<br>&#125;  <br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是&#x3D;&#x3D;数组结构&#x3D;&#x3D;。&#x3D;&#x3D;元素增删慢，查找快&#x3D;&#x3D;，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，&#x3D;&#x3D;这种用法是不提倡的&#x3D;&#x3D;。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923190413022.png" alt="image-20210923190413022"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; link = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>        <span class="hljs-comment">//添加元素</span><br>        link.addFirst(<span class="hljs-string">&quot;abc1&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc2&quot;</span>);<br>        link.addFirst(<span class="hljs-string">&quot;abc3&quot;</span>);<br>        System.out.println(link);<br>        <span class="hljs-comment">// 获取元素</span><br>        System.out.println(link.getFirst());<br>        System.out.println(link.getLast());<br>        <span class="hljs-comment">// 删除元素</span><br>        System.out.println(link.removeFirst());<br>        System.out.println(link.removeLast());<br><br>        <span class="hljs-keyword">while</span> (!link.isEmpty()) &#123; <span class="hljs-comment">//判断集合是否为空</span><br>            System.out.println(link.pop()); <span class="hljs-comment">//弹出集合中的栈顶元素</span><br>        &#125;<br><br>        System.out.println(link);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元 素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建 Set集合</span><br>        HashSet&lt;String&gt;  set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;cba&quot;</span>));<br>        set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;bac&quot;</span>); <br>        set.add(<span class="hljs-string">&quot;cba&quot;</span>);  <br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (String name : set) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">cba</span><br><span class="hljs-attribute">abc</span><br><span class="hljs-attribute">bac</span><br></code></pre></div></td></tr></table></figure><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。!</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923190652216.png" alt="image-20210923190652216"></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923190705695.png" alt="image-20210923190705695"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= student.age &amp;&amp;<br>               Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建集合对象   该集合中存储 Student类型对象</span><br>        HashSet&lt;Student&gt; stuSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Student&gt;();<br>        <span class="hljs-comment">//存储 </span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>);<br>        stuSet.add(stu);<br>        stuSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-number">44</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;于谦&quot;</span>, <span class="hljs-number">43</span>));<br>        stuSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;郭麒麟&quot;</span>, <span class="hljs-number">23</span>));<br>        stuSet.add(stu);<br><br>        <span class="hljs-keyword">for</span> (Student stu2 : stuSet) &#123;<br>            System.out.println(stu2);<br>        &#125;<br>    &#125;<br>&#125;<br>执行结果：<br>Student [name=郭德纲, age=<span class="hljs-number">44</span>]<br>Student [name=于谦, age=<span class="hljs-number">43</span>]<br>Student [name=郭麒麟, age=<span class="hljs-number">23</span>]<br></code></pre></div></td></tr></table></figure><h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashSetDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;String&gt;();<br>set.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>set.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>set.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>set.add(<span class="hljs-string">&quot;bbc&quot;</span>);<br>        Iterator&lt;String&gt; it = set.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>System.out.println(it.next());<br>&#125;<br>&#125;<br>&#125;<br>结果：<br>  bbb<br>  aaa<br>  abc<br>  bbc<br></code></pre></div></td></tr></table></figure><h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="language-xml">修饰符 返回值类型 方法名(参数类型... 形参名)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></div></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型<span class="hljs-selector-attr">[]</span> 形参名)&#123;  &#125;<br></code></pre></div></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeArgs</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">62</span>, <span class="hljs-number">431</span>, <span class="hljs-number">2</span> &#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(arr);<br>        System.out.println(sum);<br>        <span class="hljs-comment">//  6  7  2 12 2121</span><br>        <span class="hljs-comment">// 求 这几个元素和 6  7  2 12 2121</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum2</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">2121</span>);<br>        System.out.println(sum2);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 完成数组  所有元素的求和 原始写法</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      public static int getSum(int[] arr)&#123;</span><br><span class="hljs-comment">        int sum = 0;</span><br><span class="hljs-comment">        for(int a : arr)&#123;</span><br><span class="hljs-comment">            sum += a;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        return sum;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//可变参数写法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span>... arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : arr) &#123;<br>            sum += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//原来写法</span><br>        <span class="hljs-comment">//list.add(12);</span><br>        <span class="hljs-comment">//list.add(14);</span><br>        <span class="hljs-comment">//list.add(15);</span><br>        <span class="hljs-comment">//list.add(1000);</span><br>        <span class="hljs-comment">//采用工具类 完成 往集合中添加元素  </span><br>        Collections.addAll(list, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>，<span class="hljs-number">2</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//排序方法 </span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br>结果：<br>[<span class="hljs-number">5</span>, <span class="hljs-number">222</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">222</span>]<br></code></pre></div></td></tr></table></figure><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt;  list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-string">[aba, cba, nba, sba]</span><br></code></pre></div></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br></code></pre></div></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;cba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;aba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;sba&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;nba&quot;</span>);<br>        <span class="hljs-comment">//排序方法  按照第一个单词的降序</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2.charAt(<span class="hljs-number">0</span>) - o1.charAt(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-string">[sba, nba, cba, aba]</span><br></code></pre></div></td></tr></table></figure><h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>               <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>               <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>               <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建四个学生对象 存储到集合中</span><br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Student&gt;();<br><br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">16</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;ace&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;mark&quot;</span>,<span class="hljs-number">16</span>));<br><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">          让学生 按照年龄排序 升序</span><br><span class="hljs-comment">         */</span><br><span class="hljs-comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span><br><br><br>        <span class="hljs-keyword">for</span> (Student student : list) &#123;<br>            System.out.println(student);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    ....<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-o.age;<span class="hljs-comment">//升序</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再次测试，代码就OK 了效果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;abc&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mark&#x27;</span>, age=<span class="hljs-number">16</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;ace&#x27;</span>, age=<span class="hljs-number">17</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;rose&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//以学生的年龄降序</span><br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>效果：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></div></td></tr></table></figure><p>如果想要规则更多一些，可以参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-comment">// 年龄降序</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序</span><br><br>                <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span><br>                    result = o1.getName().charAt(<span class="hljs-number">0</span>)-o2.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br></code></pre></div></td></tr></table></figure><p>效果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ace&#x27;</span>, <span class="hljs-attribute">age</span>=17&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br>Student&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mark&#x27;</span>, <span class="hljs-attribute">age</span>=16&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923201434279.png" alt="image-20210923201434279"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建 map对象</span><br>        HashMap&lt;String, String&gt;  map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br><br>        <span class="hljs-comment">//添加元素到集合</span><br>        map.put(<span class="hljs-string">&quot;黄晓明&quot;</span>, <span class="hljs-string">&quot;杨颖&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;文章&quot;</span>, <span class="hljs-string">&quot;马伊琍&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        System.out.println(map);<br><br>        <span class="hljs-comment">//String remove(String key)</span><br>        System.out.println(map.remove(<span class="hljs-string">&quot;邓超&quot;</span>));<br>        System.out.println(map);<br><br>        <span class="hljs-comment">// 想要查看 黄晓明的媳妇 是谁</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;黄晓明&quot;</span>));<br>        System.out.println(map.get(<span class="hljs-string">&quot;邓超&quot;</span>));    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>        <span class="hljs-comment">//添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">//获取所有的键  获取键集</span><br>        Set&lt;String&gt; keys = map.keySet();<br>        <span class="hljs-comment">// 遍历键集 得到 每一个键</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>          <span class="hljs-comment">//key  就是键</span><br>            <span class="hljs-comment">//获取对应值</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>            System.out.println(key+<span class="hljs-string">&quot;的CP是：&quot;</span>+value);<br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>遍历图解：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923202357709.png" alt="image-20210923202357709"></p><h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Map集合对象 </span><br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>        <span class="hljs-comment">// 添加元素到集合 </span><br>        map.put(<span class="hljs-string">&quot;胡歌&quot;</span>, <span class="hljs-string">&quot;霍建华&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;郭德纲&quot;</span>, <span class="hljs-string">&quot;于谦&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;薛之谦&quot;</span>, <span class="hljs-string">&quot;大张伟&quot;</span>);<br><br>        <span class="hljs-comment">// 获取 所有的 entry对象  entrySet</span><br>        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();<br><br>        <span class="hljs-comment">// 遍历得到每一个entry对象</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>           <span class="hljs-comment">// 解析 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();  <br>            System.out.println(key+<span class="hljs-string">&quot;的CP是:&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>遍历图解：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923202346126.png" alt="image-20210923202346126"></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= student.age &amp;&amp; Objects.equals(name, student.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1,创建Hashmap集合对象。</span><br>        Map&lt;Student,String&gt;map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Student,String&gt;();<br>        <span class="hljs-comment">//2,添加元素。</span><br>        map.put(newStudent(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">28</span>), <span class="hljs-string">&quot;上海&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;北京&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhaoliu&quot;</span>,<span class="hljs-number">24</span>), <span class="hljs-string">&quot;成都&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;zhouqi&quot;</span>,<span class="hljs-number">25</span>), <span class="hljs-string">&quot;广州&quot;</span>);<br>        map.put(newStudent(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">22</span>), <span class="hljs-string">&quot;南京&quot;</span>);<br>        <br>        <span class="hljs-comment">//3,取出元素。键找值方式</span><br>        Set&lt;Student&gt;keySet = map.keySet();<br>        <span class="hljs-keyword">for</span>(Student key: keySet)&#123;<br>            Stringvalue = map.get(key);<br>            System.out.println(key.toString()+<span class="hljs-string">&quot;.....&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedHashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;邓超&quot;</span>, <span class="hljs-string">&quot;孙俪&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;李晨&quot;</span>, <span class="hljs-string">&quot;范冰冰&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-string">&quot;朱丽倩&quot;</span>);<br>        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;  &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果:</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">邓超  孙俪<br>李晨  范冰冰<br>刘德华  朱丽倩<br></code></pre></div></td></tr></table></figure><h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//友情提示</span><br>        System.out.println(<span class="hljs-string">&quot;请录入一个字符串:&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextLine();<br>        <span class="hljs-comment">// 定义 每个字符出现次数的方法</span><br>        findChar(line);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findChar</span><span class="hljs-params">(String line)</span> &#123;<br>        <span class="hljs-comment">//1:创建一个集合 存储  字符 以及其出现的次数</span><br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-comment">//2:遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; line.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> line.charAt(i);<br>            <span class="hljs-comment">//判断 该字符 是否在键集中</span><br>            <span class="hljs-keyword">if</span> (!map.containsKey(c)) &#123;<span class="hljs-comment">//说明这个字符没有出现过</span><br>                <span class="hljs-comment">//那就是第一次</span><br>                map.put(c, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//先获取之前的次数</span><br>           <br>                 <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.get(c);<br>                <span class="hljs-comment">//count++;</span><br>                <span class="hljs-comment">//再次存入  更新</span><br>                map.put(c, ++count);<br>            &#125;<br>        &#125;<br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;def&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;ghi&quot;</span>);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloJDK9</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Set&lt;String&gt; str1=Set.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);  <br>        <span class="hljs-comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span><br>        System.out.println(str1);  <br>        Map&lt;String,Integer&gt; str2=Map.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);  <br>        System.out.println(str2);  <br>        List&lt;String&gt; str3=List.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);  <br>        System.out.println(str3);  <br>    &#125;  <br>&#125; <br></code></pre></div></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 </p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug1.png"></p></li><li><p>点击Debug运行模式       <img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug2.png">                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p> <img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug3.png"><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug4.png"></p></li><li><p>Debug调试窗口介绍</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug5.png"></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug6.png"></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug7.png"></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug8.png"></p><p>回车之后效果：<img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug9.png"></p><p>调试界面效果：<img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug0.png"></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug11.png"></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug12.png"></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug13.png"></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug14.png"></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug15.png"></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug16.png"></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\debug17.png"></p></li></ol><h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\斗地主.png"></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li>准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li>洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li>发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li>看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料1\img\斗地主分析.png"></p><h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Poker</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1组装54张扑克牌</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1.1 创建Map集合存储</span><br>        HashMap&lt;Integer, String&gt; pokerMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();<br>        <span class="hljs-comment">// 1.2 创建 花色集合 与 数字集合</span><br>        ArrayList&lt;String&gt; colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">// 1.3 存储 花色 与数字</span><br>        Collections.addAll(colors, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        Collections.addAll(numbers, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">// 设置 存储编号变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        pokerMap.put(count++, <span class="hljs-string">&quot;大王&quot;</span>);<br>        pokerMap.put(count++, <span class="hljs-string">&quot;小王&quot;</span>);<br>        <span class="hljs-comment">// 1.4 创建牌 存储到map集合中</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> color + number;<br>                pokerMap.put(count++, card);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 2 将54张牌顺序打乱</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 取出编号 集合</span><br>        Set&lt;Integer&gt; numberSet = pokerMap.keySet();<br>        <span class="hljs-comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span><br>        ArrayList&lt;Integer&gt; numberList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        numberList.addAll(numberSet);<br><br>        <span class="hljs-comment">// 打乱顺序</span><br>        Collections.shuffle(numberList);<br><br>        <span class="hljs-comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span><br>        <span class="hljs-comment">// 3.1 发牌的编号</span><br>        <span class="hljs-comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span><br>        ArrayList&lt;Integer&gt; noP1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; noP3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        ArrayList&lt;Integer&gt; dipaiNo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 3.2发牌的编号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numberList.size(); i++) &#123;<br>            <span class="hljs-comment">// 获取该编号</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">no</span> <span class="hljs-operator">=</span> numberList.get(i);<br>            <span class="hljs-comment">// 发牌</span><br>            <span class="hljs-comment">// 留出底牌</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">51</span>) &#123;<br>                dipaiNo.add(no);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                    noP1.add(no);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                    noP2.add(no);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    noP3.add(no);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br>        <span class="hljs-comment">// 4.1 对手中编号进行排序</span><br>        Collections.sort(noP1);<br>        Collections.sort(noP2);<br>        Collections.sort(noP3);<br>        Collections.sort(dipaiNo);<br><br>        <span class="hljs-comment">// 4.2 进行牌面的转换</span><br>        <span class="hljs-comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span><br>        ArrayList&lt;String&gt; player1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; player2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; player3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        ArrayList&lt;String&gt; dipai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>        <span class="hljs-comment">// 4.3转换</span><br>        <span class="hljs-keyword">for</span> (Integer i : noP1) &#123;<br>            <span class="hljs-comment">// 4.4 根据编号找到 牌面 pokerMap</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> pokerMap.get(i);<br>            <span class="hljs-comment">// 添加到对应的 牌面集合中</span><br>            player1.add(card);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer i : noP2) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> pokerMap.get(i);<br>            player2.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : noP3) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> pokerMap.get(i);<br>            player3.add(card);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i : dipaiNo) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">card</span> <span class="hljs-operator">=</span> pokerMap.get(i);<br>            dipai.add(card);<br>        &#125;<br><br>        <span class="hljs-comment">//4.5 查看</span><br>        System.out.println(<span class="hljs-string">&quot;令狐冲：&quot;</span>+player1);<br>        System.out.println(<span class="hljs-string">&quot;石破天：&quot;</span>+player2);<br>        System.out.println(<span class="hljs-string">&quot;鸠摩智：&quot;</span>+player3);<br>        System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span>+dipai);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\异常体系.png"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\简单的异常查看.bmp"></p><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p>​    <img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\异常的分类.png"></p><h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTools</span> &#123;<br>    <span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>        intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>        System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\异常产生过程.png"></p><h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1 抛出异常throw"></a>2.1 抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type"></span>异常类名(参数);<br></code></pre></div></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;要访问的arr数组不存在&quot;</span>);<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个数组 </span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">52</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-comment">//根据索引找对应的元素 </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> getElement(arr, index);<br><br>        System.out.println(element);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 根据 索引找到数组中对应的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index)</span>&#123; <br>       <span class="hljs-comment">//判断  索引是否越界</span><br>        <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span> || index&gt;arr.length-<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span><br><span class="hljs-comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;哥们，角标越界了~~~&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码发现这里对为null的进行了抛出异常操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">requireNonNull</span><span class="hljs-params">(T obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj">修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>…&#123;   &#125;<br></code></pre></div></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowsDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span><span class="hljs-keyword">throws</span> FileNotFoundException, IOException &#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;b.txt&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型  e)&#123;<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span><br>            read(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<span class="hljs-comment">// 括号中需要定义什么呢？</span><br>          <span class="hljs-comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span><br>            System.out.println(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li><li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p></li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryCatchDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            <span class="hljs-comment">//抓取到的是编译期异常  抛出去的是运行期 </span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-keyword">if</span> (!path.equals(<span class="hljs-string">&quot;a.txt&quot;</span>)) &#123;<span class="hljs-comment">//如果不是 a.txt这个文件 </span><br>            <span class="hljs-comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\死了都要try.bmp"></p><h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A  e)&#123;  当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B  e)&#123;  当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 业务逻辑异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空参构造</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 表示异常提示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-comment">// 模拟数据库中已存在账号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] names = &#123;<span class="hljs-string">&quot;bill&quot;</span>,<span class="hljs-string">&quot;hill&quot;</span>,<span class="hljs-string">&quot;jill&quot;</span>&#125;;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;     <br>        <span class="hljs-comment">//调用方法</span><br>        <span class="hljs-keyword">try</span>&#123;<br>              <span class="hljs-comment">// 可能出现异常的代码</span><br>            checkUsername(<span class="hljs-string">&quot;nill&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;注册成功&quot;</span>);<span class="hljs-comment">//如果没有异常就是注册成功</span><br>        &#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>            <span class="hljs-comment">//处理异常</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断当前注册账号是否存在</span><br>    <span class="hljs-comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkUsername</span><span class="hljs-params">(String uname)</span> <span class="hljs-keyword">throws</span> LoginException&#123;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-keyword">if</span>(name.equals(uname))&#123;<span class="hljs-comment">//如果名字在这里面 就抛出登陆异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterException</span>(<span class="hljs-string">&quot;亲&quot;</span>+name+<span class="hljs-string">&quot;已经被注册了！&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p><p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p><h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\并行与并发.bmp"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\进程概念.png"></p><p><strong>线程</strong></p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\线程概念.png"></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\设置线程优先级.bmp" alt="设置线程优先级"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料2\img\抢占式调度.bmp" alt="抢占式调度"></p></li></ul></li></ul><h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建自定义线程对象</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;新的线程！&quot;</span>);<br><span class="hljs-comment">//开启新线程</span><br>mt.start();<br><span class="hljs-comment">//在主方法中执行for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;main线程！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-comment">//定义指定线程名称的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-comment">//调用父类的String参数的构造方法，指定线程的名称</span><br><span class="hljs-built_in">super</span>(name);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写run方法，完成该线程执行的逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;：正在执行！&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1.1 多线程原理"></a>1.1 多线程原理</h2><p>昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序图来体现一下多线程程序的执行流程。<br>代码如下：<br>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 利用继承中的特点</span><br><span class="hljs-comment">    * 将线程名称传递 进行设置</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 重写run方法</span><br><span class="hljs-comment">        * 定义线程要执行的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        <span class="hljs-comment">//getName()方法 来自父亲</span><br>        System.out.println(getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这里是main线程&quot;</span>);<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;小强&quot;</span>);<br>        mt.start();<span class="hljs-comment">//开启了一个新的线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;旺财:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923213334595.png" alt="image-20210923213334595"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p><p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</p><p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923213450049.png" alt="image-20210923213450049"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p><h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1.2 Thread类"></a>1.2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread 类，API中该类中定义了有关线程的一些方法，具体如下：</p><p>构造方法：</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>() :分配一个新的线程对象。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-built_in">String</span> name) :分配一个指定名字的新的线程对象。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target) :分配一个带有指定目标新的线程对象。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Thread</span>(Runnable target,<span class="hljs-built_in">String</span> name) :分配一个带有指定目标新的线程对象并指定名字。<br></code></pre></div></td></tr></table></figure><p>常用方法：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() :获取当前线程名称。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>() :导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() :此线程要执行的任务在此处定义代码。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> millis</span>) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread <span class="hljs-title">currentThread</span>() :返回对当前正在执行的线程对象的引用。</span><br></code></pre></div></td></tr></table></figure><p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</p><h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1.3 创建线程方式二"></a>1.3 创建线程方式二</h2><p>采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。<br>步骤如下：</p><ol><li><p>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p></li><li><p>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br> 的线程对象。</p></li><li><p>调用线程对象的start()方法来启动线程。</p></li></ol><p>  代码如下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建自定义类对象 线程任务对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">//创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr, <span class="hljs-string">&quot;小强&quot;</span>);<br>        t.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;旺财 &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。</p><p>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1.4 Thread和Runnable的区别"></a>1.4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p>总结：</p><p>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去共享同 一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li></ol><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p><h2 id="1-5-匿名内部类方式实现线程的创建"><a href="#1-5-匿名内部类方式实现线程的创建" class="headerlink" title="1.5 匿名内部类方式实现线程的创建"></a>1.5 匿名内部类方式实现线程的创建</h2><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。<br>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NoNameInnerClassThread</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// new Runnable()&#123;</span><br>        <span class="hljs-comment">// public void run()&#123;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; 20; i++) &#123;</span><br>        <span class="hljs-comment">// System.out.println(&quot;张宇:&quot;+i);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span><br>        <br><br>      Runnable r = <span class="hljs-keyword">new</span> Runnable()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;张宇:&quot;</span>+i);<br>                    &#125;<br>                &#125;<br>       &#125;;<br>        <span class="hljs-keyword">new</span> Thread(r).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;费玉清:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2.1 线程安全"></a>2.1 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>我们通过一个案例，演示线程的安全问题：</p><p>电影院要卖票，我们模拟电影院的卖票过程。本次电影的座位共100个(本场电影只能卖100张票)。我们来模拟电影院的售票窗口，多个窗口一起卖这100张票，采用线程对象来模拟；</p><p>模拟票：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//每个窗口卖票的操作</span><br>            <span class="hljs-comment">//窗口 永远开启</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                 <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有票 可以卖</span><br>                        <span class="hljs-comment">//出票操作</span><br>                        <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>                        e.printStackTrace();<br>                    &#125;<br>                     <span class="hljs-comment">//获取当前线程对象的名字</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>                    System.out.println(name + <span class="hljs-string">&quot;正在卖:&quot;</span> + ticket‐‐);<br>                    &#125;<br>             &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建线程任务对象</span><br>        <span class="hljs-type">Ticket</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ticket</span>();<br>        <span class="hljs-comment">//创建三个窗口对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket, <span class="hljs-string">&quot;窗口1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket, <span class="hljs-string">&quot;窗口2&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ticket, <span class="hljs-string">&quot;窗口3&quot;</span>);<br>        <span class="hljs-comment">//同时卖票</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923221645603.png" alt="image-20210923221645603"></p><p>发现程序出现了两个问题：</p><ol><li><p>相同的票数,比如5这张票被卖了两回。</p></li><li><p>不存在的票，比如0票与-1票，是不存在的。</p></li></ol><p>  这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，<br>  否则的话就可能影响线程安全。</p><h2 id="2-2-线程同步"><a href="#2-2-线程同步" class="headerlink" title="2.2 线程同步"></a>2.2 线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全题。<br>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步制<br>(synchronized)来解决。</p><p>根据案例简述：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">窗口<span class="hljs-number">1</span>线程进入操作的时候，窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>线程只能在外等着，窗口<span class="hljs-number">1</span>操作结束，窗口<span class="hljs-number">1</span>和窗口<span class="hljs-number">2</span>和窗口<span class="hljs-number">3</span>才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺<span class="hljs-meta">CPU</span>资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。<br></code></pre></div></td></tr></table></figure><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。<br>那么怎么去使用呢？有三种方式完成同步操作：</p><ol><li>同步代码块。</li><li>同步方法。</li><li>锁机制。</li></ol><h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2.3 同步代码块"></a>2.3 同步代码块</h2><p>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式:</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(同步锁)</span></span>&#123;<br>需要同步操作的代码<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同步锁:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ol><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。使用同步代码块解决代码：</p><p>使用同步代码块解决代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>                    <span class="hljs-comment">//出票操作</span><br>                    <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">50</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                      <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>                    e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-comment">//获取当前线程对象的名字</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>                    System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p><h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2.4 同步方法"></a>2.4 同步方法</h2><p>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>可能会产生线程安全问题的代码<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</p><p>使用同步方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>           sellTicket();<br>        &#125;<br>    &#125;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * 锁对象 是 谁调用这个方法 就是谁</span><br><span class="hljs-comment">            * 隐含 锁对象 就是 this</span><br><span class="hljs-comment">            *</span><br><span class="hljs-comment">            */</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sellTicket</span><span class="hljs-params">()</span>&#123;<br>         <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>                <span class="hljs-comment">//出票操作</span><br>                <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>                e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">//获取当前线程对象的名字</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>                System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2.5 Lock锁"></a>2.5 Lock锁</h2><p>java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>() :加同步锁。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>() :释放同步锁。</span><br></code></pre></div></td></tr></table></figure><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 执行卖票操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//每个窗口卖票的操作</span><br>        <span class="hljs-comment">//窗口 永远开启</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">if</span>(ticket&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//有票 可以卖</span><br>            <span class="hljs-comment">//出票操作</span><br>            <span class="hljs-comment">//使用sleep模拟一下出票时间</span><br>            <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto‐generated catch block</span><br>            e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//获取当前线程对象的名字</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            System.out.println(name+<span class="hljs-string">&quot;正在卖:&quot;</span>+ticket‐‐);<br>            &#125;<br>            lock.unlock(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><h2 id="3-1-线程状态概述"><a href="#3-1-线程状态概述" class="headerlink" title="3.1 线程状态概述"></a>3.1 线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923224357597.png" alt="image-20210923224357597"></p><p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p><h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3.2 Timed Waiting（计时等待）"></a>3.2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？<br>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。<br>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。</p><p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串<br>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> ((i) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐&quot;</span> + i);<br>            &#125;<br>            System.out.print(i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                System.out.print(<span class="hljs-string">&quot; 线程睡眠1秒！\n&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>       &#125;<br>   &#125;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li></ol><p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923224932600.png" alt="image-20210923224932600"></p><h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3.3 BLOCKED（锁阻塞）"></a>3.3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。<br>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。<br>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。</p><p>Blocked 线程状态图</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923225022131.png" alt="image-20210923225022131"></p><h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3.4 Waiting（无限等待）"></a>3.4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来</p><p>学习一下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitingTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 演示waiting</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            System.out.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);<br>                                    obj.wait(); <span class="hljs-comment">//无限等待</span><br>                            <span class="hljs-comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span><br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        System.out.println( Thread.currentThread().getName() + <span class="hljs-string">&quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;等待线程&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// while (true)&#123; //每隔3秒 唤醒一次</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                    System.out.println( Thread.currentThread().getName() +<span class="hljs-string">&quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;</span>);<br>                            obj.notify();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// &#125;</span><br>        &#125;,<span class="hljs-string">&quot;唤醒线程&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。<br>Waiting 线程状态图</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923225817125.png" alt="image-20210923225817125"></p><p>补充</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20210923225827659.png" alt="image-20210923225827659"></p><p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p><h1 id="第一章-等待唤醒机制"><a href="#第一章-等待唤醒机制" class="headerlink" title="第一章 等待唤醒机制"></a>第一章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\线程间通信.bmp"></p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait&#x2F;notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="hljs-literal">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="hljs-literal">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="hljs-literal">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。<br></code></pre></div></td></tr></table></figure><p><strong>代码演示：</strong></p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaoZi</span> &#123;<br>     String  pier ;<br>     String  xianer ;<br>     <span class="hljs-type">boolean</span>  <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span> ;<span class="hljs-comment">//包子资源 是否存在  包子资源状态</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChiHuo</span><span class="hljs-params">(String name,BaoZi bz)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.bz = bz;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//没包子</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="hljs-string">&quot;包子&quot;</span>);<br>                bz.flag = <span class="hljs-literal">false</span>;<br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> BaoZi bz;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaoZiPu</span><span class="hljs-params">(String name,BaoZi bz)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//造包子</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//同步</span><br>            <span class="hljs-keyword">synchronized</span> (bz)&#123;<br>                <span class="hljs-keyword">if</span>(bz.flag == <span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//包子资源  存在</span><br>                    <span class="hljs-keyword">try</span> &#123;<br><br>                        bz.wait();<br><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 没有包子  造包子</span><br>                System.out.println(<span class="hljs-string">&quot;包子铺开始做包子&quot;</span>);<br>                <span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 冰皮  五仁</span><br>                    bz.pier = <span class="hljs-string">&quot;冰皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;五仁&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 薄皮  牛肉大葱</span><br>                    bz.pier = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                    bz.xianer = <span class="hljs-string">&quot;牛肉大葱&quot;</span>;<br>                &#125;<br>                count++;<br><br>                bz.flag=<span class="hljs-literal">true</span>;<br>                System.out.println(<span class="hljs-string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);<br>                System.out.println(<span class="hljs-string">&quot;吃货来吃吧&quot;</span>);<br>                <span class="hljs-comment">//唤醒等待线程 （吃货）</span><br>                bz.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//等待唤醒案例</span><br>        <span class="hljs-type">BaoZi</span> <span class="hljs-variable">bz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaoZi</span>();<br><br>        <span class="hljs-type">ChiHuo</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChiHuo</span>(<span class="hljs-string">&quot;吃货&quot;</span>,bz);<br>        <span class="hljs-type">BaoZiPu</span> <span class="hljs-variable">bzp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaoZiPu</span>(<span class="hljs-string">&quot;包子铺&quot;</span>,bz);<br><br>        ch.start();<br>        bzp.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br>包子铺开始做包子<br>包子造好了：薄皮牛肉大葱<br>吃货来吃吧<br>吃货正在吃薄皮牛肉大葱包子<br>包子铺开始做包子<br>包子造好了：冰皮五仁<br>吃货来吃吧<br>吃货正在吃冰皮五仁包子<br></code></pre></div></td></tr></table></figure><h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\游泳池.jpg"></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p><h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\线程池原理.bmp"></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我要一个教练&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//包含2个线程对象</span><br>        <span class="hljs-comment">// 创建Runnable实例对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><br>        <span class="hljs-comment">//自己创建线程对象的方式</span><br>        <span class="hljs-comment">// Thread t = new Thread(r);</span><br>        <span class="hljs-comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span><br><br>        <span class="hljs-comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span><br>        service.submit(r);<br>        <span class="hljs-comment">// 再获取个线程对象，调用MyRunnable中的run()</span><br>        service.submit(r);<br>        service.submit(r);<br>        <span class="hljs-comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span><br>        <span class="hljs-comment">// 将使用完的线程又归还到了线程池中</span><br>        <span class="hljs-comment">// 关闭线程池</span><br>        <span class="hljs-comment">//service.shutdown();</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\03-Overview.png"></p><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Runnable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 匿名内部类</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 覆盖重写抽象方法</span><br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\01-交通方式.png"></p><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\课件资料4\img\02-Lambda.png"></p><p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02LambdaRunnable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="hljs-comment">// 启动线程</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>为了理解Lambda的语义，我们需要从传统的代码起步。</p><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03ThreadInitParam</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableImpl</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04ThreadNameless</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>&#125;<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>)<br></code></pre></div></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型 参数名称)</span> -&gt;</span> &#123; 代码语句 &#125;<br></code></pre></div></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cook</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeFood</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05InvokeCook</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeCook</span><span class="hljs-params">(Cook cook)</span> &#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    invokeCook(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p></blockquote><h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">需求:<br>    使用数组存储多个<span class="hljs-keyword">Person</span>对象<br>    对数组中的<span class="hljs-keyword">Person</span>对象使用Arrays的sort方法通过年龄进行升序排序<br></code></pre></div></td></tr></table></figure><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 省略构造器、toString方法与Getter Setter </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06Comparator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 本来年龄乱序的对象数组</span><br>        Person[] array = &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>      <span class="hljs-comment">// 匿名内部类</span><br>        Comparator&lt;Person&gt; comp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>            &#125;<br>        &#125;;<br>        Arrays.sort(array, comp); <span class="hljs-comment">// 第二个参数为排序规则，即Comparator接口实例</span><br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07ComparatorLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person[] array = &#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-number">19</span>),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">18</span>),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-number">20</span>) &#125;;<br><br>        Arrays.sort(array, (Person a, Person b) -&gt; &#123;<br>          <span class="hljs-keyword">return</span> a.getAge() - b.getAge();<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Person person : array) &#123;<br>            System.out.println(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08InvokeCalc</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, Calculator calculator)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.calc(a, b);<br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; &#123;<br>      <span class="hljs-keyword">return</span> a + b;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p></blockquote><h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  invokeCalc(<span class="hljs-number">120</span>, <span class="hljs-number">130</span>, (a, b) -&gt; a + b);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09InvokeCook</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeCook</span><span class="hljs-params">(Cook cook)</span> &#123;<br>        cook.makeFood();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  invokeCook(() -&gt; System.out.println(<span class="hljs-string">&quot;吃饭啦！&quot;</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用&#x3D;&#x3D;Lambda必须具有接口&#x3D;&#x3D;，且要&#x3D;&#x3D;求<strong>接口中有且仅有一个抽象方法</strong>。&#x3D;&#x3D;<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述-2"><a href="#1-1-概述-2" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul><li><p><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </p></li><li><p><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</p></li><li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </p></li><li><p>构造举例，代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 文件路径名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">pathname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(pathname); <br><br><span class="hljs-comment">// 文件路径名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">pathname2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\aaa\\bbb.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(pathname2); <br><br><span class="hljs-comment">// 通过父路径和子路径字符串</span><br> <span class="hljs-type">String</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;d:\\aaa&quot;</span>;<br> <span class="hljs-type">String</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br> <span class="hljs-type">File</span> <span class="hljs-variable">file3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parent, child);<br><br><span class="hljs-comment">// 通过父级File对象和子路径字符串</span><br><span class="hljs-type">File</span> <span class="hljs-variable">parentDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbb.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">file4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentDir, child);<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>&#x3D;&#x3D;无论该路径下是否存在文件或者目录，都不影响File对象的创建。&#x3D;&#x3D;</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileGet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/aaa/bbb.java&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;文件构造路径:&quot;</span>+f.getPath());<br>        System.out.println(<span class="hljs-string">&quot;文件名称:&quot;</span>+f.getName());<br>        System.out.println(<span class="hljs-string">&quot;文件长度:&quot;</span>+f.length()+<span class="hljs-string">&quot;字节&quot;</span>);<br><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:/aaa&quot;</span>);     <br>        System.out.println(<span class="hljs-string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());<br>        System.out.println(<span class="hljs-string">&quot;目录构造路径:&quot;</span>+f2.getPath());<br>        System.out.println(<span class="hljs-string">&quot;目录名称:&quot;</span>+f2.getName());<br>        System.out.println(<span class="hljs-string">&quot;目录长度:&quot;</span>+f2.length());<br>    &#125;<br>&#125;<br>输出结果：<br>文件绝对路径:d:\aaa\bbb.java<br>文件构造路径:d:\aaa\bbb.java<br>文件名称:bbb.java<br>文件长度:<span class="hljs-number">636</span>字节<br><br>目录绝对路径:d:\aaa<br>目录构造路径:d:\aaa<br>目录名称:aaa<br>目录长度:<span class="hljs-number">4096</span><br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilePath</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// D盘下的bbb.java文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\bbb.java&quot;</span>);<br>        System.out.println(f.getAbsolutePath());<br>      <br><span class="hljs-comment">// 项目下的bbb.java文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;bbb.java&quot;</span>);<br>        System.out.println(f2.getAbsolutePath());<br>    &#125;<br>&#125;<br>输出结果：<br>D:\bbb.java<br>D:\idea_project_test4\bbb.java<br></code></pre></div></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileIs</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\aaa\\bbb.java&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 判断是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());<br>      <span class="hljs-comment">// 判断是文件还是目录</span><br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());<br>        System.out.println(<span class="hljs-string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());<br>    &#125;<br>&#125;<br>输出结果：<br>d:\aaa\bbb.java 是否存在:<span class="hljs-literal">true</span><br>d:\aaa 是否存在:<span class="hljs-literal">true</span><br>d:\aaa 文件?:<span class="hljs-literal">false</span><br>d:\aaa 目录?:<span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCreateDelete</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 文件的创建</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;aaa.txt&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f.exists()); <span class="hljs-comment">// true</span><br><br>     <span class="hljs-comment">// 目录的创建</span><br>      File f2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newDir&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;是否存在:&quot;</span>+f2.exists());<span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 创建多级目录</span><br>      File f3= <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f3.mkdir());<span class="hljs-comment">// false</span><br>        File f4= <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;newDira\\newDirb&quot;</span>);<br>        System.out.println(f4.mkdirs());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 文件的删除</span><br>       System.out.println(f.delete());<span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 目录的删除</span><br>        System.out.println(f2.delete());<span class="hljs-comment">// true</span><br>        System.out.println(f4.delete());<span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>API中说明：delete方法，&#x3D;&#x3D;如果此File表示目录，则目录必须为空才能删除&#x3D;&#x3D;。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p></li><li><p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileFor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;d:\\java_code&quot;</span>);<br>      <br>      <span class="hljs-comment">//获取当前目录下的文件以及文件夹的名称。</span><br>String[] names = dir.list();<br><span class="hljs-keyword">for</span>(String name : names)&#123;<br>System.out.println(name);<br>&#125;<br>        <span class="hljs-comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span><br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            System.out.println(file);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01DiGui</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// a();</span><br>b(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 3.构造方法,禁止递归</span><br><span class="hljs-comment"> * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo01DiGui</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//Demo01DiGui();</span><br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span><br><span class="hljs-comment"> * 4993</span><br><span class="hljs-comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>System.out.println(i);<br><span class="hljs-comment">//添加一个递归结束的条件,i==5000的时候结束</span><br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">5000</span>)&#123;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束方法</span><br>&#125;<br>b(++i);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span><br><span class="hljs-comment"> * java.lang.StackOverflowError</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;a方法&quot;</span>);<br>a();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 &#x3D; num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiGuiDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//计算1~num的和，使用递归完成</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>      <span class="hljs-comment">// 调用求和的方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(num);<br>      <span class="hljs-comment">// 输出结果</span><br>System.out.println(sum);<br><br>&#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>      <span class="hljs-comment">/* </span><br><span class="hljs-comment">         num为1时,方法返回1,</span><br><span class="hljs-comment">         相当于是方法的出口,num总有是1的情况</span><br><span class="hljs-comment">      */</span><br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">          num不为1时,方法返回 num +(num-1)的累和</span><br><span class="hljs-comment">          递归调用getSum方法</span><br><span class="hljs-comment">        */</span><br><span class="hljs-keyword">return</span> num + getSum(num-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\1\img\day08_01_递归累和.jpg"></p><blockquote><p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">n的阶乘：n! = n * (n-<span class="hljs-number">1</span>) *...* <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> <br></code></pre></div></td></tr></table></figure><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">推理得出：<span class="hljs-built_in">n</span>! = <span class="hljs-built_in">n</span> * (<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)!<br></code></pre></div></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiGuiDemo</span> &#123;<br>  <span class="hljs-comment">//计算n的阶乘，使用递归完成</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>      <span class="hljs-comment">// 调用求阶乘的方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> getValue(n);<br>      <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;阶乘为:&quot;</span>+ value);<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    通过递归算法实现.</span><br><span class="hljs-comment">    参数列表:int </span><br><span class="hljs-comment">    返回值类型: int </span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-comment">// 1的阶乘为1</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        n不为1时,方法返回 n! = n*(n-1)!</span><br><span class="hljs-comment">          递归调用getValue方法</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">return</span> n * getValue(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiGuiDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建File对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">printDir</span><span class="hljs-params">(File dir)</span> &#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <span class="hljs-comment">// 循环打印</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        判断:</span><br><span class="hljs-comment">        当是文件时,打印绝对路径.</span><br><span class="hljs-comment">        当是目录时,继续调用打印目录的方法,形成递归调用.</span><br><span class="hljs-comment">      */</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>    <span class="hljs-comment">// 判断</span><br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件,输出文件绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 是目录,输出目录绝对路径</span><br>                System.out.println(<span class="hljs-string">&quot;目录:&quot;</span>+file.getAbsolutePath());<br>              <span class="hljs-comment">// 继续遍历,调用printDir,形成递归</span><br>                printDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiGuiDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建File对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>      <span class="hljs-comment">// 调用打印目录方法</span><br>        printDir(dir);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDir</span><span class="hljs-params">(File dir)</span> &#123;<br>      <span class="hljs-comment">// 获取子文件和目录</span><br>        File[] files = dir.listFiles();<br>      <br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>              <span class="hljs-comment">// 是文件，判断文件名并输出文件绝对路径</span><br>                <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 是目录，继续遍历,形成递归</span><br>                printDir(file); <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiGuiDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>        printDir2(dir);<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDir2</span><span class="hljs-params">(File dir)</span> &#123;<br>      <span class="hljs-comment">// 匿名内部类方式,创建过滤器子类对象</span><br>        File[] files = dir.listFiles(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileFilter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(File pathname)</span> &#123;<br>                <span class="hljs-keyword">return</span> pathname.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>)||pathname.isDirectory();<br>            &#125;<br>        &#125;);<br>      <span class="hljs-comment">// 循环打印</span><br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                printDir2(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;      <br></code></pre></div></td></tr></table></figure><h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">()-&gt;&#123; &#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDir3</span><span class="hljs-params">(File dir)</span> &#123;<br>  <span class="hljs-comment">// lambda的改写</span><br>    File[] files = dir.listFiles(f -&gt;&#123; <br>      <span class="hljs-keyword">return</span> f.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>) || f.isDirectory(); <br>    &#125;);<br>  <br><span class="hljs-comment">// 循环打印</span><br>    <span class="hljs-keyword">for</span> (File file : files) &#123;<br>        <span class="hljs-keyword">if</span> (file.isFile()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span> + file.getAbsolutePath());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        printDir3(file);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第一章-IO概述"><a href="#第一章-IO概述" class="headerlink" title="第一章 IO概述"></a>第一章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I&#x2F;O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h2><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\2\img\1_io.jpg"></p><h2 id="1-4-顶级父类们"><a href="#1-4-顶级父类们" class="headerlink" title="1.4 顶级父类们"></a>1.4 顶级父类们</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br><strong>InputStream</strong></td><td align="center">字节输出流<br><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br><strong>Reader</strong></td><td align="center">字符输出流<br><strong>Writer</strong></td></tr></tbody></table><h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStreamConstructor</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FOSWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字节</span><br>      fos.write(<span class="hljs-number">98</span>); <span class="hljs-comment">// 写出第2个字节</span><br>      fos.write(<span class="hljs-number">99</span>); <span class="hljs-comment">// 写出第3个字节</span><br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>abc<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FOSWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-type">byte</span>[] b = <span class="hljs-string">&quot;黑马程序员&quot;</span>.getBytes();<br>      <span class="hljs-comment">// 写出字节数组数据</span><br>      fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马程序员<br></code></pre></div></td></tr></table></figure><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FOSWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-type">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>输出结果：<br>cd<br></code></pre></div></td></tr></table></figure><h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。</li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FOSWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>，<span class="hljs-literal">true</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-type">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br>        fos.write(b);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br>文件操作前：cd<br>文件操作后：cdabcde<br></code></pre></div></td></tr></table></figure><h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p><p>以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FOSWrite</span> &#123;<br>  <br>    <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);  <br>      <span class="hljs-comment">// 定义字节数组</span><br>      <span class="hljs-type">byte</span>[] words = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>&#125;;<br>      <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>          <span class="hljs-comment">// 写出一个字节</span><br>            fos.write(words[i]);<br>          <span class="hljs-comment">// 写出一个换行, 换行符号转成数组写出</span><br>            fos.write(<span class="hljs-string">&quot;\r\n&quot;</span>.getBytes());<br>        &#125;<br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamConstructor</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FISRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 读取数据，返回一个字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> fis.read();<br>        System.out.println((<span class="hljs-type">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-type">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-type">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-type">char</span>) read);<br>        read = fis.read();<br>        System.out.println((<span class="hljs-type">char</span>) read);<br>      <span class="hljs-comment">// 读取到末尾,返回-1</span><br>       read = fis.read();<br>        System.out.println( read);<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br>-<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>循环改进读取方式，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FISRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-type">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fis.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-type">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>&#x3D;&#x3D;虽然读取了一个字节，但是会自动提升为int类型。&#x3D;&#x3D;</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FISRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde</span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-type">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>ed<br></code></pre></div></td></tr></table></figure><p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FISRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象.</span><br>       <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;read.txt&quot;</span>); <span class="hljs-comment">// 文件中为abcde </span><br>      <span class="hljs-comment">// 定义变量，作为有效个数</span><br>        <span class="hljs-type">int</span> len ；<br>        <span class="hljs-comment">// 定义字节数组，作为装字节数据的容器   </span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> (( len= fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b，<span class="hljs-number">0</span>，len));<span class="hljs-comment">//  len 每次读取的有效字节个数</span><br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fis.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>ab<br>cd<br>e<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/Users\baixxq\Desktop\新建文件夹\2\img\2_copy.jpg"></p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Copy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1.创建流对象</span><br>        <span class="hljs-comment">// 1.1 指定数据源</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\test.jpg&quot;</span>);<br>        <span class="hljs-comment">// 1.2 指定目的地</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test_copy.jpg&quot;</span>);<br><br>        <span class="hljs-comment">// 2.读写数据</span><br>        <span class="hljs-comment">// 2.1 定义数组</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// 2.2 定义长度</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-comment">// 2.3 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 2.4 写出数据</span><br>            fos.write(b, <span class="hljs-number">0</span> , len);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.关闭资源</span><br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><p>流的关闭原则：先开后关，后开先关。</p></blockquote><h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是&#x3D;&#x3D;因为一个中文字符可能占用多个字节存储&#x3D;&#x3D;。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p><p>idea中UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderConstructor</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，&#x3D;&#x3D;每次可以读取一个字符的数据，提升为int类型&#x3D;&#x3D;，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FRRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存数据</span><br>        <span class="hljs-type">int</span> b ；<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println((<span class="hljs-type">char</span>)b);<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑<br>马<br>程<br>序<br>员<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FRRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-type">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>         <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cbuf));<br>        &#125;<br><span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br>输出结果：<br>黑马<br>程序<br>员序<br></code></pre></div></td></tr></table></figure><p>获取有效的字符改进，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FISRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">// 使用文件名称创建流对象</span><br>       <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>      <span class="hljs-comment">// 定义变量，保存有效字符个数</span><br>        <span class="hljs-type">int</span> len ；<br>        <span class="hljs-comment">// 定义字符数组，作为装字符数据的容器</span><br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cbuf,<span class="hljs-number">0</span>,len));<br>        &#125;<br>    <span class="hljs-comment">// 关闭资源</span><br>        fr.close();<br>    &#125;<br>&#125;<br><br>输出结果：<br>黑马<br>程序<br>员<br></code></pre></div></td></tr></table></figure><h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法</p><p>。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriterConstructor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 使用File对象创建流对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file);<br>      <br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FWWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 写出数据</span><br>      fw.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// 写出第1个字符</span><br>      fw.write(<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// 写出第2个字符</span><br>      fw.write(<span class="hljs-string">&#x27;C&#x27;</span>); <span class="hljs-comment">// 写出第3个字符</span><br>      fw.write(<span class="hljs-number">30000</span>); <span class="hljs-comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span><br>      <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        【注意】关闭资源时,与FileOutputStream不同。</span><br><span class="hljs-comment">       如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// fw.close();</span><br>    &#125;<br>&#125;<br>输出结果：<br>abC田<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FWWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>        <span class="hljs-comment">// 写出数据，通过flush</span><br>        fw.write(<span class="hljs-string">&#x27;刷&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.flush();<br>        fw.write(<span class="hljs-string">&#x27;新&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符，写出成功</span><br>        fw.flush();<br>      <br>      <span class="hljs-comment">// 写出数据，通过close</span><br>        fw.write(<span class="hljs-string">&#x27;关&#x27;</span>); <span class="hljs-comment">// 写出第1个字符</span><br>        fw.close();<br>        fw.write(<span class="hljs-string">&#x27;闭&#x27;</span>); <span class="hljs-comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FWWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串转换为字节数组</span><br>      <span class="hljs-type">char</span>[] chars = <span class="hljs-string">&quot;黑马程序员&quot;</span>.toCharArray();<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(chars); <span class="hljs-comment">// 黑马程序员</span><br>        <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(b,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 程序</span><br>      <br>      <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FWWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>);     <br>      <span class="hljs-comment">// 字符串</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马程序员&quot;</span>;<br>      <br>      <span class="hljs-comment">// 写出字符数组</span><br>      fw.write(msg); <span class="hljs-comment">//黑马程序员</span><br>      <br><span class="hljs-comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span><br>        fw.write(msg,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// 程序</span><br>      <br>        <span class="hljs-comment">// 关闭资源</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FWWrite</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用文件名称创建流对象，可以续写数据</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>，<span class="hljs-literal">true</span>);     <br>      <span class="hljs-comment">// 写出字符串</span><br>        fw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>      fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>      <span class="hljs-comment">// 写出字符串</span><br>  fw.write(<span class="hljs-string">&quot;程序员&quot;</span>);<br>      <span class="hljs-comment">// 关闭资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br>输出结果:<br>黑马<br>程序员<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：字符流，&#x3D;&#x3D;只能操作文本文件，不能操作图片，视频等非文本文件&#x3D;&#x3D;。</p><p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p></blockquote><h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleException1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 声明变量</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建流对象</span><br>            fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>);<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>) &#123;<br>                    fw.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (创建流对象语句，如果多个,使用<span class="hljs-string">&#x27;;&#x27;</span>隔开) &#123;<br><span class="hljs-comment">// 读写数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleException2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> ( <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;fw.txt&quot;</span>); ) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(<span class="hljs-string">&quot;黑马程序员&quot;</span>); <span class="hljs-comment">//黑马程序员 </span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Resource</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource2&quot;</span>);<br><span class="hljs-comment">// 引入方式：创建新的变量保存</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Resource</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> resource1;<br>     <span class="hljs-type">Resource</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> resource2) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>改进后格式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 被final修饰的对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Resource</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// 普通对象</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource2&quot;</span>);<br><br><span class="hljs-comment">// 引入方式：直接引入</span><br><span class="hljs-keyword">try</span> (resource1; resource2<br>    ) &#123;<br>     <span class="hljs-comment">// 使用对象</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>改进后，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">final</span>  <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;in.txt&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;out.txt&quot;</span>);<br>       <span class="hljs-comment">// 引入到try中</span><br>        <span class="hljs-keyword">try</span> (fr; fw) &#123;<br>          <span class="hljs-comment">// 定义变量</span><br>            <span class="hljs-type">int</span> b;<br>          <span class="hljs-comment">// 读取数据</span><br>          <span class="hljs-keyword">while</span> ((b = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 写出数据</span><br>            fw.write(b);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述-1"><a href="#5-1-概述-1" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 添加键值对元素</span><br>        properties.setProperty(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;a.txt&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;209385038&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-string">&quot;D:\\a.txt&quot;</span>);<br>        <span class="hljs-comment">// 打印属性集对象</span><br>        System.out.println(properties);<br>        <span class="hljs-comment">// 通过键,获取属性值</span><br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;filename&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;length&quot;</span>));<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;location&quot;</span>));<br><br>        <span class="hljs-comment">// 遍历属性集,获取所有键的集合</span><br>        Set&lt;String&gt; strings = properties.stringPropertyNames();<br>        <span class="hljs-comment">// 打印键值对</span><br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+properties.getProperty(key));<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>&#123;filename=a.txt, length=<span class="hljs-number">209385038</span>, location=D:\a.txt&#125;<br>a.txt<br><span class="hljs-number">209385038</span><br>D:\a.txt<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></div></td></tr></table></figure><h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">filename</span>=a.txt<br><span class="hljs-attr">length</span>=<span class="hljs-number">209385038</span><br><span class="hljs-attr">location</span>=D:\a.txt<br></code></pre></div></td></tr></table></figure><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 创建属性集对象</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 加载文本中信息到属性集</span><br>        pro.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;read.txt&quot;</span>));<br>        <span class="hljs-comment">// 遍历集合并打印</span><br>        Set&lt;String&gt; strings = pro.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String key : strings ) &#123;<br>          System.out.println(key+<span class="hljs-string">&quot; -- &quot;</span>+pro.getProperty(key));<br>        &#125;<br>     &#125;<br>&#125;<br>输出结果：<br>filename -- a.txt<br>length -- <span class="hljs-number">209385038</span><br>location -- D:\a.txt<br></code></pre></div></td></tr></table></figure><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><h1 id="day10【缓冲流、转换流、序列化流】"><a href="#day10【缓冲流、转换流、序列化流】" class="headerlink" title="day10【缓冲流、转换流、序列化流】"></a>day10【缓冲流、转换流、序列化流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>缓冲流</li><li>转换流</li><li>序列化流</li><li>打印流</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled type="checkbox"> 能够使用字节缓冲流读取数据到程序</li><li><input disabled type="checkbox"> 能够使用字节缓冲流写出数据到文件</li><li><input disabled type="checkbox"> 能够明确字符缓冲流的作用和基本用法</li><li><input disabled type="checkbox"> 能够使用缓冲流的特殊功能</li><li><input disabled type="checkbox"> 能够阐述编码表的意义</li><li><input disabled type="checkbox"> 能够使用转换流读取指定编码的文本文件</li><li><input disabled type="checkbox"> 能够使用转换流写入指定编码的文本文件</li><li><input disabled type="checkbox"> 能够说出打印流的特点</li><li><input disabled type="checkbox"> 能够使用序列化流写出对象到文件</li><li><input disabled type="checkbox"> 能够使用反序列化流读取文件到程序中</li></ul><h1 id="第一章-缓冲流"><a href="#第一章-缓冲流" class="headerlink" title="第一章 缓冲流"></a>第一章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p><h2 id="1-1-概述-3"><a href="#1-1-概述-3" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>Buf feredOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建字节缓冲输入流</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;bis.txt&quot;</span>));<br><span class="hljs-comment">// 创建字节缓冲输出流</span><br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bos.txt&quot;</span>));<br></code></pre></div></td></tr></table></figure><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><ol><li>基本流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdk9.exe&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.exe&quot;</span>)<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-type">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>十几分钟过去了...<br></code></pre></div></td></tr></table></figure><ol start="2"><li>缓冲流，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 记录开始时间</span><br>      <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br>     <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>        <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-type">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br>缓冲流复制时间:<span class="hljs-number">8016</span> 毫秒<br></code></pre></div></td></tr></table></figure><p>如何更快呢？</p><p>使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>      <span class="hljs-comment">// 记录开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-keyword">try</span> (<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdk9.exe&quot;</span>));<br> <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;copy.exe&quot;</span>));<br>        )&#123;<br>          <span class="hljs-comment">// 读写数据</span><br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>*<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((len = bis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(bytes, <span class="hljs-number">0</span> , len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><span class="hljs-comment">// 记录结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br>&#125;<br>缓冲流使用数组复制时间:<span class="hljs-number">666</span> 毫秒<br></code></pre></div></td></tr></table></figure><h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建字符缓冲输入流</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;br.txt&quot;</span>));<br><span class="hljs-comment">// 创建字符缓冲输出流</span><br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;bw.txt&quot;</span>));<br></code></pre></div></td></tr></table></figure><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li></ul><p><code>readLine</code>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-comment">// 创建流对象</span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;in.txt&quot;</span>));<br><span class="hljs-comment">// 定义字符串,保存读取的一行文字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span>  <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-comment">// 循环读取,读取到最后返回null</span><br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-literal">null</span>) &#123;<br>            System.out.print(line);<br>            System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        &#125;<br><span class="hljs-comment">// 释放资源</span><br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>newLine</code>方法演示，代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterDemo</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException  &#123;<br>      <span class="hljs-comment">// 创建流对象</span><br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>      <span class="hljs-comment">// 写出数据</span><br>        bw.write(<span class="hljs-string">&quot;黑马&quot;</span>);<br>      <span class="hljs-comment">// 写出换行</span><br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;程序&quot;</span>);<br>        bw.newLine();<br>        bw.write(<span class="hljs-string">&quot;员&quot;</span>);<br>        bw.newLine();<br><span class="hljs-comment">// 释放资源</span><br>        bw.close();<br>    &#125;<br>&#125;<br>输出效果:<br>黑马<br>程序<br>员<br></code></pre></div></td></tr></table></figure><h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。<br>8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>9.今当远离，临表涕零，不知所言。<br>6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br></code></pre></div></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;      <br>        <span class="hljs-comment">// 创建map集合,保存文本数据,键为序号,值为文字       </span><br>        HashMap&lt;String, String&gt; lineMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        <span class="hljs-comment">// 创建流对象   </span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;in.txt&quot;</span>));     <br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;out.txt&quot;</span>));  <br>        <span class="hljs-comment">// 读取数据      </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span>  <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;       <br>        <span class="hljs-keyword">while</span> ((line = br.readLine())!=<span class="hljs-literal">null</span>) &#123;       <br>            <span class="hljs-comment">// 解析文本           </span><br>            String[] split = line.split(<span class="hljs-string">&quot;\\.&quot;</span>);            <span class="hljs-comment">// 保存到集合    </span><br>            lineMap.put(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);        <br>        &#125;        <br>        <span class="hljs-comment">// 释放资源       </span><br>        br.close();        <br>        <span class="hljs-comment">// 遍历map集合       </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= lineMap.size(); i++) &#123;          <br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(i);            <span class="hljs-comment">// 获取map中文本          </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> lineMap.get(key);          <span class="hljs-comment">// 写出拼接文本   </span><br>               bw.write(key+<span class="hljs-string">&quot;.&quot;</span>+value);          <span class="hljs-comment">// 写出换行            </span><br>                bw.newLine();       <br>        &#125;<span class="hljs-comment">// 释放资源    </span><br>        bw.close();   <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第二章-转换流"><a href="#第二章-转换流" class="headerlink" title="第二章 转换流"></a>第二章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload\JAVA黑马课\02-Java语进阶\day10_缓冲流、转换流、序列化流、Files\课件资料\课件资料\img\1_charset.jpg"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;E:\\File_GBK.txt&quot;</span>);     <br>        <span class="hljs-type">int</span> read;     <br>        <span class="hljs-keyword">while</span> ((read = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;       <br>            System.out.print((<span class="hljs-type">char</span>)read);       <br>        &#125;        <br>        fileReader.close();   <br>    &#125;<br>&#125;输出结果：���<br></code></pre></div></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;in.txt&quot;</span>));<br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;in.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderDemo2</span> &#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;   <br>        <span class="hljs-comment">// 定义文件路径,文件为gbk编码       </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">FileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\file_gbk.txt&quot;</span>;     <br>        <span class="hljs-comment">// 创建流对象,默认UTF8编码      </span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FileName));      <span class="hljs-comment">// 创建流对象,指定GBK编码       </span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FileName) , <span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-comment">// 定义变量,保存字符      </span><br>        <span class="hljs-type">int</span> read;     <br>        <span class="hljs-comment">// 使用默认编码字符流读取,乱码       </span><br>        <span class="hljs-keyword">while</span> ((read = isr.read()) != -<span class="hljs-number">1</span>) &#123;           <br>            System.out.print((<span class="hljs-type">char</span>)read);<br>                                           <span class="hljs-comment">// ��Һ�     </span><br>        &#125;       <br>           isr.close();           <br>        <span class="hljs-comment">// 使用指定编码字符流读取,正常解析   </span><br>        <span class="hljs-keyword">while</span> ((read = isr2.read()) != -<span class="hljs-number">1</span>) &#123;       <br>            System.out.print((<span class="hljs-type">char</span>)read);<span class="hljs-comment">// 大家好    </span><br>        &#125;        <br>        isr2.close();   <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>));<span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">isr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>) , <span class="hljs-string">&quot;GBK&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputDemo</span> &#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;   <br>        <span class="hljs-comment">// 定义文件路径      </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">FileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\out.txt&quot;</span>;      <span class="hljs-comment">// 创建流对象,默认UTF8编码    </span><br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(FileName));        <span class="hljs-comment">// 写出数据      </span><br>        osw.write(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 保存为6个字节      </span><br>        osw.close();      <span class="hljs-comment">// 定义文件路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">FileName2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E:\\out2.txt&quot;</span>;     <span class="hljs-comment">// 创建流对象,指定GBK编码      </span><br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(FileName2),<span class="hljs-string">&quot;GBK&quot;</span>);    <br>        <span class="hljs-comment">// 写出数据      </span><br>        osw2.write(<span class="hljs-string">&quot;你好&quot;</span>);<span class="hljs-comment">// 保存为4个字节      </span><br>        osw2.close();    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload\JAVA黑马课\02-Java语进阶\day10_缓冲流、转换流、序列化流、Files\课件资料\课件资料\img\2_zhuanhuan.jpg"></p><h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransDemo</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;      <br>    <span class="hljs-comment">// 1.定义文件路径     </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file_gbk.txt&quot;</span>;    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file_utf8.txt&quot;</span>;<span class="hljs-comment">// 2.创建流对象   </span><br>    <span class="hljs-comment">// 2.1 转换输入流,指定GBK编码      </span><br>    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile) , <span class="hljs-string">&quot;GBK&quot;</span>);    <span class="hljs-comment">// 2.2 转换输出流,默认utf8编码     </span><br>    <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(destFile));<span class="hljs-comment">// 3.读写数据    // 3.1 定义数组       </span><br>    <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">// 3.2 定义长度      </span><br>    <span class="hljs-type">int</span> len;    <span class="hljs-comment">// 3.3 循环读取      </span><br>    <span class="hljs-keyword">while</span> ((len = isr.read(cbuf))!=-<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 循环写出       </span><br>        osw.write(cbuf,<span class="hljs-number">0</span>,len);        &#125;    <br>    <span class="hljs-comment">// 4.释放资源       </span><br>    osw.close();       <br>    isr.close();  <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-序列化"><a href="#第三章-序列化" class="headerlink" title="第三章 序列化"></a>第三章 序列化</h1><h2 id="3-1-概述-1"><a href="#3-1-概述-1" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload\JAVA黑马课\02-Java语进阶\day10_缓冲流、转换流、序列化流、Files\课件资料\课件资料\img\3_xuliehua.jpg"></p><h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;employee.txt&quot;</span>);<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOut);<br></code></pre></div></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;  <br>    <span class="hljs-keyword">public</span> String name;    <br>    <span class="hljs-keyword">public</span> String address;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">// transient瞬态修饰成员,不会被序列化  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addressCheck</span><span class="hljs-params">()</span> &#123;      <br>        System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);   <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializeDemo</span>&#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>   &#123;    <br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();    <br>        e.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;    <br>        e.address = <span class="hljs-string">&quot;beiqinglu&quot;</span>;    <br>        e.age = <span class="hljs-number">20</span>;     <br>        <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 创建序列化流对象        </span><br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;employee.txt&quot;</span>));        <br>            <span class="hljs-comment">// 写出对象        </span><br>            out.writeObject(e);        <span class="hljs-comment">// 释放资源     </span><br>            out.close();        <br>            System.out.println(<span class="hljs-string">&quot;Serialized data is saved&quot;</span>); <span class="hljs-comment">// 姓名，地址被序列化，年龄没有被序列化。        </span><br>        &#125; <span class="hljs-keyword">catch</span>(IOException i)   &#123;    <br>            i.printStackTrace();      <br>        &#125;   <br>    &#125;<br>&#125;输出结果：Serialized data is saved<br></code></pre></div></td></tr></table></figure><h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeserializeDemo</span> &#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>   &#123;  <br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;       <br>        <span class="hljs-keyword">try</span> &#123;          <br>            <span class="hljs-comment">// 创建反序列化流           </span><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;employee.txt&quot;</span>);    <br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileIn);         <br>            <span class="hljs-comment">// 读取一个对象         </span><br>            e = (Employee) in.readObject();        <br>            <span class="hljs-comment">// 释放资源            </span><br>            in.close();            <br>            fileIn.close();     <br>        &#125;<span class="hljs-keyword">catch</span>(IOException i) &#123;  <br>            <span class="hljs-comment">// 捕获其他异常         </span><br>            i.printStackTrace();           <br>            <span class="hljs-keyword">return</span>;     <br>        &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException c)  &#123; <br>            <span class="hljs-comment">// 捕获类找不到异常          </span><br>            System.out.println(<span class="hljs-string">&quot;Employee class not found&quot;</span>);   <br>            c.printStackTrace();          <br>            <span class="hljs-keyword">return</span>;      <br>        &#125;        <span class="hljs-comment">// 无异常,直接打印输出        </span><br>        System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + e.name);<span class="hljs-comment">// zhangsan  </span><br>        System.out.println(<span class="hljs-string">&quot;Address: &quot;</span> + e.address); <span class="hljs-comment">// beiqinglu    </span><br>        System.out.println(<span class="hljs-string">&quot;age: &quot;</span> + e.age); <span class="hljs-comment">// 0   </span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法</li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;    <br>    <span class="hljs-comment">// 加入序列版本号  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;   <br>    <span class="hljs-keyword">public</span> String name;    <br>    <span class="hljs-keyword">public</span> String address;     <span class="hljs-comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.   </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> eid;      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addressCheck</span><span class="hljs-params">()</span> &#123;   <br>        System.out.println(<span class="hljs-string">&quot;Address  check : &quot;</span> + name + <span class="hljs-string">&quot; -- &quot;</span> + address);  <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h3 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerTest</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 创建 学生对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;老王&quot;</span>, <span class="hljs-string">&quot;laow&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;老张&quot;</span>, <span class="hljs-string">&quot;laoz&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;老李&quot;</span>, <span class="hljs-string">&quot;laol&quot;</span>);<br>    ArrayList&lt;Student&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    arrayList.add(student);<br>    arrayList.add(student2);<br>    arrayList.add(student3);<br>    <span class="hljs-comment">// 序列化操作</span><br>    <span class="hljs-comment">// serializ(arrayList);</span><br>    <span class="hljs-comment">// 反序列化  </span><br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;list.txt&quot;</span>));<span class="hljs-comment">// 读取对象,强转为ArrayList类型</span><br>    ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++ )&#123;     <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);        <br>        System.out.println(s.getName()+<span class="hljs-string">&quot;--&quot;</span>+ s.getPwd());      <br>    &#125;<br>&#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializ</span><span class="hljs-params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>          <span class="hljs-comment">// 创建 序列化流 </span><br>          <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;list.txt&quot;</span>));<br>          <span class="hljs-comment">// 写出对象</span><br>          oos.writeObject(arrayList);<span class="hljs-comment">// 释放资源</span><br>          oos.close();<br>      &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure><h1 id="第四章-打印流"><a href="#第四章-打印流" class="headerlink" title="第四章 打印流"></a>第四章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-12"><a href="#构造方法-12" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;ps.txt&quot;</span>)；<br></code></pre></div></td></tr></table></figure><h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintDemo</span> &#123;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 调用系统的打印流,控制台直接输出97      </span><br>        System.out.println(<span class="hljs-number">97</span>);      <span class="hljs-comment">// 创建打印流,指定文件的名称 </span><br>        <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;ps.txt&quot;</span>);            <span class="hljs-comment">// 设置系统的打印流流向,输出到ps.txt      </span><br>        System.setOut(ps);      <span class="hljs-comment">// 调用系统的打印流,ps.txt中输出97        </span><br>        System.out.println(<span class="hljs-number">97</span>);   <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="day11【网络编程】"><a href="#day11【网络编程】" class="headerlink" title="day11【网络编程】"></a>day11【网络编程】</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>软件架构CS／BS</li><li>网络通信三要素</li><li>TCP通信</li><li>Socket套接字</li><li>ServerSocket</li></ul><h2 id="教学目标-1"><a href="#教学目标-1" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li><input disabled type="checkbox"> 能够辨别UDP和TCP协议特点</li><li><input disabled type="checkbox"> 能够说出TCP协议下两个常用类名称</li><li><input disabled type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li><li><input disabled type="checkbox"> 能够理解TCP协议下文件上传案例</li><li><input disabled type="checkbox"> 能够理解TCP协议下案例2</li></ul><h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul><li><strong>C&#x2F;S结构</strong> ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/1_cs.jpg"></p><p><strong>B&#x2F;S结构</strong> ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/2_bs.jpg"></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul><li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p></li><li><p><strong>TCP&#x2F;IP协议：</strong> 传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p></li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/3_tcp_ip.jpg"></p><p>上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/UDP通信图解.bmp" alt="UDP通信图解"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/4_tcp.jpg"></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ipconfig<br></code></pre></div></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ping 空格 IP地址<br>ping <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br></code></pre></div></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述-1"><a href="#2-1-概述-1" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h3 id="构造方法-13"><a href="#构造方法-13" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></div></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流。</li></ul><h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h3 id="构造方法-14"><a href="#构造方法-14" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6666</span>);<br></code></pre></div></td></tr></table></figure><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。</li></ul><h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/5_简单通信.jpg"></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerTCP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>        <span class="hljs-comment">//5.关闭资源.</span><br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientTCP</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.获取流对象 . 输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br><span class="hljs-comment">// 4. 关闭资源 .</span><br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerTCP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动 , 等待连接 .... &quot;</span>);<br>        <span class="hljs-comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6666</span>);<br>        <span class="hljs-comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> ss.accept();<br>        <span class="hljs-comment">// 3.通过socket 获取输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> server.getInputStream();<br>        <span class="hljs-comment">// 4.一次性读取数据</span><br>      <span class="hljs-comment">// 4.1 创建字节数组</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-comment">// 4.2 据读取到字节数组中.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> is.read(b)；<br>        <span class="hljs-comment">// 4.3 解析数组,打印字符串信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, len);<br>        System.out.println(msg);<br>      <span class="hljs-comment">// =================回写数据=======================</span><br>      <span class="hljs-comment">// 5. 通过 socket 获取输出流</span><br>       <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> server.getOutputStream();<br>      <span class="hljs-comment">// 6. 回写数据</span><br>       out.write(<span class="hljs-string">&quot;我很好,谢谢你&quot;</span>.getBytes());<br>      <span class="hljs-comment">// 7.关闭资源.</span><br>      out.close();<br>        is.close();<br>        server.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientTCP</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;客户端 发送数据&quot;</span>);<br><span class="hljs-comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>);<br><span class="hljs-comment">// 2.通过Scoket,获取输出流对象 </span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> client.getOutputStream();<br><span class="hljs-comment">// 3.写出数据.</span><br>os.write(<span class="hljs-string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());<br>      <span class="hljs-comment">// ==============解析回写=========================</span><br>      <span class="hljs-comment">// 4. 通过Scoket,获取 输入流对象</span><br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> client.getInputStream();<br>      <span class="hljs-comment">// 5. 读取数据数据</span><br>      <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">100</span>];<br>      <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> in.read(b);<br>      System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, len));<br><span class="hljs-comment">// 6. 关闭资源 .</span><br>      in.close();<br>os.close();<br>client.close();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-综合案例-1"><a href="#第三章-综合案例-1" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/6_upload.jpg">    </p><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUpload_Server</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);        <span class="hljs-comment">// 1. 创建服务端ServerSocket      ServerSocket serverSocket = new ServerSocket(6666);  // 2. 建立连接         Socket accept = serverSocket.accept();      // 3. 创建流对象      // 3.1 获取输入流,读取文件数据        BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());        // 3.2 创建输出流,保存到本地 .        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.jpg&quot;));// 4. 读写数据        byte[] b = new byte[1024 * 8];        int len;        while ((len = bis.read(b)) != -1) &#123;            bos.write(b, 0, len);        &#125;        //5. 关闭 资源        bos.close();        bis.close();        accept.close();        System.out.println(&quot;文件上传已保存&quot;);    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUPload_Client</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-comment">// 1.创建流对象        // 1.1 创建输入流,读取本地文件          BufferedInputStream bis  = new BufferedInputStream(new FileInputStream(&quot;test.jpg&quot;));        // 1.2 创建输出流,写到服务端         Socket socket = new Socket(&quot;localhost&quot;, 6666);        BufferedOutputStream   bos   = new BufferedOutputStream(socket.getOutputStream());        //2.写出数据.         byte[] b  = new byte[1024 * 8 ];        int len ;         while (( len  = bis.read(b))!=-1) &#123;            bos.write(b, 0, len);            bos.flush();        &#125;        System.out.println(&quot;文件发送完毕&quot;);        // 3.释放资源        bos.close();         socket.close();        bis.close();         System.out.println(&quot;文件上传完毕 &quot;);&#125;&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(System.currentTimeMillis()+<span class="hljs-string">&quot;.jpg&quot;</span>) <span class="hljs-comment">// 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis);</span><br></code></pre></div></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每次接收新的连接,创建一个Socketwhile（true）&#123;    Socket accept = serverSocket.accept();    ......&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-literal">true</span>）&#123;    <span class="hljs-type">Socket</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> serverSocket.accept();    <span class="hljs-comment">// accept 交给子线程处理.    new Thread(() -&gt; &#123;      ......        InputStream bis = accept.getInputStream();      ......    &#125;).start();&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUpload_Server</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);        <span class="hljs-comment">// 1. 创建服务端ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);      // 2. 循环接收,建立连接        while (true) &#123;            Socket accept = serverSocket.accept();          /*           3. socket对象交给子线程处理,进行读写操作               Runnable接口中,只有一个run方法,使用lambda表达式简化格式            */            new Thread(() -&gt; &#123;                try (                    //3.1 获取输入流对象                    BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());                    //3.2 创建输出流对象, 保存到本地 .                    FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + &quot;.jpg&quot;);                    BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123;                    // 3.3 读写数据                    byte[] b = new byte[1024 * 8];                    int len;                    while ((len = bis.read(b)) != -1) &#123;                      bos.write(b, 0, len);                    &#125;                    //4. 关闭 资源                    bos.close();                    bis.close();                    accept.close();                    System.out.println(&quot;文件上传已保存&quot;);                &#125; catch (IOException e) &#123;                  e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/6_upload2.jpg"></p><h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUpload_Server</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        System.out.println(<span class="hljs-string">&quot;服务器 启动.....  &quot;</span>);        <span class="hljs-comment">// 1. 创建服务端ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);        // 2. 循环接收,建立连接        while (true) &#123;            Socket accept = serverSocket.accept();          /*          3. socket对象交给子线程处理,进行读写操作               Runnable接口中,只有一个run方法,使用lambda表达式简化格式            */            new Thread(() -&gt; &#123;                try (                    //3.1 获取输入流对象                    BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());                    //3.2 创建输出流对象, 保存到本地 .                    FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + &quot;.jpg&quot;);                    BufferedOutputStream bos = new BufferedOutputStream(fis);                ) &#123;                    // 3.3 读写数据                    byte[] b = new byte[1024 * 8];                    int len;                    while ((len = bis.read(b)) != -1) &#123;                        bos.write(b, 0, len);                    &#125;                    // 4.=======信息回写===========================                    System.out.println(&quot;back ........&quot;);                    OutputStream out = accept.getOutputStream();                    out.write(&quot;上传成功&quot;.getBytes());                    out.close();                    //================================                    //5. 关闭 资源                    bos.close();                    bis.close();                    accept.close();                    System.out.println(&quot;文件上传已保存&quot;);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUpload_Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-comment">// 1.创建流对象        // 1.1 创建输入流,读取本地文件        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;test.jpg&quot;));        // 1.2 创建输出流,写到服务端        Socket socket = new Socket(&quot;localhost&quot;, 6666);        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());        //2.写出数据.        byte[] b  = new byte[1024 * 8 ];        int len ;        while (( len  = bis.read(b))!=-1) &#123;            bos.write(b, 0, len);        &#125;      // 关闭输出流,通知服务端,写出数据完毕        socket.shutdownOutput();        System.out.println(&quot;文件发送完毕&quot;);        // 3. =====解析回写============        InputStream in = socket.getInputStream();        byte[] back = new byte[20];        in.read(back);        System.out.println(new String(back));        in.close();        // ============================        // 4.释放资源        socket.close();        bis.close();    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h3 id="案例分析-3"><a href="#案例分析-3" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/复制.png"></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8000</span>);    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();       <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> in.read(bytes);    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes,<span class="hljs-number">0</span>,len));    socket.close();    server.close();&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/无法访问.jpg"></p></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/读取访问信息.jpg"></p></li></ol><p>GET&#x2F;web&#x2F;index.html HTTP&#x2F;1.1是浏览器的请求消息。&#x2F;web&#x2F;index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(&quot; &quot;);//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path);</span><br></code></pre></div></td></tr></table></figure><h3 id="案例实现-4"><a href="#案例实现-4" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        System.out.println(<span class="hljs-string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);        <span class="hljs-comment">// 创建ServerSocket 对象        ServerSocket server = new ServerSocket(8888);        Socket socket = server.accept();        // 转换流读取浏览器的请求消息        BufferedReader readWb = new        BufferedReader(new InputStreamReader(socket.getInputStream()));        String requst = readWb.readLine();        // 取出请求资源的路径        String[] strArr = requst.split(&quot; &quot;);        // 去掉web前面的/        String path = strArr[1].substring(1);        // 读取客户端请求的资源文件        FileInputStream fis = new FileInputStream(path);        byte[] bytes= new byte[1024];        int len = 0 ;        // 字节输出流,将文件写会客户端        OutputStream out = socket.getOutputStream();        // 写入HTTP协议响应头,固定写法        out.write(&quot;HTTP/1.1 200 OK\r\n&quot;.getBytes());        out.write(&quot;Content-Type:text/html\r\n&quot;.getBytes());        // 必须要写入空行,否则浏览器不解析        out.write(&quot;\r\n&quot;.getBytes());        while((len = fis.read(bytes))!=-1)&#123;            out.write(bytes,0,len);        &#125;        fis.close();        out.close();        readWb.close();        socket.close();        server.close();    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul><li><strong>火狐</strong></li></ul><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/效果图1.png"></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Web</span>(socket)).start();        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Web</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;        <span class="hljs-keyword">private</span> Socket socket;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Web</span><span class="hljs-params">(Socket socket)</span>&#123;            <span class="hljs-built_in">this</span>.socket=socket;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">try</span>&#123;                <span class="hljs-comment">//转换流,读取浏览器请求第一行                BufferedReader readWb = new                        BufferedReader(new InputStreamReader(socket.getInputStream()));                String requst = readWb.readLine();                //取出请求资源的路径                String[] strArr = requst.split(&quot; &quot;);                System.out.println(Arrays.toString(strArr));                String path = strArr[1].substring(1);                System.out.println(path);                FileInputStream fis = new FileInputStream(path);                System.out.println(fis);                byte[] bytes= new byte[1024];                int len = 0 ;                //向浏览器 回写数据                OutputStream out = socket.getOutputStream();                out.write(&quot;HTTP/1.1 200 OK\r\n&quot;.getBytes());                out.write(&quot;Content-Type:text/html\r\n&quot;.getBytes());                out.write(&quot;\r\n&quot;.getBytes());                while((len = fis.read(bytes))!=-1)&#123;                    out.write(bytes,0,len);                &#125;                fis.close();                out.close();                readWb.close();                socket.close();            &#125;catch(Exception ex)&#123;            &#125;        &#125;    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><p><strong>访问效果：</strong></p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/BaiduNetdiskDownload/JAVA黑马课/02-Java语进阶/day11_网络编程/课件资料/img/效果图2.png">图解：</p><p><img src="/2022/04/28/Java%E5%9F%BA%E7%A1%80/img%5CBS%E9%80%9A%E4%BF%A1.bmp"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2022/04/27/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/27/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p> Redis是一个开源的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。并且在此基础上实现了master-slave(主从)同步。</p><h3 id="1、Redis快速安装"><a href="#1、Redis快速安装" class="headerlink" title="1、Redis快速安装"></a>1、Redis快速安装</h3><p>1、要安装gcc， 安装wget     进入到 &#x2F;usr&#x2F;local&#x2F;src&#x2F;    下载压缩包 </p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 安装gcc  wget </span><br><span class="hljs-string">yum</span> <span class="hljs-string">-y</span> <span class="hljs-string">install</span> <span class="hljs-string">gcc</span> <span class="hljs-string">wget</span><br><span class="hljs-comment"># 进入到 /usr/local/src/目录</span><br><span class="hljs-string">cd</span> <span class="hljs-string">/usr/local/src/</span><br><span class="hljs-comment">#下载压缩包</span><br><span class="hljs-string">wget</span> <span class="hljs-string">http://download.redis.io/releases/redis-6.2.6.tar.gz</span><br></code></pre></div></td></tr></table></figure><p>2、解压缩</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#解压缩</span><br><span class="hljs-string">tar</span> <span class="hljs-string">zxvf</span> <span class="hljs-string">redis-6.2.6.tar.gz</span><br><span class="hljs-comment">#安装</span><br><span class="hljs-string">make</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">make</span> <span class="hljs-string">install</span><br></code></pre></div></td></tr></table></figure><p>3、后台启动运行，按需求设置</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#进入 解压后的 redis-6.2.6 ，修改配置文件 redis.conf</span><br><span class="hljs-string">bind</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>     <span class="hljs-comment"># 或者直接注释，允许所有访问</span><br><span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span> <span class="hljs-comment"># 后台运行</span><br><span class="hljs-string">requirepass</span> <span class="hljs-string">baixxq</span> <span class="hljs-comment"># 密码</span><br></code></pre></div></td></tr></table></figure><p>4、开启自启动，按需求设置</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">vi</span> <span class="hljs-string">/etc/systemd/system/redis.service</span><br></code></pre></div></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">[<span class="hljs-string">Unit</span>]<br><span class="hljs-string">Description=redis</span> <span class="hljs-bullet">-</span> <span class="hljs-string">server</span><br><span class="hljs-string">After=network.target</span><br><br>[<span class="hljs-string">Service</span>]<br><span class="hljs-string">Type=forking</span><br><span class="hljs-string">ExecStart=/usr/local/bin/redis-server</span> <span class="hljs-string">/usr/local/src/redis-6.2.6/redis.conf</span><br><span class="hljs-string">PrivateTmp=true</span><br><br>[<span class="hljs-string">Install</span>]<br><span class="hljs-string">WantedBy=multi-user.target</span><br></code></pre></div></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#重新载入</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">daemon-reload</span><br><span class="hljs-comment">#启动Redis</span><br><span class="hljs-string">redis-server</span> <span class="hljs-string">/usr/local/src/redis-6.2.6/redis.conf</span><br><span class="hljs-comment">#设置开启启动</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">redis</span><br></code></pre></div></td></tr></table></figure><p>5、注意开放防火墙端口</p><p>开放端口 6379</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#放行端口</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-string">--zone=public</span> <span class="hljs-string">--add-port=6379/tcp</span> <span class="hljs-string">--permanent</span><br><span class="hljs-comment">#重启防火墙，注意改完其他的要重启一下才能生效</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-string">--reload</span><br></code></pre></div></td></tr></table></figure><p>6、持久化配置</p><p>RDB持久化</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#当 900 秒内有至少有 1 个键被改动时，自动进行数据集保存操作</span><br><span class="hljs-string">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-comment">#当 300 秒内有至少有 10 个键被改动时，自动进行数据集保存操作</span><br><span class="hljs-string">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-comment">#当 60 秒内有至少有 10000 个键被改动时，自动进行数据集保存操作</span><br><span class="hljs-string">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br>    <br><span class="hljs-comment">#RDB持久化文件名</span><br><span class="hljs-string">dbfilename</span> <span class="hljs-string">dump-&lt;port&gt;.rdb</span><br><span class="hljs-comment">#数据持久化文件存储目录</span><br><span class="hljs-string">dir</span> <span class="hljs-string">/var/lib/redis</span><br><span class="hljs-comment">#bgsave发生错误时是否停止写入，通常为yes</span><br><span class="hljs-string">stop-writes-on-bgsave-error</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment">#rdb文件是否使用压缩格式</span><br><span class="hljs-string">rdbcompression</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment">#是否对rdb文件进行校验和检验，通常为yes</span><br><span class="hljs-string">rdbchecksum</span> <span class="hljs-literal">yes</span><br></code></pre></div></td></tr></table></figure><p>AOF持久化</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#开启AOF持久化方式</span><br><span class="hljs-string">appendonly</span> <span class="hljs-literal">yes</span><br>    <br><span class="hljs-comment">#AOF持久化文件名</span><br><span class="hljs-string">appendfilename</span> <span class="hljs-string">appendonly-&lt;port&gt;.aof</span><br>    <br><span class="hljs-comment">#每秒把缓冲区的数据同步到磁盘always， everysec，no</span><br><span class="hljs-string">appendfsync</span> <span class="hljs-string">everysec</span><br><br><span class="hljs-comment">#数据持久化文件存储目录</span><br><span class="hljs-string">dir</span> <span class="hljs-string">/var/lib/redis</span><br><br><span class="hljs-comment">#Redis 2.2 需要自己手动执行 bgrewriteaof 命令； Redis 2.4 则可以通过配置自动触发 AOF 重写。</span><br><span class="hljs-comment">#是否在执行重写时不同步数据到AOF文件</span><br><span class="hljs-literal">no</span><span class="hljs-string">-appendfsync-on-rewrite</span> <span class="hljs-literal">no</span><br>    <br><span class="hljs-comment">#触发AOF文件执行重写的最小尺寸</span><br><span class="hljs-string">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span><br>    <br><span class="hljs-comment">#触发AOF文件执行重写的增长率</span><br><span class="hljs-string">auto-aof-rewrite-percentage</span> <span class="hljs-number">100</span><br>    <br><span class="hljs-comment">#请注意，如果在中间发现AOF文件已损坏，则服务器仍将退出并出现错误。 仅当Redis尝试从AOF文件读取更多数据但找不到足够的字节时，此选项才适用。</span><br><span class="hljs-string">aof-load-truncated</span> <span class="hljs-literal">yes</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题</title>
    <link href="/2022/04/27/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/04/27/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p><code>Stack</code>类表示后进先出（LIFO）对象堆栈</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stack&lt;Integer&gt;  stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;()<br></code></pre></div></td></tr></table></figure><p><a href="https://www.apiref.com/java11-zh/java.base/java/util/Deque.html"><code>Deque</code></a>接口及其实现提供了更完整和一致的LIFO堆栈操作集，应优先使用此类。 例如：</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">Deque&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> ArrayDeque&lt;<span class="hljs-built_in">Integer</span>&gt;(); <br></code></pre></div></td></tr></table></figure><p>方法</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">E<span class="hljs-built_in">peek</span>()<br>查看此堆栈顶部的对象，而不将其从堆栈中删除。<br>E<span class="hljs-built_in">pop</span>()<br>移除此堆栈顶部的对象，并将该对象作为此函数的值返回。<br>Epush (E item)<br>将项目推到此堆栈的顶部。<br><span class="hljs-built_in">isEmpty</span>()<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.pop</span>()<span class="hljs-selector-class">.equals</span>(b)比较最好用<br></code></pre></div></td></tr></table></figure><p>方法</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">E<span class="hljs-built_in">peekFirst</span>()<br>检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回 null 。<br>E<span class="hljs-built_in">peekLast</span>()<br>检索但不删除此双端队列的最后一个元素，如果此双端队列为空，则返回 null 。<br>voidaddFirst​(E e)<br>如果可以在不违反容量限制的情况下立即插入指定元素，则在此双端队列的前面插入指定元素，如果当前没有可用空间，则抛出IllegalStateException <br>voidaddLast​(E e)<br>如果可以在不违反容量限制的情况下立即插入指定元素，则在此双端队列的末尾插入指定元素，如果当前没有可用空间，则抛出IllegalStateException<br>E<span class="hljs-built_in">peekFirst</span>()<br>检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回 null 。<br>E<span class="hljs-built_in">peekLast</span>()<br>检索但不删除此双端队列的最后一个元素，如果此双端队列为空，则返回 null 。<br>E<span class="hljs-built_in">removeFirst</span>()<br>检索并删除此双端队列的第一个元素。<br>E<span class="hljs-built_in">removeLast</span>()<br>检索并删除此双端队列的最后一个元素。<br>int<span class="hljs-built_in">size</span>()<br>返回此双端队列中的元素数。<br></code></pre></div></td></tr></table></figure><h1 id="一、数据结构和算法-剑指Offer"><a href="#一、数据结构和算法-剑指Offer" class="headerlink" title="一、数据结构和算法-剑指Offer"></a>一、数据结构和算法-剑指Offer</h1><h2 id="1-栈与队列"><a href="#1-栈与队列" class="headerlink" title="1.栈与队列"></a>1.栈与队列</h2><p>&#x3D;&#x3D;有优先考虑，双栈，队列&#x3D;&#x3D;</p><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>]<br><br>输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[<span class="hljs-literal">null</span>,-<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>利用栈的先入后出的性质，通过两个栈的相互转移颠倒，实现数据的插入和删除功能。</strong></p><p>​时间复杂度：O(1)</p><p>​空间复杂度：O(N)</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.定义两个栈<br><span class="hljs-attribute">2</span>.第一个栈用来存数据，第二个栈用来存放第一个栈的数据，此时，两个栈的栈顶分别是队列头部和队列尾部。<br><span class="hljs-attribute">3</span>.判断栈<span class="hljs-number">2</span>是否空，空则判断栈<span class="hljs-number">1</span>，栈<span class="hljs-number">1</span>空返回-<span class="hljs-number">1</span>，不空将栈<span class="hljs-number">1</span>放入栈<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span>&#123;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack1;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack2;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span>&#123;<br>stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>stack1.push(value);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(!stack2.isEmpty())&#123;<br><span class="hljs-keyword">return</span> stack2.pop();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;<br>stack2.push(stack1.pop());<br>&#125;<br><span class="hljs-keyword">return</span> stack2.isEmpty() ? -<span class="hljs-number">1</span> : stack2.pop();<br>&#125;<br>&#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>minStack.push(-<span class="hljs-number">2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(-<span class="hljs-number">3</span>);<br>minStack.min();   --&gt; 返回 -<span class="hljs-number">3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.min();   --&gt; 返回 -<span class="hljs-number">2.</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>利用辅助栈、即双栈，栈1存储数据，栈2严格遵守最小值规则。</strong></p><p>​时间复杂度：O(1)</p><p>​空间复杂度：O(N)</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack1;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    stack1.push(x);<br>    <span class="hljs-keyword">if</span>(stack2.empty()||stack2.peek()&gt;=x)&#123;<br>    stack2.push(x);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span>(stack1.pop().equals(stack2.peek()))&#123;<br>    stack2.pop();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> stack1.peek();<br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> stack2.peek();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><p>&#x3D;&#x3D;考虑辅助栈，队列，递归&#x3D;&#x3D;</p><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用辅助栈，将链表的数据全部取出来放入栈中，利用栈的先入后出原则。</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p>​<strong>二、原地逆序数组遍历利</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p>​<strong>三、递归</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p>递归代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; tem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        recur(head);<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[tem.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;<br>            res[i] = tem.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        recur(head.next);<br>        tem.add(head.val);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用辅助栈，将链表的数据全部取出来放入栈中，利用栈的先入后出原则。</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p>​<strong>二、迭代</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(1)</p><p>​<strong>三、递归</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p>迭代代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head ,pure = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pure;<br>            pure = cur;<br>            cur = tmp;         <br>        &#125;<br>         <span class="hljs-keyword">return</span> pure;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br>输出：<span class="hljs-string">[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><br>输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br><br>输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br><br>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></div></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></p><p><strong>解题思路：</strong></p><p>​该题本质上就是链表的深拷贝</p><p>​<strong>一、利用回溯+哈希表。</strong></p><p>​时间复杂度：O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</p><p>​空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">其实就是建立一个哈希表，链表的键和值拷贝进去，然后分别读取链表的键，设置值的<span class="hljs-built_in">next</span>和radom指向，最总通过<span class="hljs-built_in">get</span>(head)获取哈希表存放链表的头<br></code></pre></div></td></tr></table></figure><p>​<strong>二、迭代+拆分</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(1)</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">把原链表和新链表组合在一起，分别通过.<span class="hljs-keyword">next</span>来访问，注意最后把原链表还原<br><span class="hljs-number">1.</span>先复制链表，柔和进去<br><span class="hljs-number">2.</span>设置<span class="hljs-built_in">random</span>链接<br><span class="hljs-number">3.</span>拆分<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/27/%E7%AE%97%E6%B3%95%E9%A2%98/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220221162314960.png" alt="image-20220221162314960"></p><p>方法一代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            map.put(cur,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val));<br>            cur = cur.next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            map.get(cur).next = map.get(cur.next);<br>            map.get(cur).random = map.get(cur.random);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val);<br>            temp.next = cur.next;<br>            cur.next = temp;<br>            cur = temp.next;<br>        &#125;<br>        <br>        cur = head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.random!=<span class="hljs-literal">null</span>)&#123;<br>               cur.next.random = cur.random; <br>            &#125;<br>            cur = cur.next.next;<br>        &#125;<br>        cur = head.next;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head , res = head.next;<br>        <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-literal">null</span>)&#123;<br>            pre.next = pre.next.next;<br>            cur.next = cur.next.next;<br>            pre = pre.next;<br>            cur = res.next;<br>        &#125;<br>        pre.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 单独处理原链表尾节点</span><br>        <span class="hljs-keyword">return</span> res;      <span class="hljs-comment">// 返回新链表头节点</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、数组拷贝。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(n)</p><p>方法一代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (Character c : s.toCharArray()) &#123;<br>              <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)builder.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>              <span class="hljs-keyword">else</span> builder.append(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出: <span class="hljs-string">&quot;cdefgab&quot;</span><br><br>输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lrloseumgh&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">6</span><br>输出: <span class="hljs-string">&quot;umghlrlose&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用String的切片函数。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(n)</p><p>​<strong>二、列表遍历拼接。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(n)</p><p>方法一代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s.substring(n)+s.substring(<span class="hljs-number">0</span>,n));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; s.length(); i++)<br>            res.append(s.charAt(i));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            res.append(s.charAt(i));<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-查找算法二分"><a href="#4-查找算法二分" class="headerlink" title="4.查找算法二分"></a>4.查找算法二分</h2><h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用Set集合。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(n)</p><p>​<strong>二、原地交换。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(1)</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">算法流程：<br>遍历数组 numsnums ，设索引初始值为 i = 0<br>1.若 nums<span class="hljs-comment">[i]</span> = i ： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>2.若 nums<span class="hljs-comment">[nums<span class="hljs-comment">[i]</span>]</span> = nums<span class="hljs-comment">[i]</span> ： 代表索引 nums<span class="hljs-comment">[i]</span>处和索引i处的元素值都为nums<span class="hljs-comment">[i]</span>,即找到一组重复值,返回此值 nums<span class="hljs-comment">[i]</span>;<br>否则： 交换索引为 i 和 nums<span class="hljs-comment">[i]</span> 的元素值，将此数字交换至对应索引位置。<br>若遍历完毕尚未返回，则返回 -1 。<br></code></pre></div></td></tr></table></figure><p>方法一代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!set.add(num))&#123;<br>                <span class="hljs-keyword">return</span> num;<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[tmp];<br>            nums[tmp] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>统计一个数字在排序数组中出现的次数。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br><br><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br><br>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109<br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用二分法。</strong></p><p>​时间复杂度：O(log(N))</p><p>​空间复杂度：O(1)</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.初始化： 左边界 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>，右边界 j = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-number">2</span>.循环二分： 当闭区间 <span class="hljs-selector-attr">[i, j]</span><span class="hljs-selector-attr">[i,j]</span> 无元素时跳出；<br><span class="hljs-number">1</span>.计算中点 m = (<span class="hljs-selector-tag">i</span> + j) / <span class="hljs-number">2</span>m=(i+j)/<span class="hljs-number">2</span> （向下取整）；<br><span class="hljs-number">2</span>.若 nums<span class="hljs-selector-attr">[m]</span> &lt; target，则 target在闭区间<span class="hljs-selector-attr">[m+1,j]</span> 中，因此执行 <span class="hljs-selector-tag">i</span> = m + <span class="hljs-number">1</span>；<br><span class="hljs-number">3</span>.若 nums<span class="hljs-selector-attr">[m]</span> &gt; target ，则 target在闭区间 <span class="hljs-selector-attr">[i,m−1]</span> 中，因此执行 j = m- <span class="hljs-number">1</span>；<br><span class="hljs-number">4</span>.若 nums<span class="hljs-selector-attr">[m]</span> = target,则右边界<span class="hljs-attribute">right</span>在闭区间[m+<span class="hljs-number">1</span>,j]中;左边界<span class="hljs-attribute">left</span>在闭区间[i,m−<span class="hljs-number">1</span>]中,因此分为以下两种情况<br><span class="hljs-number">1</span>.若查找 右边界<span class="hljs-attribute">right</span> ，则执行 i = m + <span class="hljs-number">1</span>；（跳出时 i 指向右边界）<br><span class="hljs-number">2</span>.若查找 左边界<span class="hljs-attribute">left</span> ，则执行 j = m - <span class="hljs-number">1</span>；（跳出时 j 指向左边界）<br><span class="hljs-number">3</span>.返回值： 应用两次二分，分别查找 <span class="hljs-attribute">right</span> 和 left ，最终返回 right - left - <span class="hljs-number">1</span> 即可。<br><br>查找完右边界后，可用 nums<span class="hljs-selector-attr">[j]</span> = j判断数组中是否包含 target，若不包含则直接提前返回 <span class="hljs-number">0</span> ，无需后续查找左边界。<br>查找完右边界后，左边界 <span class="hljs-attribute">left</span> 一定在闭区间 [<span class="hljs-number">0</span>, j] 中，因此直接从此区间开始二分查找即可。<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] &lt;= target) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 搜索左边界 right</span><br>        i = <span class="hljs-number">0</span>; j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] &lt; target) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: [0,1,3]</span><br><span class="hljs-section">输出: 2</span><br><br><span class="hljs-section">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="hljs-section">输出: 8</span><br><br>1 &lt;= 数组长度 &lt;= 10000<br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用二分法。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(1)</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.初始化： 左边界 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>，右边界j=<span class="hljs-built_in">len</span>(nums)−<span class="hljs-number">1</span> ；代表闭区间 <span class="hljs-selector-attr">[i, j]</span> <br><span class="hljs-number">2</span>.循环二分： 当 i≤j 时循环（即当闭区间 <span class="hljs-selector-attr">[i,j]</span> 为空时跳出）<br><span class="hljs-number">1</span>.计算中点 m = (<span class="hljs-selector-tag">i</span> + j) <span class="hljs-comment">// 2，其中 &quot;//&quot; 为向下取整除法；</span><br><span class="hljs-number">2</span>.若 nums<span class="hljs-selector-attr">[m]</span> = m，则 “右子数组的首位元素” 一定在闭区间 <span class="hljs-selector-attr">[m + 1, j]</span>中，因此执行i=m+<span class="hljs-number">1</span>,<br><span class="hljs-number">3</span>.若 nums<span class="hljs-selector-attr">[m]</span> ≠m ，则 “左子数组的末位元素” 一定在闭区间 <span class="hljs-selector-attr">[i, m - 1]</span>中，因此执行 j = m - <span class="hljs-number">1</span>；<br><span class="hljs-number">3</span>.返回值：跳出时，变量 <span class="hljs-selector-tag">i</span> 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 <span class="hljs-selector-tag">i</span> 即可。<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = len(nums) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i+j)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m]==m)i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-查找算法"><a href="#5-查找算法" class="headerlink" title="5.查找算法"></a>5.查找算法</h2><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">现有矩阵 matrix 如下：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [1,   4,  7, 11, 15]</span>,<br><span class="hljs-string">  [2,   5,  8, 12, 19]</span>,<br><span class="hljs-string">  [3,   6,  9, 16, 22]</span>,<br><span class="hljs-string">  [10, 13, 14, 17, 24]</span>,<br><span class="hljs-string">  [18, 21, 23, 26, 30]</span><br>]<br>给定 target = <span class="hljs-number">5</span>，返回 <span class="hljs-literal">true</span>。<br>给定 target = <span class="hljs-number">20</span>，返回 <span class="hljs-literal">false</span><br><br>限制：<br><span class="hljs-number">0</span> &lt;= n &lt;= <span class="hljs-number">1000</span><br><span class="hljs-number">0</span> &lt;= m &lt;= <span class="hljs-number">1000</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用二分法，可类似成二叉树，将矩阵旋转，。</strong></p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(1)</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">从矩阵 matrix 左下角元素（索引设为 (<span class="hljs-selector-tag">i</span>, j) ）开始遍历，并与目标值对比：<br>当 matrix<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> &gt; target 时，执行 i-- ，即消去第 <span class="hljs-selector-tag">i</span> 行元素；<br>当 matrix<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> &lt; target 时，执行 j++ ，即消去第 j 列元素；<br>当 matrix<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = target 时，返回 truetrue ，代表找到目标值。<br></code></pre></div></td></tr></table></figure><img src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" style="zoom:50%;"><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) i--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) j++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br><br>输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、利用二分法</strong></p><p>​时间复杂度：O(log(N))</p><p>​空间复杂度：O(1)</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">1.初始化，<span class="hljs-attribute">i</span>=0，j=numbers.length-1;<br>2.循环查找  m=(i+j)/2   i&lt;=m&lt;j<br>    1.如果munbers[m]&lt;number[j],则该数一定在左边，令<span class="hljs-attribute">j</span>=m;<br>2.如果munbers[m]&gt;number[j],则该数一定在右边，令<span class="hljs-attribute">i</span>=m+1;<br>3.如果munbers[m]=number[j],则该数不一定，<span class="hljs-attribute">j</span>=j-1;<br>3.返回值： 当 i = j 时跳出二分循环，并返回 旋转点的值 nums[i] 即可<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=numbers.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i!=j)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i+j)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(numbers[m]&lt;numbers[j])j=m;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[m]&gt;numbers[j])i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j=j-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>   <br>返回：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>           <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>           ans.add(node.val);<br><br>           <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>) queue.add(node.left);<br>           <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>) queue.add(node.right);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ans.size();i++)&#123;<br>            res[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="6-搜索与回溯算法（广度优先搜索）"><a href="#6-搜索与回溯算法（广度优先搜索）" class="headerlink" title="6.搜索与回溯算法（广度优先搜索）"></a>6.搜索与回溯算法（广度优先搜索）</h2><p>广度优先搜索算法（Breadth-First Search，缩写为 BFS），又称为宽度优先搜索，是一种图形搜索算法。简单的说，BFS 是从根结点开始，沿着树的宽度遍历树的结点。如果所有结点均被访问，则算法中止。</p><h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">例如:<br>给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>   <br>返回其层次遍历结果：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [3]</span>,<br><span class="hljs-string">  [9,20]</span>,<br><span class="hljs-string">  [15,7]</span><br>]<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">/**  **  **  **  **  **  ** 重要，判断空，并且为什么不判空返回**  **   **  **  *  */</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>           ArrayList&lt;Integer&gt; arry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size();i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>               arry.add(node.val);<br>               <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>) queue.add(node.left);<br>               <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>) queue.add(node.right);     <br>            &#125;<br>            ans.add(arry);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">例如:<br>给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>返回其层次遍历结果：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [3]</span>,<br><span class="hljs-string">  [20,9]</span>,<br><span class="hljs-string">  [15,7]</span><br>]<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>           LinkedList&lt;Integer&gt; arry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size();i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>               <span class="hljs-keyword">if</span>(ans.size() % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)arry.addLast(node.val);<br>               <span class="hljs-keyword">else</span> arry.addFirst(node.val);<br>               <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>) queue.add(node.left);<br>               <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>) queue.add(node.right);     <br>            &#125;<br>            ans.add(arry);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="7-搜索与回溯算法-深度优先搜索"><a href="#7-搜索与回溯算法-深度优先搜索" class="headerlink" title="7.搜索与回溯算法(深度优先搜索)"></a>7.搜索与回溯算法(深度优先搜索)</h2><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次.</p><h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">输入两棵二叉树<span class="hljs-selector-tag">A</span>和<span class="hljs-selector-tag">B</span>，判断<span class="hljs-selector-tag">B</span>是不是<span class="hljs-selector-tag">A</span>的子结构。(约定空树不是任意一个树的子结构)<br><span class="hljs-selector-tag">B</span>是<span class="hljs-selector-tag">A</span>的子结构， 即 <span class="hljs-selector-tag">A</span>中有出现和<span class="hljs-selector-tag">B</span>相同的结构和节点值。<br>例如:<br>给定的树 A:<br>     <span class="hljs-number">3</span><br>    / \<br>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>  / \<br> <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br>给定的树 B：<br>   <span class="hljs-number">4</span> <br>  /<br> <span class="hljs-number">1</span><br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。<br><br>示例 <span class="hljs-number">1</span>：<br>输入：A = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], B = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：false<br><br>示例 <span class="hljs-number">2</span>：<br>输入：A = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], B = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：true<br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、先序遍历 + 包含判断</strong></p><p>​时间复杂度：O(MN)</p><p>​空间复杂度：O(M)</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less">若树<span class="hljs-selector-tag">B</span>是树<span class="hljs-selector-tag">A</span>的子结构,则子结构的根节点可能为树<span class="hljs-selector-tag">A</span>的任意一个节点.因此,判断树<span class="hljs-selector-tag">B</span>是否是树<span class="hljs-selector-tag">A</span>的子结构,需完成以下两步工作:<br><span class="hljs-number">1</span>.先序遍历树 <span class="hljs-selector-tag">A</span> 中的每个节点 <span class="hljs-selector-tag">n</span>(a)  （对应函数 <span class="hljs-selector-tag">isSubStructure</span>(A, B)）<br><span class="hljs-number">2</span>.判断树 <span class="hljs-selector-tag">A</span> 中 以 <span class="hljs-selector-tag">n</span>(a) 为根节点的子树是否包含树 <span class="hljs-selector-tag">B</span>   （对应函数 <span class="hljs-selector-tag">recur</span>(A, B)）<br><br><span class="hljs-selector-tag">recur</span>(A, B) 函数：<br><span class="hljs-number">1</span>.终止条件：<br><span class="hljs-number">1</span>.当节点 <span class="hljs-selector-tag">B</span> 为空：说明树 <span class="hljs-selector-tag">B</span> 已匹配完成（越过叶子节点），因此返回 <span class="hljs-selector-tag">true</span> ；<br><span class="hljs-number">2</span>.当节点 <span class="hljs-selector-tag">A</span> 为空：说明已经越过树 <span class="hljs-selector-tag">A</span> 叶子节点，即匹配失败，返回 <span class="hljs-selector-tag">false</span> ；<br><span class="hljs-number">3</span>.当节点 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span> 的值不同：说明匹配失败，返回 <span class="hljs-selector-tag">false</span> ；<br><span class="hljs-number">2</span>.返回值：<br>判断 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span> 的左子节点是否相等，即 <span class="hljs-selector-tag">recur</span>(A.left, B.left) ；<br>判断 <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span> 的右子节点是否相等，即 <span class="hljs-selector-tag">recur</span>(A.right, B.right) ；<br><br><span class="hljs-selector-tag">isSubStructure</span>(A, B) 函数：<br>特例处理： 当树 <span class="hljs-selector-tag">A</span> 为空或树 <span class="hljs-selector-tag">B</span> 为空时，直接返回 <span class="hljs-selector-tag">false</span> ；<br>返回值： 若树 <span class="hljs-selector-tag">B</span> 是树 <span class="hljs-selector-tag">A</span> 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br><span class="hljs-number">1</span>.以节点 <span class="hljs-selector-tag">A</span> 为根节点的子树 包含树 <span class="hljs-selector-tag">B</span> ，对应 <span class="hljs-selector-tag">recur</span>(A, B)；<br><span class="hljs-number">2</span>.树 <span class="hljs-selector-tag">B</span> 是树 <span class="hljs-selector-tag">A</span> 左子树的子结构，对应 <span class="hljs-selector-tag">isSubStructure</span>(A.left, B)；<br><span class="hljs-number">3</span>.树 <span class="hljs-selector-tag">B</span> 是树 <span class="hljs-selector-tag">A</span> 右子树的子结构，对应 <span class="hljs-selector-tag">isSubStructure</span>(A.right, B)；<br><br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">return</span> (A!=<span class="hljs-literal">null</span>&amp;&amp;B!=<span class="hljs-literal">null</span>) &amp;&amp; (  recur(A, B)||isSubStructure(A.left, B)||isSubStructure(A.right, B)           )<br><br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span>&#123;<br>        <span class="hljs-keyword">if</span>(B==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-literal">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> recur(A.left, B.left)&amp;&amp;recur(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>例如输入：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br>镜像输出：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><br>输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= 节点个数 &lt;= <span class="hljs-number">1000</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、递归法</strong></p><p>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 &#x2F; 右子节点，即可生成二叉树的镜像。</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="hljs-number">1</span>.终止条件： 当节点<span class="hljs-built_in"> root</span> 为空时（即越过叶节点），则返回 null ；<br><span class="hljs-number">2</span>.递推工作：<br><span class="hljs-number">1</span>.初始化节点 tmp ，用于暂存<span class="hljs-built_in"> root</span> 的左子节点；<br><span class="hljs-number">2</span>.开启递归 右子节点 mirrorTree<span class="hljs-built_in">(root</span>.right)，并将返回值作为<span class="hljs-built_in"> root</span> 的左子节点 <br><span class="hljs-number">3</span>.开启递归 左子节点 mirrorTree(tmp)，并将返回值作为<span class="hljs-built_in"> root</span> 的右子节点 <br><span class="hljs-number">3</span>.返回值：返回当前节点<span class="hljs-built_in"> root</span> <br></code></pre></div></td></tr></table></figure><p>​<strong>二、辅助栈（或队列）</strong></p><p>利用栈（或队列）遍历树的所有节点 nodenode ，并交换每个 nodenode 的左 &#x2F; 右子节点。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>.特例处理： 当 root 为空时，直接返回 null ；<br><span class="hljs-number">2</span>.初始化： 栈（或队列），本文用栈，并加入根节点 root 。<br><span class="hljs-number">3</span>.循环交换： 当栈 stack 为空时跳出；<br><span class="hljs-number">1</span>.出栈： 记为 <span class="hljs-keyword">node</span> <span class="hljs-title">；</span><br><span class="hljs-title">2</span>.添加子节点： 将 <span class="hljs-keyword">node</span> <span class="hljs-title">左和右子节点入栈；</span><br><span class="hljs-title">3</span>.交换： 交换 <span class="hljs-keyword">node</span> <span class="hljs-title">的左 / 右子节点。</span><br><span class="hljs-title">4</span>.返回值： 返回根节点 root 。<br></code></pre></div></td></tr></table></figure><p>方法一递归代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(tmp);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二栈代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)stack.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)stack.add(node.right);<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> node.left;<br>            node.left = node.right;<br>            node.right = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">例如，二叉树 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>] 是对称的。<br>    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br>但是下面这个 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>] 则不是镜像对称的:<br>    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br>   <br>示例 <span class="hljs-number">1</span>：<br>输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、递归法</strong></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">对称二叉树定义： 对于树中任意两个对称节点LL和RR,一定有：<br>L<span class="hljs-selector-class">.val</span> = R<span class="hljs-selector-class">.val</span> ：即此两对称节点值相等。<br>L<span class="hljs-selector-class">.left</span><span class="hljs-selector-class">.val</span> = R<span class="hljs-selector-class">.right</span><span class="hljs-selector-class">.val</span> ：即 L 的 左子节点 和 R 的 右子节点 对称；<br>L<span class="hljs-selector-class">.right</span><span class="hljs-selector-class">.val</span> = R<span class="hljs-selector-class">.left</span>.val：即 L 的 右子节点 和 R 的 左子节点 对称。<br>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。<br><br><span class="hljs-function"><span class="hljs-title">isSymmetric</span><span class="hljs-params">(root)</span></span> <br>特例处理： 若根节点 root 为空，则直接返回 true。<br>返回值： 即 <span class="hljs-built_in">recur</span>(root<span class="hljs-selector-class">.left</span>, root.<span class="hljs-attribute">right</span>) ;<br><span class="hljs-function"><span class="hljs-title">recur</span><span class="hljs-params">(L, R)</span></span> <br>终止条件：<br>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；<br>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；<br>当节点 L ≠ 节点 R 值： 此树不对称，因此返回 false ；<br>递推工作：<br>判断两节点 L<span class="hljs-selector-class">.left</span> 和 R<span class="hljs-selector-class">.right</span> 是否对称，即 <span class="hljs-built_in">recur</span>(L<span class="hljs-selector-class">.left</span>, R.<span class="hljs-attribute">right</span>) ；<br>判断两节点 L<span class="hljs-selector-class">.right</span> 和 R<span class="hljs-selector-class">.left</span> 是否对称，即 <span class="hljs-built_in">recur</span>(L<span class="hljs-selector-class">.right</span>, R.<span class="hljs-attribute">left</span>) ；<br>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span> : recur(root.left, root.right);<br>    &#125;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode left,TreeNode right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>&amp;&amp;right==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>||right==<span class="hljs-literal">null</span>||left.val!=right.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(L.left, R.right)&amp;&amp;recur(L.right, R.left);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1><h2 id="8-动态规划"><a href="#8-动态规划" class="headerlink" title="8.动态规划"></a>8.动态规划</h2><h3 id="1-简单"><a href="#1-简单" class="headerlink" title="1.简单"></a>1.简单</h3><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。</p><p>使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。</p><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br><br>斐波那契数列由 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 <span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>（<span class="hljs-number">1000000007</span>），如计算初始结果为：<span class="hljs-number">1000000008</span>，请返回 <span class="hljs-number">1</span>。<br></code></pre></div></td></tr></table></figure><p><strong>方法一：动态规划</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><br>斐波那契数的边界条件是 <span class="hljs-constructor">F(0)</span>=<span class="hljs-number">0</span> 和 <span class="hljs-constructor">F(1)</span>=<span class="hljs-number">1</span>。当 n&gt;<span class="hljs-number">1</span> 时，每一项的和都等于前两项的和，因此有如下递推关系：<br><span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=<span class="hljs-constructor">F(<span class="hljs-params">n</span>-1)</span>+<span class="hljs-constructor">F(<span class="hljs-params">n</span>-2)</span><br>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 <span class="hljs-constructor">F(0)</span> 和 <span class="hljs-constructor">F(1)</span>。<br>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span> 的实现。由于 <span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span> 只和 <span class="hljs-constructor">F(<span class="hljs-params">n</span>−1)</span> 与<span class="hljs-constructor">F(<span class="hljs-params">n</span>−2)</span> 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <span class="hljs-constructor">O(1)</span>。如下的代码中给出的就是这种实现。<br></code></pre></div></td></tr></table></figure><p><strong>方法二：递归</strong></p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">原理： 把 <span class="hljs-built_in">f</span>(n)问题的计算拆分成 <span class="hljs-built_in">f</span>(n-<span class="hljs-number">1</span>) 和 <span class="hljs-built_in">f</span>(n-<span class="hljs-number">2</span>)两个子问题的计算，并递归，以 <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>) 和 <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) 为终止条件。<br>缺点： 大量重复的递归计算，例如 <span class="hljs-built_in">f</span>(n) 和 <span class="hljs-built_in">f</span>(n - <span class="hljs-number">1</span>)两者向下递归需要 各自计算 <span class="hljs-built_in">f</span>(n - <span class="hljs-number">2</span>)的值。<br></code></pre></div></td></tr></table></figure><p><strong>方法三：矩阵快速幂</strong></p><p><img src="/2022/04/27/%E7%AE%97%E6%B3%95%E9%A2%98/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220222095803683.png" alt="image-20220222095803683"></p><p>方法一代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            p = q;<br>            q = r;<br>            r=(p+q)%MOD;             <br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法三代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] q = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = pow(q, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] pow(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                ret = multiply(ret, a);<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>            a = multiply(a, a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiply(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b) &#123;<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                c[i][j] = (<span class="hljs-type">int</span>) (((<span class="hljs-type">long</span>) a[i][<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>][j] + (<span class="hljs-type">long</span>) a[i][<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>][j]) % MOD);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。问题同上一题</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br><br>输入：n <span class="hljs-operator">=</span> <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br><br>输入：n <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>方法一 矩阵快速幂</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] q = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = curr(q, n );<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] curr(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-type">int</span>[][] dir = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)dir =mutiply(a,dir);<br>            a = mutiply(a,a);<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dir;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] mutiply(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span>[][] b)&#123;<br>        <span class="hljs-type">int</span>[][] tem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)&#123;<br>                tem[i][j]=(<span class="hljs-type">int</span>)(((<span class="hljs-type">long</span>)a[i][<span class="hljs-number">0</span>]*b[<span class="hljs-number">0</span>][j]+(<span class="hljs-type">long</span>)a[i][<span class="hljs-number">1</span>]*b[<span class="hljs-number">1</span>][j])%MOD);<br>            &#125;     <br>        &#125;<br>        <span class="hljs-keyword">return</span> tem;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二 动态规划</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, sum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum = (a + b) % <span class="hljs-number">1000000007</span>;<br>            a = b;<br>            b = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br><br><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一：暴力法</strong></p><p><strong>方法二：动态规划</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minprice</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price:prices)&#123;<br>        <span class="hljs-keyword">if</span>(minprice&gt;price)minprice = price;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minprice&lt;price)pro = Math.max(pro,price-minprice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pro;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-中等"><a href="#2-中等" class="headerlink" title="2.中等"></a>2.中等</h3><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></div></td></tr></table></figure><p><strong>方法一、动态规划</strong></p><p><strong>方法二、暴力</strong></p><table><thead><tr><th>常见解法</th><th>时间复杂度</th><th><strong>空间复杂度</strong></th></tr></thead><tbody><tr><td>暴力搜索</td><td>O(N^2)</td><td>O(1)</td></tr><tr><td>分治思想</td><td>O(NlogN)</td><td>O(logN)</td></tr><tr><td>动态规划</td><td><em>O</em>(<em>N</em>)</td><td>O(1)</td></tr></tbody></table><p><strong>方法三、分治思想</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> res=nums[<span class="hljs-number">0</span>]; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            nums[i] += Math.max(nums[i-<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>            res = Math.max(res,nums[i]);<br>        &#125;     <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></p><h2 id="9-双指针（简单）"><a href="#9-双指针（简单）" class="headerlink" title="9.双指针（简单）"></a>9.双指针（简单）</h2><h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 5</span><br><span class="hljs-section">输出: [4,1,9]</span><br><span class="hljs-section">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><br><span class="hljs-section">输入: head = [4,5,1,9], val = 1</span><br><span class="hljs-section">输出: [4,5,9]</span><br><span class="hljs-section">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p>​<strong>一、顺序查找，直接遍历</strong></p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head.val==val)<span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head,node = head.next;<br>        <span class="hljs-keyword">while</span>( node != <span class="hljs-literal">null</span> &amp;&amp; node.val != val)&#123;<br>            pre = node;<br>            node = node.next;    <br>        &#125;<br>        <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">null</span>)pre.next = node.next;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p><strong>一、直接遍历</strong></p><p><strong>二、双指针遍历（快慢指针）</strong></p><p>快慢指针的思想。我们将第一个指针 fast 指向链表的第 k + 1个节点，第二个指针 slow 指向链表的第一个节点，此时指针 fast 与 slow 二者之间刚好间隔 k 个节点。此时两个指针同步向后走，当第一个指针fast 走到链表的尾部空节点时，则此时slow 指针刚好指向链表的倒数第k个节点。</p><p><strong>一、直接遍历代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>        ListNode node=head;<br><br>        <span class="hljs-keyword">for</span>(;node != <span class="hljs-literal">null</span>;node = node.next)n++;<br>        node=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-k;i++)&#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>二、双指针遍历（快慢指针）代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head,slow = head;<br>        <span class="hljs-keyword">for</span>(k&gt;<span class="hljs-number">0</span>;k++)fast = fast.next;<br>        <br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>)&#123;<br>            slow=slow.next;fast=fast.next;<br>        &#125;<br><span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br><br><span class="hljs-number">0</span> &lt;= 链表长度 &lt;= <span class="hljs-number">1000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、顺序遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> l1;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">null</span>&amp;&amp;l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val&lt;l2.val)&#123;<br>                node.next = l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span>) node.next = l2;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">null</span>) node.next = l1;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、递归</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l1 ==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2 ==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;<br><br>        <span class="hljs-keyword">if</span>(l1.val&lt;l2.val)&#123;<br>            l1.next = mergeTwoLists(l1.next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l2.next = mergeTwoLists(l1,l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Reference of the node with value = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-keyword">Reference</span> of the <span class="hljs-keyword">node</span> <span class="hljs-title">with</span> value = <span class="hljs-number">2</span><br>输入解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></div></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 <span class="hljs-built_in">O</span>(n) 时间复杂度，且仅用 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 内存。<br></code></pre></div></td></tr></table></figure><p><strong>方法一、双指针</strong></p><p>O(n+m) 时间复杂度，空间 O(m)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span>  <span class="hljs-operator">=</span> headA,pB = headB;<br>        <span class="hljs-keyword">while</span>(pA!=pB)&#123;<br>            pA = pA==<span class="hljs-literal">null</span> ? headB : pA.next;<br>            pB = pB==<span class="hljs-literal">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、哈希集合</strong></p><p>O(n+m) 时间复杂度，空间 O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        Set&lt;ListNode&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ListNode&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            visited.add(temp);<br>            temp = temp.next;<br>        &#125;<br>        temp = headB;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(temp)) &#123;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,2,3,4]</span><br>输出：<span class="hljs-selector-attr">[1,3,2,4]</span> <br>注：<span class="hljs-selector-attr">[3,1,2,4]</span> 也是正确的答案之一。<br><br><br><span class="hljs-number">0</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">50000</span><br><span class="hljs-number">0</span> &lt;= nums<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、双指针</strong></p><p>O(n) 时间复杂度，空间 O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] exchange(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(nums[left]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)left++;<br>            <span class="hljs-keyword">if</span>(nums[right]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)right--;<br><br>            <span class="hljs-keyword">if</span>(nums[left]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; nums[right]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span> &amp;&amp; left&lt;right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>                nums[left] = nums[right];<br>                nums[right] = temp;<br>            &#125;      <br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h4><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,7,11,15]</span>, target = <span class="hljs-number">9</span><br>输出：<span class="hljs-selector-attr">[2,7]</span> 或者 <span class="hljs-selector-attr">[7,2]</span><br><br>输入：nums = <span class="hljs-selector-attr">[10,26,30,31,47,60]</span>, target = <span class="hljs-number">40</span><br>输出：<span class="hljs-selector-attr">[10,30]</span> 或者 <span class="hljs-selector-attr">[30,10]</span><br><br><span class="hljs-number">1</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= nums<span class="hljs-selector-attr">[i]</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、双指针</strong></p><p>O(n) 时间复杂度，空间 O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(nums[right]&gt;target)right--;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(nums[left]+nums[right]&gt;target)right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left]+nums[right]&lt;target) left++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[left],nums[right]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;the sky is blue&quot;</span><br><span class="hljs-section">输出: &quot;blue is sky the&quot;</span><br><br><span class="hljs-section">输入: &quot;  hello world!  &quot;</span><br><span class="hljs-section">输出: &quot;world! hello&quot;</span><br><span class="hljs-section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><br><span class="hljs-section">输入: &quot;a good   example&quot;</span><br><span class="hljs-section">输出: &quot;example good a&quot;</span><br><span class="hljs-section">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、双指针</strong></p><p>O(n) 时间复杂度，空间 O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> s.length-<span class="hljs-number">1</span>; right = left;<br>        <br>        <span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(s.charAt(left)!=<span class="hljs-string">&#x27; &#x27;</span>)left--;<br>            res.append( s.substring(left+<span class="hljs-number">1</span>,right) + <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">while</span>(s.charAt(right)!=<span class="hljs-string">&#x27; &#x27;</span>)left--;<br>            right = left;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span> <span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span><br>返回一个字符串，该字符串是此字符串的子字符串。 子字符串从指定的beginIndex开始，并扩展到索引endIndex - <span class="hljs-number">1</span>处的字符。 因此子串的长度是endIndex-beginIndex 。<br></code></pre></div></td></tr></table></figure><h2 id="10-搜索与回溯算法（中等）"><a href="#10-搜索与回溯算法（中等）" class="headerlink" title="10.搜索与回溯算法（中等）"></a>10.搜索与回溯算法（中等）</h2><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br><br>输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], word = <span class="hljs-string">&quot;abcd&quot;</span><br>输出：false<br><br><span class="hljs-number">1</span> &lt;= board.length &lt;= <span class="hljs-number">200</span><br><span class="hljs-number">1</span> &lt;= board[i].length &lt;= <span class="hljs-number">200</span><br>board 和 word 仅由大小写英文字母组成<br></code></pre></div></td></tr></table></figure><p><strong>方法一、深度优先搜索DFS+剪枝</strong></p><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p><img src="https://pic.leetcode-cn.com/1604944042-glmqJO-Picture0.png" alt="Picture0.png"></p><p><strong>DFS 解析：</strong></p><p><strong>1.递归参数：</strong> </p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">当前元素在矩阵 <span class="hljs-keyword">board </span>中的行列索引 i 和 <span class="hljs-keyword">j </span>，当前目标字符在 word 中的索引 k 。<br></code></pre></div></td></tr></table></figure><p><strong>2.终止条件：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span>返回 falsefalse ：<br>(<span class="hljs-number">1</span>) 行或列索引越界 或 (<span class="hljs-number">2</span>) 当前矩阵元素与目标字符不同 或 (<span class="hljs-number">3</span>) 当前矩阵元素已访问过 （ (<span class="hljs-number">3</span>) 可合并至 (<span class="hljs-number">2</span>) ）<br><span class="hljs-number">2.</span>返回 truetrue ： k = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">word</span>) - <span class="hljs-number">1</span> ，即字符串 <span class="hljs-built_in">word</span> 已全部匹配。<br></code></pre></div></td></tr></table></figure><p><strong>递推工作：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog"><span class="hljs-number">1.</span>标记当前矩阵元素： 将 board[i][j] 修改为 空字符 <span class="hljs-string">&#x27;&#x27;</span> ，代表此元素已访问过，防止之后搜索时重复访问。<br><span class="hljs-number">2.</span>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 <span class="hljs-symbol">DFS</span> ），并记录结果至 res 。<br><span class="hljs-number">3.</span>还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。<br></code></pre></div></td></tr></table></figure><p><strong>返回值：</strong> </p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">返回布尔量 <span class="hljs-keyword">res</span> ，代表是否搜索到目标字符串。<br><br></code></pre></div></td></tr></table></figure><p>使用空字符（Python: ‘’ , Java&#x2F;C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">时间复杂度 O(<span class="hljs-number">3</span>^K  MN)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(<span class="hljs-number">3</span>^K)<br> )；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<br>    <br>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 <span class="hljs-number">3</span> 种选择，因此方案数的复杂度为 O(<span class="hljs-number">3</span>^K) 。<br>    <br>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K=MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。<br></code></pre></div></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] wordarry = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;board.length;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;<br>               <span class="hljs-keyword">if</span>( cur(board,wordarry,i,j,<span class="hljs-number">0</span>))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cur</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board,<span class="hljs-type">char</span>[] wordarry,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;=board.length||j&lt;<span class="hljs-number">0</span>||j&gt;=board[<span class="hljs-number">0</span>].length||board[i][j]!=wordarry[k])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(k == wordarry.length - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> cur(board,wordarry,i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>)||cur(board,wordarry,i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>)||cur(board,wordarry,i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>)||cur(board,wordarry,i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);<br>        board[i][j] = wordarry[k];<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入：m = <span class="hljs-number">2</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br><br>输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br><br><span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">n</span>,m &lt;= <span class="hljs-number">100</span><br><span class="hljs-number">0</span> &lt;= k &lt;= <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、深度优先搜索</strong></p><p><img src="https://pic.leetcode-cn.com/1603026306-OdpwLi-Picture1.png" alt="img"></p><p><strong>算法解析：</strong></p><p><strong>递归参数：</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">当前元素在矩阵中的行列索引 <span class="hljs-selector-tag">i</span> 和 j ，两者的数位和 si, sj 。<br></code></pre></div></td></tr></table></figure><p>**终止条件：</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回<span class="hljs-number"> 00 </span>，代表不计入可达解。<br></code></pre></div></td></tr></table></figure><p><strong>递推工作：</strong></p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">标记当前单元格 ：将索引 (i, j) 存入 <span class="hljs-keyword">Set</span> visited 中，代表此单元格已被访问过。<br><br>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。<br>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。<br></code></pre></div></td></tr></table></figure><p><strong>回溯返回值：</strong> </p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">返回<span class="hljs-number"> 1 </span>+ 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。<br></code></pre></div></td></tr></table></figure><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m,n,k;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-built_in">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> si,<span class="hljs-type">int</span> sj)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=m||j&gt;=n||si+sj&gt;k||visited[i][j])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i+<span class="hljs-number">1</span>,j,(i+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> ? si-<span class="hljs-number">8</span> : si+<span class="hljs-number">1</span> ,sj) + dfs(i,j+<span class="hljs-number">1</span>,si,(j+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> ? sj-<span class="hljs-number">8</span> : sj+<span class="hljs-number">1</span> );<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、广度优先搜索BFS</strong></p><p><strong>BFS&#x2F;DFS ：</strong> 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。</p><p>**BFS 实现： **通常利用队列实现广度优先遍历。</p><p><strong>初始化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">将机器人初始点 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 加入队列 queue ；<br></code></pre></div></td></tr></table></figure><p><strong>迭代终止条件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">queue 为空。代表已遍历完所有可达解。<br></code></pre></div></td></tr></table></figure><p><strong>迭代工作：</strong></p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。<br>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。<br>标记当前单元格 ：将单元格索引 (i, j) 存入 <span class="hljs-keyword">Set</span> visited 中，代表此单元格 已被访问过 。<br>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。<br></code></pre></div></td></tr></table></figure><p><strong>返回值：</strong></p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-keyword">Set</span> visited 的长度 <span class="hljs-comment">len(visited)</span> ，即可达解的数量。<br></code></pre></div></td></tr></table></figure><p><strong>广度优先搜索BFS代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <br>        <span class="hljs-keyword">while</span>(queue.size()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span>[] temp = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">0</span>],j=temp[<span class="hljs-number">1</span>],si=temp[<span class="hljs-number">2</span>],sj=temp[<span class="hljs-number">3</span>];<br>            <span class="hljs-keyword">if</span>(i&gt;=m||j&gt;=n||si+sj&gt;k||visited[i][j])<span class="hljs-keyword">continue</span>;<br>            visited[i][j] = <span class="hljs-literal">true</span>;<br>            res++;<br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;temp[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,temp[<span class="hljs-number">1</span>],(temp[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> ? temp[<span class="hljs-number">2</span>]-<span class="hljs-number">8</span> : temp[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span> ,temp[<span class="hljs-number">3</span>]&#125;);<br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;temp[<span class="hljs-number">0</span>],temp[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,temp[<span class="hljs-number">2</span>],(temp[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> ? temp[<span class="hljs-number">3</span>]-<span class="hljs-number">8</span> : temp[<span class="hljs-number">3</span>]+<span class="hljs-number">1</span> &#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ， 找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,null,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], targetSum = <span class="hljs-number">22</span><br>输出：<span class="hljs-string">[[5,4,11,2],[5,8,4,5]]</span><br></code></pre></div></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2,3]</span>, targetSum = 5<br>输出：<span class="hljs-comment">[]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span>, targetSum = 0<br>输出：<span class="hljs-comment">[]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">树中节点总数在范围</span> [<span class="hljs-number">0</span>, <span class="hljs-number">5000</span>] <span class="hljs-string">内</span><br><span class="hljs-number">-1000</span> <span class="hljs-string">&lt;=</span> <span class="hljs-string">Node.val</span> <span class="hljs-string">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-number">-1000</span> <span class="hljs-string">&lt;=</span> <span class="hljs-string">targetSum</span> <span class="hljs-string">&lt;=</span> <span class="hljs-number">1000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、深度优先搜索DFS</strong></p><p><strong>算法解析：</strong></p><p><strong>递归参数：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;&gt;</span>  存放所有的结果<br>队列存放路线<br><br>当前节点的子节点   <span class="hljs-variable">target</span>剩余的值<br></code></pre></div></td></tr></table></figure><p>**终止条件：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">当节点为空，立即返回<br><span class="hljs-attribute">target</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> 并且没有子节点，表明搜索到了。将该队列路线加入list<br></code></pre></div></td></tr></table></figure><p><strong>递推工作：</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">将当前值入队列，路线<br>左孩子和右孩子放入递归中，<br>说明路线不通或者已经走通，将当前加入队列的值删掉<br></code></pre></div></td></tr></table></figure><p><strong>回溯返回值：</strong> </p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">无<br></code></pre></div></td></tr></table></figure><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        dfs(root, target);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.offerLast(root.val);<br>        target -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; target == <span class="hljs-number">0</span>) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(path));<br>        &#125;<br>        dfs(root.left, target);<br>        dfs(root.right, target);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、广度优先搜索BFS</strong></p><h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p> <strong>方法一、深度优先搜索DFS</strong></p><p><strong>算法流程：</strong></p><p><strong>dfs(cur): 递归法中序遍历；</strong></p><p><strong>1.终止条件：</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">当节点 cur 为空，代表越过叶节点，直接返回；<br></code></pre></div></td></tr></table></figure><p><strong>2.递归左子树</strong>，</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">即 <span class="hljs-built_in">dfs</span>(cur.left) <br></code></pre></div></td></tr></table></figure><p><strong>3.构建链表：</strong></p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-number">1</span>.当 <span class="hljs-keyword">pre</span> 为空时： 代表正在访问链表头节点，记为 head ；<br><span class="hljs-number">2</span>.当 <span class="hljs-keyword">pre</span> 不为空时： 修改双向节点引用，即 <span class="hljs-keyword">pre</span>.<span class="hljs-keyword">right</span> = cur ， cur.<span class="hljs-keyword">left</span> = <span class="hljs-keyword">pre</span> ；<br><span class="hljs-number">3</span>.保存 cur ： 更新 <span class="hljs-keyword">pre</span> = cur ，即节点 cur 是后继节点的 <span class="hljs-keyword">pre</span> ；<br></code></pre></div></td></tr></table></figure><p><strong>4.递归右子树</strong></p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">即 <span class="hljs-built_in">dfs</span>(cur.right) ；<br></code></pre></div></td></tr></table></figure><p><strong>treeToDoublyList(root)：</strong></p><p><strong>1.特例处理：</strong> 若节点 root 为空，则直接返回；</p><p><strong>2.初始化：</strong> 空节点 pre ；</p><p><strong>3.转化为双向链表：</strong> 调用 dfs(root) ；</p><p><strong>4.构建循环链表：</strong> 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；</p><p><strong>5.返回值：</strong> 返回链表的头节点 head 即可；</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Node pre,head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>        <br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">null</span>)head = cur;<br>        <span class="hljs-keyword">else</span> &#123;pre.right = cur; &#125;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br><br>输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br><br><span class="hljs-number">1</span> ≤ k ≤ 二叉搜索树元素个数<br></code></pre></div></td></tr></table></figure><p> <strong>方法一、深度优先搜索DFS</strong></p><p><strong>算法流程：</strong></p><p><strong>1.终止条件：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">当节点 cur 为空，代表越过叶节点，反回， 如果K<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;找到第k大数返回。</span><br></code></pre></div></td></tr></table></figure><p><strong>2.递归右子树</strong>，</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">即 <span class="hljs-built_in">dfs</span>(cur.right) <br></code></pre></div></td></tr></table></figure><p><strong>3.递归：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-number">1</span>.k--<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p><strong>4.递归左子树</strong></p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">即 <span class="hljs-built_in">dfs</span>(cur.left) ；<br></code></pre></div></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> k,aim;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> aim;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(--k == <span class="hljs-number">0</span> )aim = root.val;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>返回它的最大深度 3 。</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">节点总数 &lt;<span class="hljs-operator">=</span> <span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、深度优先搜索</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、广度优先搜索BFS</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        List&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(TreeNode node : queue) &#123;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) tmp.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) tmp.add(node.right);<br>            &#125;<br>            queue = tmp;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>返回 <span class="hljs-literal">true</span> <br></code></pre></div></td></tr></table></figure><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br><span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、后序遍历 + 剪枝 （从底至顶）</strong></p><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p><p><strong>算法流程：</strong></p><p>recur(root) 函数：</p><p><strong>返回值：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">当节<span class="hljs-built_in">点root</span> 左 / 右子树的深度差 \leq <span class="hljs-number">1</span>≤<span class="hljs-number">1</span> ：则返回当前子树的深度，即节点<span class="hljs-built_in"> root</span> 的左 / 右子树的深度最大值 +<span class="hljs-number">1</span>+<span class="hljs-number">1</span> （<span class="hljs-built_in"> max</span>(left, right) + <span class="hljs-number">1</span> ）；<br><br>当节<span class="hljs-built_in">点root</span> 左 / 右子树的深度差 &gt; <span class="hljs-number">2</span>&gt;<span class="hljs-number">2</span> ：则返回 -<span class="hljs-number">1</span>−<span class="hljs-number">1</span> ，代表 此子树不是平衡树 。<br></code></pre></div></td></tr></table></figure><p><strong>终止条件：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">当 root 为空：说明越过叶节点，因此返回高度 <span class="hljs-number">0</span> ；<br><br>当左（右）子树深度为 -<span class="hljs-number">1</span> ：代表此树的 左（右）子树 不是平衡树，因此剪枝，直接返回 -<span class="hljs-number">1</span> ；<br><span class="hljs-function"><span class="hljs-title">isBalanced</span><span class="hljs-params">(root)</span></span> 函数：<br></code></pre></div></td></tr></table></figure><p><strong>返回值：</strong> </p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl">若 <span class="hljs-function"><span class="hljs-title">recur</span>(<span class="hljs-variable">root</span>) <span class="hljs-variable">!</span>= -<span class="hljs-number">1</span> ，则说明此树平衡，返回 <span class="hljs-variable"><span class="hljs-literal">true</span></span> ； 否则返回 <span class="hljs-variable"><span class="hljs-literal">false</span></span> 。</span><br></code></pre></div></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(root) != -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> recur(root.left);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> recur(root.right);<br>        <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(left - right) &lt; <span class="hljs-number">2</span> ? Math.max(left,right)+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 3</span><br><span class="hljs-section">输出: 6</span><br><br><span class="hljs-section">输入: n = 9</span><br><span class="hljs-section">输出: 45</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、递归</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> n &gt;<span class="hljs-number">0</span> &amp;&amp; (n+=sumNums(n-<span class="hljs-number">1</span>)) &gt;<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入: root = <span class="hljs-selector-attr">[6,2,8,0,4,7,9,null,null,3,5]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span> <br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br><br>输入: root = <span class="hljs-selector-attr">[6,2,8,0,4,7,9,null,null,3,5]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br><br><br>所有节点的值都是唯一的。<br>p、<span class="hljs-selector-tag">q</span> 为不同节点且均存在于给定的二叉搜索树中。 <br></code></pre></div></td></tr></table></figure><p><strong>方法一：迭代</strong></p><p>循环搜索： 当节点 rootroot 为空时跳出；</p><p>当 p, qp,q 都在 rootroot 的 右子树 中，则遍历至 root.rightroot.right ；</p><p>否则，当 p, qp,q 都在 rootroot 的 左子树 中，则遍历至 root.leftroot.left ；</p><p>否则，说明找到了 最近公共祖先 ，跳出。</p><p>时间复杂度 O(N)O(N) ： 其中 NN 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 \log NlogN （满二叉树），最大为 NN （退化为链表）。</p><p>空间复杂度 O(1)O(1) ： 使用常数大小的额外空间。</p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br><br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)root = root.left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)root = root.right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入: root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br><br>输入: root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br><br>所有节点的值都是唯一的。<br>p、<span class="hljs-selector-tag">q</span> 为不同节点且均存在于给定的二叉树中。<br></code></pre></div></td></tr></table></figure><p>pp 和 qq 在 rootroot 的子树中，且分列 rootroot 的 异侧（即分别在左、右子树中）；</p><p>p &#x3D; rootp&#x3D;root ，且 qq 在 rootroot 的左或右子树中；</p><p>q &#x3D; rootq&#x3D;root ，且 pp 在 rootroot 的左或右子树中；</p><p>递归解析：</p><p>终止条件：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">当越过叶节点，则直接返回 nullnull ；当 rootroot 等于 <span class="hljs-selector-tag">p</span>, qp,<span class="hljs-selector-tag">q</span> ，则直接返回 rootroot ；<br></code></pre></div></td></tr></table></figure><p>递推工作：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">开启递归左子节点，返回值记为 leftleft ；<br>开启递归右子节点，返回值记为 rightright ；<br></code></pre></div></td></tr></table></figure><p>返回值：</p><p> 根据 leftleft 和 rightright ，可展开为四种情况；</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">当 leftleft 和 rightright 同时为空 ：说明 rootroot 的左 / 右子树中都不包含 <span class="hljs-selector-tag">p</span>,qp,<span class="hljs-selector-tag">q</span> ，返回 nullnull ；<br><br>当 leftleft 和 rightright 同时不为空 ：说明 <span class="hljs-selector-tag">p</span>, qp,<span class="hljs-selector-tag">q</span> 分列在 rootroot 的 异侧 （分别在 左 / 右子树），因此 rootroot 为最近公共祖先，返回 rootroot ；<br><br>当 leftleft 为空 ，rightright 不为空 ：<span class="hljs-selector-tag">p</span>,qp,<span class="hljs-selector-tag">q</span> 都不在 rootroot 的左子树中，直接返回 rightright 。具体可分为两种情况：<br><br><span class="hljs-selector-tag">p</span>,qp,<span class="hljs-selector-tag">q</span> 其中一个在 rootroot 的 右子树 中，此时 rightright 指向 pp（假设为 pp ）；<br><span class="hljs-selector-tag">p</span>,qp,<span class="hljs-selector-tag">q</span> 两节点都在 rootroot 的 右子树 中，此时的 rightright 指向 最近公共祖先节点 ；<br>当 leftleft 不为空 ， rightright 为空 ：与情况 <span class="hljs-number">3</span>. 同理；<br></code></pre></div></td></tr></table></figure><p>时间复杂度 O(N)O(N) ： 其中 NN 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</p><p>空间复杂度 O(N)O(N) ： 最差情况下，递归深度达到 NN ，系统使用 O(N)O(N) 大小的额外空间。</p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p ||  root == q)<span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left , p , q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right , p , q);<br><br>        <span class="hljs-keyword">if</span>( left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>( left == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>( right == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> left;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="11-排序（简单）"><a href="#11-排序（简单）" class="headerlink" title="11.排序（简单）"></a>11.排序（简单）</h2><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入: <span class="hljs-selector-attr">[10,2]</span><br>输出: <span class="hljs-string">&quot;102&quot;</span><br><br>输入: <span class="hljs-selector-attr">[3,30,34,5,9]</span><br>输出: <span class="hljs-string">&quot;3033459&quot;</span><br><br><span class="hljs-number">0</span> &lt; nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100</span><br>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 <span class="hljs-number">0</span>，最后结果不需要去掉前导 <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>方法一、</p><p>若拼接字符串 x + y &gt; y + x，则 x “大于” y ；</p><p>反之，若 x + y &lt; y + x，则 x “小于” y ；</p><p>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度 ≤N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2)</p><p>空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        String[] str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)str[i] = String.valueOf(nums[i]);<br>        Arrays.sort(str,(x,y)-&gt;(x+y).compareTo(y+x));<br>         <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>         <span class="hljs-keyword">for</span>(String s : str)&#123;<br>             res.append(s);<br>         &#125;<br>         <span class="hljs-keyword">return</span> res.toString();<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>自己写快排</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)<br>            strs[i] = String.valueOf(nums[i]);<br>        quickSort(strs, <span class="hljs-number">0</span>, strs.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(String s : strs)<br>            res.append(s);<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> strs[i];<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j) j--;<br>            <span class="hljs-keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j) i++;<br>            tmp = strs[i];<br>            strs[i] = strs[j];<br>            strs[j] = tmp;<br>        &#125;<br>        strs[i] = strs[l];<br>        strs[l] = tmp;<br>        quickSort(strs, l, i - <span class="hljs-number">1</span>);<br>        quickSort(strs, i + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4,5]</span><br><span class="hljs-section">输出: True</span><br><br><span class="hljs-section">输入: [0,0,1,2,5]</span><br><span class="hljs-section">输出: True</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一： 集合 Set + 遍历</strong></p><p>遍历五张牌，遇到大小王（即 0 ）直接跳过。</p><p>判别重复： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1) ；</p><p>获取最大 &#x2F; 最小的牌： 借助辅助变量 mama 和 mimi ，遍历统计即可。</p><p>复杂度分析：</p><p>时间复杂度 O(N) &#x3D; O(5) &#x3D; O(1)： 其中 NN 为 nums 长度，本题中 N \equiv 5N≡5 ；遍历数组使用 O(N) 时间。</p><p>空间复杂度 O(N) &#x3D; O(5) &#x3D; O(1)： 用于判重的辅助 Set 使用 O(N) 额外空间。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>,min=<span class="hljs-number">14</span>;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>            max = Math.max(max,nums[i]);<br>            min = Math.min(min,nums[i]);<br>            <span class="hljs-keyword">if</span>(set.contains(nums[i]))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            set.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ( max - min ) &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">输入：arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 或者 [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><br>输入：arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">0</span>]<br><br><span class="hljs-number">0</span> &lt;= k &lt;= arr.length &lt;= <span class="hljs-number">10000</span><br><span class="hljs-number">0</span> &lt;= arr[i] &lt;= <span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一：排序</strong></p><p><strong>思路和算法</strong></p><p>对原数组从小到大排序后取出前 <em>k</em> 个数即可。</p><p>复杂度分析</p><p>时间复杂度：O(nlogn)，其中 nn 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。</p><p>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</p><p><strong>方法一代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            vec[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二：堆</strong></p><p>我们用一个大根堆实时维护数组的前 kk 小值。首先将前 kk 个数插入大根堆中，随后从第 k+1k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 排除 0 的情况</span><br>            <span class="hljs-keyword">return</span> vec;<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer num1, Integer num2)</span> &#123;<br>                <span class="hljs-keyword">return</span> num2 - num1;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            queue.offer(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; arr.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (queue.peek() &gt; arr[i]) &#123;<br>                queue.poll();<br>                queue.offer(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            vec[i] = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>        double findMedian() - 返回目前所有元素的中位数。</p><figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]<br><br>输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,<span class="hljs-number">2.00000</span>,null,<span class="hljs-number">2.50000</span>]<br><br>最多会对 addNum、findMedian 进行 <span class="hljs-number">50000</span> 次调用。<br></code></pre></div></td></tr></table></figure><p><strong>方法一、堆</strong></p><p>维护A,B两个堆，将数据大的一半放入B中，小的一半放入A中，去中位数从A,B顶端取出元素比较即可。</p><p>时间复杂度 </p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">查找中位数 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) ： 获取堆顶元素使用 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 时间；<br>添加数字 <span class="hljs-built_in">O</span>(logN) ： 堆的插入和弹出操作使用 <span class="hljs-built_in">O</span>(logN) 时间。<br></code></pre></div></td></tr></table></figure><p>空间复杂度O(N) :其中 N* 为数据流中的元素数量，小顶堆 A* 和大顶堆 B* 最多同时保存 <em>N</em> 个元素。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    PriorityQueue&lt;Integer&gt; A,B;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;( (x,y) -&gt; (y-x) );<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;<br>            A.add(num);<br>            B.add(A.poll());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> A.size() == B.size() ?  ( A.peek()+B.peek() )/<span class="hljs-number">2.0</span> : A.peek();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="分治算法（中等）"><a href="#分治算法（中等）" class="headerlink" title="分治算法（中等）"></a>分治算法（中等）</h2><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas"><span class="hljs-keyword">Input</span>: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br><span class="hljs-keyword">Output</span>: [3,9,20,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,15,7]<br></code></pre></div></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: preorder =<span class="hljs-meta"> [-1], inorder = [-1]</span><br><span class="hljs-attribute">Output</span>:<span class="hljs-meta"> [-1]</span><br><br><span class="hljs-attribute">0</span> &lt;= 节点个数 &lt;= <span class="hljs-number">5000</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一：递归</strong></p><p>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。</p><p>中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</p><p><strong>根据以上性质，可得出以下推论：</strong></p><p>前序遍历的首元素 为 树的根节点 node 的值。</p><p>在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</p><p>根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]</p><p><img src="https://pic.leetcode-cn.com/1629825510-roByLr-Picture1.png" alt="Picture1.png"></p><p>通过以上三步，可确定 <strong>三个节点</strong> ：1.树的根节点、2.左子树根节点、3.右子树根节点。</p><p>根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。</p><p><strong>分治算法解析：</strong></p><p><strong>递推参数：</strong> 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p><p><strong>终止条件：</strong> 当 left &gt; right ，代表已经越过叶节点，此时返回 nullnull ；</p><p><strong>递推工作：</strong></p><p>​<strong>1.建立根节点 node ：</strong> 节点值为 preorder[root] ；</p><p>​<strong>2.划分左右子树：</strong> 查找根节点在中序遍历 inorder 中的索引 i ；</p><p>为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)O(1) ；</p><p>​<strong>3.构建左右子树：</strong> 开启左右子树递归；</p><table><thead><tr><th>根节点索引</th><th>中序遍历左边界</th><th>中序遍历右边界</th></tr></thead><tbody><tr><td><strong>左子树</strong></td><td><code>root + 1</code></td><td><code>left</code></td></tr><tr><td><strong>右子树</strong></td><td><code>i - left + root + 1</code></td><td><code>i + 1</code></td></tr></tbody></table><p><strong>TIPS：</strong> <code>i - left + root + 1</code>含义为 <code>根节点索引 + 左子树长度 + 1</code></p><p><img src="https://pic.leetcode-cn.com/1603644245-oLIgwn-Picture12.png" alt="img"></p><p>时间复杂度 O(N)O(N) ： 其中 NN 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N)O(N) 。递归共建立 NN 个节点，每层递归中的节点建立、搜索操作占用 O(1)O(1) ，因此使用 O(N)O(N) 时间。</p><p>空间复杂度 O(N)O(N) ： HashMap 使用 O(N)O(N) 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 NN ，占用 O(N)O(N) 的栈帧空间；因此总共使用 O(N)O(N) 空间。</p><p><strong>方法一、递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    HashMap&lt;Integer,Integer&gt; inorderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] preorderArry;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            inorderMap.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.preorderArry = preorder;<br>        <span class="hljs-keyword">return</span> recur(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    TreeNode <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;right)<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorderArry[root]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> inorderMap.get(preorderArry[root]);<br>        node.left = recur(root + <span class="hljs-number">1</span> , left , i - <span class="hljs-number">1</span>);<br>        node.right = recur(root + <span class="hljs-number">1</span>  - left + i , i + <span class="hljs-number">1</span> , right);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1024.00000</span><br><br>输入：x = <span class="hljs-number">2.10000</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">9.26100</span><br><br>输入：x = <span class="hljs-number">2.00000</span>, n = -<span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.25000</span><br>解释：<span class="hljs-number">2</span>-<span class="hljs-number">2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0</span>.<span class="hljs-number">25</span><br></code></pre></div></td></tr></table></figure><p><strong>快速幂解析（二进制角度）：</strong></p><p>注意 <strong>java中int类型是有符号的</strong>，负的下限 绝对这 <strong>比正的上限</strong>绝对值<strong>大一</strong>   ，要切换成long型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span>(b &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span> / x;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) res *= x;<br>            x *= x;<br>            b &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p><strong>后序遍历定义：</strong> [ <strong>左子树 | 右子树 | 根节点 ]</strong> ，即遍历顺序为 “左、右、根” 。</p><p>二叉搜索树定义： <strong>左子树中所有节点的值 &lt;&lt; 根节点的值**；**右子树中所有节点的值 &gt;&gt; 根节点的值</strong>；其左、右子树也分别为二叉搜索树。</p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 ：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,6,3,2,5]</span><br><span class="hljs-section">输出: false</span><br><br><span class="hljs-section">输入: [1,3,2,6,5]</span><br><span class="hljs-section">输出: true</span><br><br>数组长度 &lt;= 1000<br></code></pre></div></td></tr></table></figure><p><strong>方法一：递归分治</strong></p><p>根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p><p><strong>递归解析：</strong></p><p><strong>终止条件：</strong> 当 i≥j ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 truetrue ；</p><p><strong>递推工作：</strong></p><p>​<strong>1.划分左右子树：</strong> 遍历后序遍历的 [i, j][i,j] 区间元素，寻找 第一个大于根节点 的节点，索引记为 m 。此时，可划分出左子树区间 [i,m-1][i,m−1] 、右子树区间 [m, j - 1][m,j−1] 、根节点索引 j 。</p><p>​<strong>2.判断是否为二叉搜索树：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">1</span>.左子树区间 <span class="hljs-selector-attr">[i, m - 1]</span><span class="hljs-selector-attr">[i,m−1]</span> 内的所有节点都应 &lt;&lt; postorder<span class="hljs-selector-attr">[j]</span>postorder<span class="hljs-selector-attr">[j]</span> 。而第 <span class="hljs-number">1</span>.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。<br><br><span class="hljs-number">2</span>.右子树区间 <span class="hljs-selector-attr">[m, j-1]</span><span class="hljs-selector-attr">[m,j−1]</span> 内的所有节点都应 &gt;&gt; postorder<span class="hljs-selector-attr">[j]</span>postorder<span class="hljs-selector-attr">[j]</span> 。实现方式为遍历，当遇到 \leq postorder<span class="hljs-selector-attr">[j]</span>≤postorder<span class="hljs-selector-attr">[j]</span> 的节点则跳出；则可通过 <span class="hljs-selector-tag">p</span> = jp=j 判断是否为二叉搜索树。<br></code></pre></div></td></tr></table></figure><p><strong>返回值：</strong> 所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp;&amp; 连接。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.p</span> = jp=j ： 判断 此树 是否正确。<br><span class="hljs-number">2</span><span class="hljs-selector-class">.recur</span>(<span class="hljs-selector-tag">i</span>, m - <span class="hljs-number">1</span>)<span class="hljs-built_in">recur</span>(<span class="hljs-selector-tag">i</span>,m−<span class="hljs-number">1</span>) ： 判断 此树的左子树 是否正确。<br><span class="hljs-number">3</span><span class="hljs-selector-class">.recur</span>(m, j - <span class="hljs-number">1</span>)<span class="hljs-built_in">recur</span>(m,j−<span class="hljs-number">1</span>) ： 判断 此树的右子树 是否正确。<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> recur(postorder, <span class="hljs-number">0</span> , postorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=j)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(postorder[p]&lt;postorder[j])p++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p;<br>        <span class="hljs-keyword">while</span>(postorder[p]&gt;postorder[j])p++;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span>= j &amp;&amp; recur(postorder,i,m-<span class="hljs-number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="位运算（简单）"><a href="#位运算（简单）" class="headerlink" title="位运算（简单）"></a>位运算（简单）</h2><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p> 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">输入：n =<span class="hljs-number"> 11 </span>(控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。<br><br>输入：n =<span class="hljs-number"> 128 </span>(控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。<br><br>输入：n =<span class="hljs-number"> 4294967293 </span>(控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：输入的二进制串<span class="hljs-number"> 11111111111111111111111111111101 </span>中，共有<span class="hljs-number"> 31 </span>位为 &#x27;1&#x27;。<br><br>输入必须是长度为<span class="hljs-number"> 32 </span>的 二进制串 。<br></code></pre></div></td></tr></table></figure><p><strong>方法一、循环检查二进制位</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>( (n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)cnt++;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二：位运算优化</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> &amp; (n−<span class="hljs-number">1</span>)其预算结果恰为把 n 的二进制位中的最低位的 <span class="hljs-number">1</span> 变为 <span class="hljs-number">0</span> 之后的结果。<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">2</span><br><br><span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> 均可能是负数或 <span class="hljs-number">0</span><br>结果不会溢出 <span class="hljs-number">32</span> 位整数<br></code></pre></div></td></tr></table></figure><p>方法一、位运算</p><p> 在计算机系统中，数值一律用 <strong>补码</strong> 来表示和存储。<strong>补码的优势：</strong> 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 <strong>同时适用于正数和负数的加法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a ^ b;<br>            b = (a &amp; b)&lt;&lt;<span class="hljs-number">1</span>; <br>            a = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[4,1,4,6]</span><br>输出：<span class="hljs-selector-attr">[1,6]</span> 或 <span class="hljs-selector-attr">[6,1]</span><br><br>输入：nums = <span class="hljs-selector-attr">[1,2,10,4,1,4,3,3]</span><br>输出：<span class="hljs-selector-attr">[2,10]</span> 或 <span class="hljs-selector-attr">[10,2]</span><br><br><span class="hljs-number">2</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            res ^= nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>( (res &amp; b) == <span class="hljs-number">0</span> )b &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resultA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, resultB = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-keyword">if</span>((nums[i] &amp; b) != <span class="hljs-number">0</span>) resultA ^= nums[i];<br>            <span class="hljs-keyword">else</span> resultB ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;resultA,resultB&#125;;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,4,3,3]</span><br>输出：<span class="hljs-number">4</span><br><br>输入：nums = <span class="hljs-selector-attr">[9,1,7,9,7,9,7]</span><br>输出：<span class="hljs-number">1</span><br><br>限制：<br><span class="hljs-number">1</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10000</span><br><span class="hljs-number">1</span> &lt;= nums<span class="hljs-selector-attr">[i]</span> &lt; <span class="hljs-number">2</span>^<span class="hljs-number">31</span><br></code></pre></div></td></tr></table></figure><p> 统计每一个出现的次数</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] sumBitCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">32</span> ; j++ )&#123;<br>                sumBitCount[j] += ((nums[i] &amp; b) != <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> );<br>                b &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">32</span> ; i++)&#123;<br>           rec |=  ( (sumBitCount[i] % <span class="hljs-number">3</span>) &amp; <span class="hljs-number">1</span> ) &lt;&lt; i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rec;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="数学（简单）"><a href="#数学（简单）" class="headerlink" title="数学（简单）"></a>数学（简单）</h2><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="hljs-section">输出: 2</span><br><br>1 &lt;= 数组长度 &lt;= 50000<br></code></pre></div></td></tr></table></figure><p><strong>方法一、哈希表</strong></p><p>每个数次出现的次数，如果最大出现次数大于数组一半，直接返回</p><p>​时间复杂度：O(N)</p><p>​空间复杂度：O(N)</p><p><strong>方法二、中位数法</strong></p><p>排序一下，取中位数</p><p>​时间复杂度：O(nlogn)</p><p>​空间复杂度：O(nlogn)</p><p><strong>方法三、Boyer-Moore 投票算法</strong></p><p>既然是大于数组一般，直接让该数出现一次+1， 出现别的-1；   &#x3D;0 时换数字，  最终和一定大于0</p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(1)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                candidate = nums[i];<br>            &#125;<br>            count += nums[i] == candidate ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>   <br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">输入: <span class="hljs-selector-attr">[1,2,3,4,5]</span><br>输出: <span class="hljs-selector-attr">[120,60,40,30,24]</span><br><br>所有元素乘积之和不会溢出 <span class="hljs-number">32</span> 位整数<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">100000</span><br></code></pre></div></td></tr></table></figure><p>根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p><p>​时间复杂度：O(n)</p><p>​空间复杂度：O(1)</p><p><img src="https://pic.leetcode-cn.com/1599920669-thDqmQ-Picture10.png" alt="img"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leng</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">if</span>(leng == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[leng];<br>        b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;leng ; i++ )&#123;<br>            b[i] = b[i-<span class="hljs-number">1</span>]*a[i-<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tem</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> leng-<span class="hljs-number">2</span> ; i &gt;=<span class="hljs-number">0</span> ; i-- )&#123;<br>            tem *= a[i+<span class="hljs-number">1</span>];<br>            b[i] *= tem;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1<br><br>输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36<br></code></pre></div></td></tr></table></figure><p><strong>方法一、数学法</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二、通用法  贪心</strong></p><p>和方法一一样，通过N&#x3D;1,2,3,4,5,6  …找到规律</p><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">输入：target = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[2,3,4],[4,5]]</span><br><br>输入：target = <span class="hljs-number">15</span><br>输出：<span class="hljs-string">[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><br> <span class="hljs-number">1</span> &lt;= target &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p><strong>方法一、枚举+暴力</strong></p><p><strong>方法一、枚举+数学优化</strong></p><p>根据连续数，首项加末项×项数除以2 &#x3D; target</p><p>(x+y)×(y−x+1)&#x2F;2 &#x3D; target     ，变成 <em>y</em>2+<em>y</em>−<em>x</em>2+<em>x</em>−2×<em>target</em>&#x3D;0      </p><p><em>a</em>&#x3D;1,<em>b</em>&#x3D;1,<em>c</em>&#x3D;−<em>x</em>2+<em>x</em>−2×<em>target</em>    直接用求根公式</p><ul><li>判别式 b^2-4ac 开根需要为整数</li><li>最后的求根公式的分子需要为偶数，因为分母为 2</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] findContinuousSequence(<span class="hljs-type">int</span> target) &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, limit = (target - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// (target - 1) / 2 等效于 target / 2 下取整</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= limit; ++x) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> - <span class="hljs-number">4</span> * (x - (<span class="hljs-type">long</span>) x * x - <span class="hljs-number">2</span> * target);<br>            <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">delta_sqrt</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(delta + <span class="hljs-number">0.5</span>);<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) delta_sqrt * delta_sqrt == delta &amp;&amp; (delta_sqrt - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (-<span class="hljs-number">1</span> + delta_sqrt) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 另一个解(-1-delta_sqrt)/2必然小于0，不用考虑</span><br>                <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>                    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[y - x + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> x; i &lt;= y; ++i) &#123;<br>                        res[i - x] = i;<br>                    &#125;<br>                    vec.add(res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[vec.size()][]);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 5, m = 3</span><br><span class="hljs-section">输出: 3</span><br><br><span class="hljs-section">输入: n = 10, m = 17</span><br><span class="hljs-section">输出: 2</span><br><br>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6<br></code></pre></div></td></tr></table></figure><p><strong>方法一：数学 + 递归</strong></p><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，需要求解的函数值有 n 个。</li><li>空间复杂度：<em>O</em>(<em>n</em>)，函数的递归深度为 n<em>，需要使用 O</em>(n) 的栈空间。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">一个人的时候: 这个活着的人的下标是<span class="hljs-number">0.</span> 所以需要知道当两个人存在的时候,这个人的下标是多少;<br><br>两个人的时候: 这个活着的人下标:<span class="hljs-comment">(0+3)</span><span class="hljs-meta">%</span><span class="hljs-number">2</span>=<span class="hljs-number">1</span> 所以需要知道当三个人存在的时候 ,这个人的下标是多少;<br><br>三个人的时候: 这个活着的人下标:<span class="hljs-comment">(1+3)</span><span class="hljs-meta">%</span><span class="hljs-number">3</span>=<span class="hljs-number">1</span> 所以需要知道当四个人存在的时候 ,这个人的下标是多少;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">return</span> f(n, m);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(n - <span class="hljs-number">1</span>, m);<br>        <span class="hljs-keyword">return</span> (m + x) % n;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二：数学 + 迭代</strong></p><ul><li>时间复杂度：O(n)，需要求解的函数值有 n 个。</li><li>空间复杂度：O(1)，只使用常数个变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i != n + <span class="hljs-number">1</span>; ++i) &#123;<br>            f = (m + f) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟（中等）"><a href="#模拟（中等）" class="headerlink" title="模拟（中等）"></a>模拟（中等）</h2><h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br><br>输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,6,7,8]</span>,<span class="hljs-comment">[9,10,11,12]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><br>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix<span class="hljs-comment">[i]</span>.length &lt;= 100<br></code></pre></div></td></tr></table></figure><p>矩阵 左、右、上、下 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> ，用于打印的结果列表 <code>res</code> 。</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">时间复杂度 <span class="hljs-built_in">O</span>(MN)： M, NM,N 分别为矩阵行数和列数。<br><br>空间复杂度 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) ： 四个边界 l , r , t , <span class="hljs-selector-tag">b</span> 使用常数大小的 额外 空间（ res 为必须使用的空间）。<br></code></pre></div></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-literal">null</span> ||matrix.length == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> , t = <span class="hljs-number">0</span> , b = matrix.length - <span class="hljs-number">1</span>; <br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ (b+<span class="hljs-number">1</span>)*(r+<span class="hljs-number">1</span>) ];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r ; i++)res[x++] = matrix[t][i];<br>            <span class="hljs-keyword">if</span>(t++ &gt;= b)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> t; i &lt;= b ; i++)res[x++] = matrix[i][r];<br>            <span class="hljs-keyword">if</span>(r-- &lt;= l)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r; i &gt;= l ; i--)res[x++] = matrix[b][i];<br>            <span class="hljs-keyword">if</span>(b-- &lt;= t)<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b; i &gt;= t ; i--)res[x++] = matrix[i][l];<br>            <span class="hljs-keyword">if</span>(l++ &gt;= r)<span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：我们可以按以下顺序执行：<br>push(<span class="hljs-number">1</span>), push(<span class="hljs-number">2</span>), push(<span class="hljs-number">3</span>), push(<span class="hljs-number">4</span>), pop() -&gt; <span class="hljs-number">4</span>,<br>push(<span class="hljs-number">5</span>), pop() -&gt; <span class="hljs-number">5</span>, pop() -&gt; <span class="hljs-number">3</span>, pop() -&gt; <span class="hljs-number">2</span>, pop() -&gt; <span class="hljs-number">1</span><br><br>输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">1</span> 不能在 <span class="hljs-number">2</span> 之前弹出。<br><br><span class="hljs-number">0</span> &lt;= pushed.length == popped.length &lt;= <span class="hljs-number">1000</span><br><span class="hljs-number">0</span> &lt;= pushed[i], popped[i] &lt; <span class="hljs-number">1000</span><br>pushed 是 popped 的排列。<br></code></pre></div></td></tr></table></figure><p>时间复杂度 O(N)： 其中 NN 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。</p><p>空间复杂度 O(N)： 辅助栈 stack 最多同时存储 N 个元素。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> nums : pushed)&#123;<br>            stack.push(nums);<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;<br>                stack.pop();<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="字符串（中等）"><a href="#字符串（中等）" class="headerlink" title="字符串（中等）"></a>字符串（中等）</h2><h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p>小数（按顺序）可以分成以下几个部分：</p><ol><li><p>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</p></li><li><p>下述格式之一：</p><ol><li><p>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></p></li><li><p>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</p></li><li><p>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</p></li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[<span class="hljs-string">&quot;+100&quot;</span>, <span class="hljs-string">&quot;5e2&quot;</span>, <span class="hljs-string">&quot;-123&quot;</span>, <span class="hljs-string">&quot;3.1416&quot;</span>, <span class="hljs-string">&quot;-1E-16&quot;</span>, <span class="hljs-string">&quot;0123&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><p>部分<strong>非数值</strong>列举如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[<span class="hljs-string">&quot;12e&quot;</span>, <span class="hljs-string">&quot;1a3.14&quot;</span>, <span class="hljs-string">&quot;1.2.3&quot;</span>, <span class="hljs-string">&quot;+-5&quot;</span>, <span class="hljs-string">&quot;12e+5.4&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br><br>输入：s = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br><br>输入：s = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br><br>输入：s = <span class="hljs-string">&quot;    .1  &quot;</span><br>输出：<span class="hljs-literal">true</span><br><br><span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">20</span><br>s 仅含英文字母（大写和小写），数字（<span class="hljs-number">0</span><span class="hljs-number">-9</span>），加号 <span class="hljs-string">&#x27;+&#x27;</span> ，减号 <span class="hljs-string">&#x27;-&#x27;</span> ，空格 <span class="hljs-string">&#x27; &#x27;</span> 或者点 <span class="hljs-string">&#x27;.&#x27;</span> 。<br></code></pre></div></td></tr></table></figure><h1 id="二、力扣热题-HOT-100"><a href="#二、力扣热题-HOT-100" class="headerlink" title="二、力扣热题 HOT 100"></a>二、力扣热题 HOT 100</h1><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br><br>输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br><br>输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></div></td></tr></table></figure><p><strong>解题思路：</strong></p><p><strong>1.暴力穷举</strong></p><p><strong>2.利用哈希表，每次查找一下当前值和哈希表是否重复，不重复存储target-当前值和下标值</strong></p><p><strong>代码</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    Map&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt; map = <span class="hljs-built_in">new</span> HashMap&lt;<span class="hljs-type">Integer</span>,<span class="hljs-type">Integer</span>&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>    <span class="hljs-keyword">if</span>(map.containsKey(target-nums[i]))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;map.<span class="hljs-keyword">get</span>(target-nums[i]),i&#125;;<br>    &#125;<br>    map.put(nums[i],i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试高频问题</title>
    <link href="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h2><h4 id="1-JAVA基础、字符串、哈希、"><a href="#1-JAVA基础、字符串、哈希、" class="headerlink" title="1.JAVA基础、字符串、哈希、"></a>1.JAVA基础、字符串、哈希、</h4><h6 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h6><p>思维不同，面向过程：一个个方法的执行解决问题。面向用对象执行方法的方式解决问题。程序更易维护、易复用、易扩展。</p><h6 id="多态的特点"><a href="#多态的特点" class="headerlink" title="多态的特点"></a>多态的特点</h6><p>父类的引用指向子类的实例。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">在程序运行期间确定引用类型使用的哪个方法，<br>对象类型和引用类型之间具有继承（类）/实现（接口）的关系<br>多态不能调用“只在子类存在但在父类不存在”的方法<br>子类重新方法，执行子，没重写，执行父<br></code></pre></div></td></tr></table></figure><h6 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h6><p>1.简单易学  2.面向对象（封装，继承，多态） 3.跨平台  4.支持多线程  5.支持多线程  6.可靠性  7.安全性（指针）8.支持网络编程并且很方便   9.编译与解释并存</p><p>实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！</p><h6 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h6><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.指针访问内存程序内存更加安全<br><span class="hljs-number">2</span>.<span class="hljs-keyword">Java </span>的类是单继承的，C++ 支持多重继承；虽然 <span class="hljs-keyword">Java </span>的类不可以多继承，但是接口可以多继承。<br><span class="hljs-number">3</span>.<span class="hljs-keyword">Java </span>有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。<br><span class="hljs-number">4</span>.C ++同时支持方法重载和操作符重载，但是 <span class="hljs-keyword">Java </span>只支持方法重载（操作符重载增加了复杂性，这与 <span class="hljs-keyword">Java </span>最初的设计思想不符）。<br></code></pre></div></td></tr></table></figure><h6 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h6><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java </span>虚拟机（<span class="hljs-keyword">JVM）：JVM </span>有针对不同系统的特定实现，保证相同的字节码有相同的结果。一次编译，随处可以运行”的关键所在。<br><span class="hljs-keyword">JDK </span>：是 <span class="hljs-keyword">Java </span>Development Kit 缩写，它拥有 <span class="hljs-keyword">JRE </span>所拥有的一切，还有编译器（<span class="hljs-keyword">javac）和工具（如 </span><span class="hljs-keyword">javadoc </span>和 <span class="hljs-keyword">jdb）。它能够创建和编译程序。</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JRE </span>：是 <span class="hljs-keyword">Java </span>运行时环境。包括 <span class="hljs-keyword">Java </span>虚拟机（<span class="hljs-keyword">JVM），Java </span>类库，<span class="hljs-keyword">java </span>命令和其他的一些基础构件。但是，它不能用于创建新程序。<br></code></pre></div></td></tr></table></figure><h6 id="采用字节码的好处是什么"><a href="#采用字节码的好处是什么" class="headerlink" title="采用字节码的好处是什么?"></a>采用字节码的好处是什么?</h6><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h6 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h6><ul><li>编译型 ：会通过编译器将源代码一次性翻译成可被该平台执行的机器码。编译语言的执行速度比较快，开发效率比较低。常见的比如 C、C++、Go、Rust </li><li>解释型 ：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。比如 Python、JavaScript、PHP 。</li></ul><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h6 id="Java-中的几种基本数据类型了解么？"><a href="#Java-中的几种基本数据类型了解么？" class="headerlink" title="Java 中的几种基本数据类型了解么？"></a>Java 中的几种基本数据类型了解么？</h6><table><thead><tr><th align="left">基本类型</th><th align="left">位数</th><th align="left">字节</th><th align="left">默认值</th><th>取值范围</th></tr></thead><tbody><tr><td align="left"><code>byte</code></td><td align="left">8</td><td align="left">1</td><td align="left">0</td><td>-128 ~ 127</td></tr><tr><td align="left"><code>short</code></td><td align="left">16</td><td align="left">2</td><td align="left">0</td><td>-32768 ~ 32767</td></tr><tr><td align="left"><code>int</code></td><td align="left">32</td><td align="left">4</td><td align="left">0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td align="left"><code>long</code></td><td align="left">64</td><td align="left">8</td><td align="left">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td align="left"><code>char</code></td><td align="left">16</td><td align="left">2</td><td align="left">‘u0000’</td><td>0 ~ 65535</td></tr><tr><td align="left"><code>float</code></td><td align="left">32</td><td align="left">4</td><td align="left">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td align="left"><code>double</code></td><td align="left">64</td><td align="left">8</td><td align="left">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td align="left"><code>boolean</code></td><td align="left">1</td><td align="left"></td><td align="left">false</td><td>true、false</td></tr></tbody></table><h6 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h6><ul><li>默认值：包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>泛型：包装类型可用于泛型，而基本类型不可以。</li><li>存储地方：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>占用空间：相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><h6 id="包装类型的常量池技术了解么？"><a href="#包装类型的常量池技术了解么？" class="headerlink" title="包装类型的常量池技术了解么？"></a>包装类型的常量池技术了解么？</h6><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>，创建时如果有，会直接复用堆上的对象。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p><p>所有整型包装类对象之间值的比较，全部使用 equals 方法比较，但是-128 至 127之间的可以直接用&#x3D;&#x3D;。</p><h6 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h6><ul><li>语法形式 ：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，局部变量不能被 <code>static</code> 和权限所修饰；但都能被 <code>final</code> 所修饰。</li><li>存储方式 ：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h6 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a>对象的相等与指向他们的引用相等,两者有什么不同?</h6><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h6 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h6><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h6 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h6><p><strong>共同点</strong> ：</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">都不能被实例化。<br>都可以包含抽象方法。<br>都可以有默认实现的方法（Java <span class="hljs-number">8</span> 可以用 `default` 关键在接口中定义默认方法）。<br></code></pre></div></td></tr></table></figure><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h6 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h6><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br>    <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><br>     <span class="hljs-comment">// 唤醒 下边五个native方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br>    <span class="hljs-comment">//等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException <span class="hljs-comment">//多加nanos</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br>     <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></div></td></tr></table></figure><h6 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h6><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p>加入对象，先判断哈希值，相等才会去调用equal判断是否相等，提升效率</p><h6 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h6><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法</p><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的</p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><h6 id="Java-9-为何要将-String-的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将-String-的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将 String 的底层实现由 char[] 改成了 byte[] ?"></a><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></h6><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><h6 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h6><p>“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。</p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p><h6 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h6><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p>JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p><h6 id="String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h6><p>会创建 1 或 2 个字符串：</p><p>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</p><p>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</p><h4 id="2-JAVA反射、序列化、IO"><a href="#2-JAVA反射、序列化、IO" class="headerlink" title="2.JAVA反射、序列化、IO"></a>2.JAVA反射、序列化、IO</h4><h6 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h6><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h6 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h6><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h6 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h6><p><code>Annotation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h6 id="何为反射？"><a href="#何为反射？" class="headerlink" title="何为反射？"></a>何为反射？</h6><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li></ul><h6 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h6><p>Java 提供了四种方式获取 Class 对象:</p><p><strong>1. 知道具体类的情况下可以使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></div></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p><p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></div></td></tr></table></figure><p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></div></td></tr></table></figure><p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ClassLoader.loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p><h6 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h6><p>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作</p><p><strong>静态代理</strong></p><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*)。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>动态代理</p><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><h6 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a><strong>JDK 动态代理机制</strong></h6><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p> JDK 动态代理类使用步骤</p><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h6 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h6><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</p><p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p><p>CGLIB 通过继承方式实现代理。例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p><strong>CGLIB 动态代理类使用步骤</strong></p><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>proxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是<code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h6 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h6><ol><li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h6 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h6><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h6 id="何为-I-x2F-O"><a href="#何为-I-x2F-O" class="headerlink" title="何为 I&#x2F;O?"></a>何为 I&#x2F;O?</h6><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p><strong>我们再先从应用程序的角度来解读一下 I&#x2F;O。</strong></p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p><ol><li>内核等待 I&#x2F;O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h6 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h6><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p><h6 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h6><p>**BIO (Blocking I&#x2F;O)<strong>同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量</p><p><strong>NIO (Non-blocking&#x2F;New I&#x2F;O)</strong></p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> </p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><strong>AIO (Asynchronous I&#x2F;O)</strong></p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><h6 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a>BigDecimal 详解</h6><p>十进制整数在转化成二进制数时不会有精度问题，那么把十进制小数扩大N倍让它在整数的维度上进行计算，并保留相应的精度信息。</p><p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加，<code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减。<code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘，<code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除。</p><h4 id="3-集合、容器、扩容"><a href="#3-集合、容器、扩容" class="headerlink" title="3.集合、容器、扩容"></a>3.集合、容器、扩容</h4><h6 id="都有哪些集合"><a href="#都有哪些集合" class="headerlink" title="都有哪些集合"></a>都有哪些集合</h6><p><img src="https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png" alt="img"></p><p><strong>List</strong></p><ul><li><code>Arraylist</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环</li></ul><p><strong>Set</strong></p><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树</li></ul><p><strong>Queue</strong></p><ul><li><p>PriorityQueue<code>: </code>Object[]&#96; 数组来实现二叉堆</p></li><li><p><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</p><h6 id><a href="#" class="headerlink" title></a></h6></li></ul><p><strong>Map</strong></p><ul><li><p><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p></li><li><p><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p></li><li><p><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p></li><li><p><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</p></li></ul><h6 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h6><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的</li></ul><h6 id="Arraylist扩容"><a href="#Arraylist扩容" class="headerlink" title="Arraylist扩容"></a>Arraylist扩容</h6><ul><li>new 出来时候elementData.length 为 0 ，add时，取默认和传入参数最大值，所以 minCapacity 此时为 10。此时判断是否扩容条件，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)</li></ul><h6 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h6><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ol><h6 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h6><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h6 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h6><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h6 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h6><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h6 id="为什么hashMap引入了红黑树而不是其他结构"><a href="#为什么hashMap引入了红黑树而不是其他结构" class="headerlink" title="为什么hashMap引入了红黑树而不是其他结构"></a>为什么hashMap引入了红黑树而不是其他结构</h6><p>1.为什么不是二叉排序树(又称二叉查找树) （左子树上所有结点的值均小于根结点，右字数大于根节点）</p><p>在二叉排序树在添加元素的时候极端情况下会出现线性结构，如果我们添加的元素都比根节点小。会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷</p><p>2.平衡二叉树(AVL树)当且仅当两个子树的高度差不超过1时</p><p>红黑树不追求完全平衡，部分达到平衡即可，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而平衡二叉树是严格平衡树，因此在增加或者删除节点的时候，旋转的次数比红黑树要多。时间复杂度<em>O(logN)</em>    <em>O(1)</em></p><p>但是，search要比红黑树效率高，因为他相差 &lt;&#x3D;1 </p><h6 id="HashMap为什么是8"><a href="#HashMap为什么是8" class="headerlink" title="HashMap为什么是8"></a>HashMap为什么是8</h6><p>当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于等于64，就会把链表转换为红黑树。小于等于6会退化成链表，如果 hash 计算的结果离散好，链表长度符合泊松分布，也就是长度为 8 的概率，小于千万分之一概率，把长度 8 作为转化的默认阈值**。</p><p><strong>为什么用链表</strong>：最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题</p><h6 id="为什么HashMap扩容是2的次幂"><a href="#为什么HashMap扩容是2的次幂" class="headerlink" title="为什么HashMap扩容是2的次幂"></a>为什么HashMap扩容是2的次幂</h6><p>Hash 值的范围值-2147483648 到 2147483647，内存是放不下的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方，这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><h6 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h6><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><h6 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h6><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h6 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h6><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组+链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，要相对Segment里边的HashEntry修改，就需要先获得对应的 <code>Segment</code> 的锁。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h1 id="二、计算机"><a href="#二、计算机" class="headerlink" title="二、计算机"></a>二、计算机</h1><h2 id="1、计算机网络"><a href="#1、计算机网络" class="headerlink" title="1、计算机网络"></a>1、计算机网络</h2><h3 id="OSI-和-TCP-x2F-IP-网络分层模型详解（基础）"><a href="#OSI-和-TCP-x2F-IP-网络分层模型详解（基础）" class="headerlink" title="OSI 和 TCP&#x2F;IP 网络分层模型详解（基础）"></a>OSI 和 TCP&#x2F;IP 网络分层模型详解（基础）</h3><h5 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="osi七层模型"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="img"></p><p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP&#x2F;IP 四 层模型呢？</strong></p><p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p><ol><li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li><li>OSI 的协议实现起来过分复杂，而且运行效率很低</li><li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP&#x2F;IP 的互联网已经抢先在全球相当大的范围成功运行了）</li><li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li></ol><p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p><p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p><p><img src="https://javaguide.cn/assets/osi-model-detail.69f69153.png" alt="img"></p><h5 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h5><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><p> <img src="https://javaguide.cn/assets/TCP-IP-4-model.6ae180f1.png" alt="TCP-IP-4-model"></p><h6 id="应用层（Application-layer）"><a href="#应用层（Application-layer）" class="headerlink" title="应用层（Application layer）"></a><strong>应用层（Application layer）</strong></h6><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><p><img src="https://javaguide.cn/assets/application-layer.a60c27d2.png" alt="application-layer"></p><h6 id="传输层（Transport-layer）"><a href="#传输层（Transport-layer）" class="headerlink" title="传输层（Transport layer）"></a><strong>传输层（Transport layer）</strong></h6><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠 的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><img src="https://javaguide.cn/assets/transport-layer.3d064ed5.png" alt="transport-layer"></p><h6 id="网络层（Network-layer）"><a href="#网络层（Network-layer）" class="headerlink" title="网络层（Network layer）"></a>网络层（Network layer）</h6><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p><p>注意 ⚠️：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。</strong></p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p><p><img src="https://javaguide.cn/assets/nerwork-layer.688b8282.png" alt="img"></p><h6 id="网络接口层（Network-interface-layer）"><a href="#网络接口层（Network-interface-layer）" class="headerlink" title="网络接口层（Network interface layer）"></a>网络接口层（Network interface layer）</h6><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><p><img src="https://javaguide.cn/assets/network-interface-layer.c1c4efcc.png" alt="network-interface-layer"></p><h5 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h5><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><h3 id="HTTP-vs-HTTPS（应用层）"><a href="#HTTP-vs-HTTPS（应用层）" class="headerlink" title="HTTP vs HTTPS（应用层）"></a>HTTP vs HTTPS（应用层）</h3><h5 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h5><h6 id="HTTP-协议介绍"><a href="#HTTP-协议介绍" class="headerlink" title="HTTP 协议介绍"></a><strong>HTTP 协议介绍</strong></h6><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p><h6 id="HTTP-协议通信过程"><a href="#HTTP-协议通信过程" class="headerlink" title="HTTP 协议通信过程"></a>HTTP 协议通信过程</h6><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接</li></ol><h6 id="HTTP-协议优点"><a href="#HTTP-协议优点" class="headerlink" title="HTTP 协议优点"></a>HTTP 协议优点</h6><p>扩展性强、速度快、跨平台支持性好。</p><h5 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h5><h6 id="HTTPS-协议介绍"><a href="#HTTPS-协议介绍" class="headerlink" title="HTTPS 协议介绍"></a>HTTPS 协议介绍</h6><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。默认端口号是 443.</p><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><h6 id="HTTPS-协议优点"><a href="#HTTPS-协议优点" class="headerlink" title="HTTPS 协议优点"></a>HTTPS 协议优点</h6><p>保密性好、信任度高</p><h5 id="SSL-x2F-TLS协议（HTTPS-的核心）"><a href="#SSL-x2F-TLS协议（HTTPS-的核心）" class="headerlink" title="SSL&#x2F;TLS协议（HTTPS 的核心）"></a>SSL&#x2F;TLS协议（HTTPS 的核心）</h5><h6 id="SSL-和-TLS-的区别？"><a href="#SSL-和-TLS-的区别？" class="headerlink" title="SSL 和 TLS 的区别？"></a>SSL 和 TLS 的区别？</h6><p><strong>SSL 和 TLS 没有太大的区别。</strong></p><p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p><h6 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a>HTTPS通信流程</h6><p>1）TCP三次握手后，客户端发起一个http请求，告诉服务器自己支持哪些hash算法，并生成一个随机数给客户端。</p><p>2）服务端把确认自己支持的TLS版本以及选择的加密套件，并且服务器也生成一个随机数给客户端，</p><p>3）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。</p><p>3）验证证书的合法性</p><p>客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。</p><p>4）生成随机密码（RSA签名）</p><p>浏览器会生成第三个随机数，预主密钥，用收到的公钥加密，发给服务器。让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。</p><p>5）生成对称加密算法</p><p>之后，服务端用第一随机数，第二随机数加预主密钥生成会话密钥，客户端也是</p><h6 id="SSL-x2F-TLS-的工作原理"><a href="#SSL-x2F-TLS-的工作原理" class="headerlink" title="SSL&#x2F;TLS 的工作原理"></a>SSL&#x2F;TLS 的工作原理</h6><p><strong>非对称加密</strong></p><p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，<strong>私钥</strong>仅由<strong>解密者保存</strong>，<strong>公钥</strong>由任何一个想与解密者通信的<strong>发送者</strong>（加密者）所知。可以设想一个场景，</p><p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p><blockquote><p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y&#x3D;f(x)；而给定一个输出 y，假设存在 f(x)&#x3D;y，很难根据 f 来计算出 x。</p><p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y&#x3D;f(x;h)；而给定一个输出 y，假设存在 f(x;h)&#x3D;y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p></blockquote><p><strong>对称加密</strong></p><p>使用 SSL&#x2F;TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL&#x2F;TLS 实际对消息的加密使用的是对称加密。</p><p>对称加密的密钥生成代价比公私钥对的生成代价低得多，为什么 <strong>SSL&#x2F;TLS 还需要使用非对称加密</strong>呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p><p><strong>公钥传输的信赖性</strong></p><blockquote><p>客户端 C 和服务器 S 想要使用 SSL&#x2F;TLS 通信，由上述 SSL&#x2F;TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p><ol><li>任何人都可以捕获通信包</li><li>通信包的保密性由发送者设计</li><li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li></ol><p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p><p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p></blockquote><p>第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。</p><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p><p><strong>数字签名</strong></p><p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p><blockquote><p>CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p><p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p><p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p></blockquote><p>注意，验证身份的证书一定是由 CA 的公钥进行签名，而不能由发送者自己来签名。这是为了抵抗以下的攻击场景：</p><blockquote><p>攻击者使用某种手段，欺骗了客户端，将服务器的公钥替换为攻击者的诱饵公钥。</p><p>假使证书的签名使用的是服务器的私钥，那么客户端在解码的时候，将会使用假的服务器公钥（实则为诱饵公钥）。那么，如果该证书实则由攻击者（使用自己的私钥签名）发出，那么客户端就会成功验证（攻击者的）身份为真，从而信赖了证书中的公钥。</p><p>如果使用 CA 的私钥和公钥来对签名处理，则不会出现上述问题。</p></blockquote><p>总结来说，带有证书的公钥传输机制如下：</p><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书山的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ul><h3 id="HTTP-1-0-vs-HTTP-1-1（应用层）"><a href="#HTTP-1-0-vs-HTTP-1-1（应用层）" class="headerlink" title="HTTP 1.0 vs HTTP 1.1（应用层）"></a>HTTP 1.0 vs HTTP 1.1（应用层）</h3><p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p><ul><li>响应状态码</li><li>缓存处理</li><li>连接方式</li><li>Host头处理</li><li>带宽优化</li></ul><h5 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h5><p>HTTP&#x2F;1.0仅定义了16种状态码。HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p><h5 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h5><p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p><h6 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h6><p>HTTP&#x2F;1.0提供的缓存机制非常简单。服务器端使用<code>Expires</code>标签来标志（时间）一个响应体，在<code>Expires</code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个<code>Last-Modified</code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用<code>If-Modified-Since</code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之前，我要请求的资源是否有被修改过？”通常情况下，请求头中的<code>If-Modified-Since</code>的值即为上一次获得该资源时，响应体中的<code>Last-Modified</code>的值。</p><p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p><p>如果服务器判断<code>If-Modified-Since</code>时间后，资源被修改过，则返回给客户端一个<code>200 OK</code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p><h6 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h6><p>HTTP&#x2F;1.1的缓存机制在HTTP&#x2F;1.0的基础上，大大增加了灵活性和扩展性。基本工作原理和HTTP&#x2F;1.0保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code></p><h5 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h5><p><strong>HTTP&#x2F;1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个TCP连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p><p><strong>为了解决 HTTP&#x2F;1.0 存在的资源浪费的问题， HTTP&#x2F;1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p><p>有必要说明的是，HTTP&#x2F;1.0仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在HTTP&#x2F;1.1中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p><p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p><h5 id="Host头处理"><a href="#Host头处理" class="headerlink" title="Host头处理"></a>Host头处理</h5><p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP&#x2F;1.0并没有考虑这个问题，假设我们有一个资源URL是<a href="http://example1.org/home.html%EF%BC%8CHTTP/1.0%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%AD%EF%BC%8C%E5%B0%86%E4%BC%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E6%98%AF%60GET">http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是`GET</a> &#x2F;home.html HTTP&#x2F;1.0&#96;.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p><p>因此，HTTP&#x2F;1.1在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">GET /home.html HTTP/1.1<br>Host: example1.org<br></code></pre></div></td></tr></table></figure><p>服务器端就可以确定客户端想要请求的真正的网址了。</p><h5 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h5><h6 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h6><p>HTTP&#x2F;1.1引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP&#x2F;1.1可以在请求中加入<code>Range</code>头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略<code>Range</code>头部，也可以返回若干<code>Range</code>响应。</p><p>如果一个响应包含部分数据的话，那么将带有<code>206 (Partial Content)</code>状态码。该状态码的意义在于避免了HTTP&#x2F;1.0代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。</p><p>在范围响应中，<code>Content-Range</code>头部标志指示出了该数据块的偏移量和数据块的长度。</p><h6 id="状态码100"><a href="#状态码100" class="headerlink" title="状态码100"></a>状态码100</h6><p>HTTP&#x2F;1.1中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYUAAADSCAMAAACSASyBAAAA8FBMVEX///8AAADg4OAfHx+enp7nplIAgsb/46Wl4////8ZeXl5SpufG//+goKAAVaViYmLGggD/x4SEx//n/////+elVQCEAAAcHBwAAISjo6OhoaFSAFJSAAAAAFJSAISEAFIGBgbAwMA8PDyEAISlVVLv7+8WFhZSpsjn46VSVaXnx4R+fn43Nzfn4//n/+fG/8bG46XGx4TGglKl4+eEx+cAgqWZh5HGgoSlVYSlggCEggBSVQDn5Of/4+fXzcyP0cZSgsalyqVSgoQAVVLnx6WEpqXnpoTGplJRUlHGx//G/+eEpufn/8aEVaWlpoSEglIrcn0nAAAL50lEQVR42uydCZfSMBDHG7XZYlDTCiwqqOt93/d969Pn8/t/G2emSdoKcgguYfv/PWFb2uJzfpmkTd1pAgAAAAAAAAAAAAAAAAAAAAAAAAAA/ifWJE12znbDcmr8wvGTCahj1xmR3hdl/rAw0tXymSxJ8mGXLbTXRKoI0xmoEglPrkwzaIoYdsuf42yJ725ShA3jrG4cFugf3uuThcJ3HhL1gK41V/opK8t8d9IZeKPyd1jlEbFl9wQLDQu0xNGSViur42xFC53BOGtY0Ekg9+mlc+WABcmCgl7HT+6MypwYdlfqkcRoveFPWPCLbR+hU0WIBcsLnA4SvfHbgeKlVXIhyUPzTjm9Ji1QfyUy2k7Ihck2/Ed0rKGPl2qsMspbin/O3zXNAq+nx28owWVaG/EWQsdcDQwpiwiDdYVJlkCOr3xaVaMck0sx7U4Jb+GtZIPVIWZCHlrnzuhqnxQtS67YaMp63fDfyAV+We23tBdv4RFHoeqYUv3HbhRG7o+WHXJ0LSNIbzPWMuY87Jtev3ZJ0UrC6Czn69Q6OSQVrp268NhlTyXzRo8fNFdIEpKbcmzqDNpqwY/O8se31PpVnK2P07mYWRjp7KsTLXmvEMEfzmSwECxQxF6EmNnQja9yvTBpgRNuchdYsDpxFqjfKXwDHXbdQrHS9ULTglid1mk9brsFjouzYMcvy5ZqQ5+TrzKDMTku8Lgz7bKu9blAcXYWLF9DqYJeJpzZ0+IaeyRJrUmqFLGtvWjTnQH92+lN8mDyZHQyF9oZKAAAAAAAAAAAAAAAAAAAbAUntpnkoLB7dHs5nBwUdk8l28oRWIgAWIgBWIgBWIgBWIgBWIgBWIgBWIgBWIgBWIgBWIgBWIgBWIgBWPgHdt5NqaeV6sTq6pdhaAUWZpb/KQNlVUmo6DDO0lq1AlvQW+dc1ohzyevnuqpwMOz6rb3btvzyV1ZpWFjMQv03eXt9EzZKqZukc7ErVVYqC6kKce1dylwuVIVsgsryswIWVrMgzTjnl/rIO/jiTy91UmGVwzQypZJjDSysbCE19GEhOwg510EJ1SF0Ldy8rysrJ5XMep9GqoCFVS3kqvB9TmVB5FQjRKoCBR2tyw4rV1dvh1+Nh4X5JRKnW3BxpS3XT8604MuLyg8ZxNPHfR4UPLCwWi4IuU7mWBhVNuULlKYhWZaagzUs/LsFWyQL5wJhx5mYqdo/KUEurGRBzlOXyAWrCv7M/xZ+qE7UGgtv1m0hXB3PtpB/DrkgrV4sVAV4c8WVNWl5Xy28STbE3uFj/8NCaiZK0zQsKN3okZyFarPEX6qc7qeFmxf2ks1wS+0e29d5JHFWcPjlqllXBQNDX2QqHyR7/yxcPq825GFPqfO7xzCnKtxUm/JwS4kHWCiTYb0eXp1ekJuKYA/bbOHK6fXwTam1etg7vCC7quTwlS22cP7weriinIZDyf5y87ykwhH0SMStFVJhta5QHCwyOudFXrg5UcNTpCZMN4R61bPuosnpbfPctH58EYGFvQ04EG46B/Mt9J51H2QcNonl9TufRjpMWnPY599Fe8X3f1JVwgqO3+kXlZdJxNy9M9l+WbilNnOKdPkKO1jMwpOTT93TTGTOlKd66FWfeZt/F02OzrmOpWTSo36Rzqnp/rT7Zb8s7LGDTXCEHCxqoX+1b7wFevMTRi4XeHp69l00OfZXxnIK6pz40B5Z0E7bdDo/7zzr7te1816ycRYanXPVoGhamHcXrT/8fpssGZm1e/11nPVCLshnPKuayo224V23mpudHwd+Nm9ZCy4XwqRps0eafRetXlGZp+pI350qFzjksrsddvNx5lbbMaf6TxbuDsYPL2U8BrANN6fHuTDnLlrljNeZWi7QsVx5nHf6MDKJW4WF6aTunkDRGTy+HbqfRe6ihQwSOXKg/+n3LPy0tlttyf2FJS1wP8GNXGToyWFizl00sZBqsSBvtBNllDW2KDPFiEkRKKuw8De8hUJmqH1/RBcE8++iiQVrRIB8EQ3stNWWZu3w/jgrH4ajE7cKCzMspGr8Us6KyAQH/N5IL3AXjS1wE9d+DOn1Of7sJddSCd7ylQSLLPwqLPzNgjuLLPjSjUkVoRe4iyZdmHG9GQWfIv0gK7PjwfuR4ZTRdIrEyvwqLEzDSgT9dFLtgQW5Gmcz76I1HnaTK035YI07MJbZvM2DOdUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUYgIUY2D11aFs5SBbU9nJwLBzaZhIAAAAAAAAAAAAAAAAAAIC2cmSbSQ4Ku4e3mOSggP+DEQOwEAOwEAOwEAOwEANxWKCKALCwAaTiW0U67MLCgrhyL1zUZaRKHvWVwEWpqjJVZcWSVM9o7bYIhTUqDCwsYyE8WcHXrZWNoWRSahoPzKs/SY9l6TxUxOUyJhgX1m5h54zU1ms+ME+epBeSItWuO8qDBWvkC2BhfRZ8vVW/Q3iS3nQL98hDqmltnMHCGizINopsrhO3Q+BPC9dG/ERWsXB3UPBX8JNlYGEhC6pkugXf1Se2mG+ByuexBR7IreHN5BbjwjpyoXp47cIWuFeiJKCDaQMsrM8CN+8lLEgVUPpK0gELa7SQmmTxccEaOdJqa3Cmuk4LD7JZFgZKlbkg50jlSa0RO7CwPgtVRWer3Ubib2eqsuSWYeF3e2fb2zQMxPG4yFZXl8qJNuiERDukDSQepjFpG294wwtAQnz/j8P9L2eracrWdM3kdPdX18Wpkxf3y/n8FN1TSkwejHE0koBzRDmlMDQphRykFHKQUshBSiEHZU/h/LlROC+y09m7UU8U0Ou/T0e/VwrfOwwAgnsMhdEku82SZ5/MpJ8WCSs344dHdSI765+CMDCvi7xEDIwZ9UTB/niTHQVisDR5uQIzWE76ic6SXXMtwZ2YH8v++JYMPa6wSITBJPBlV5b2SxkkB9So/8++uYIvdJ0oCANzUWQkMIDORtvr4rTLLBLiQivBnUwsBYca+IOhKzZ+pIDJJLpWIKASXYvf6T6WfuMUe5zVxHWhUDMwy5vRfnS+l0S1O2i5PYXg2JLtBHcwauQUgTUpwNJRwaVAD3yoytYPXs5un+vc7Fkf99M3Msv+fEGe53aCu5RUTyhwAqsmBbRVDEr8Js21WodbAg1fhTaquy+YnHxBOPQVF4Jh+Y0J7lBAYKhw4Fq+UIPybQohURB/Gn5cEA799ZHgC/9LcAfL0wfWRZVEIaXWQ+GeFok+h9JHEg6TPim0E9xxXID5yag4DX9gHIjEVJfjQnQCVACKVnRGXRQOYbzQ/9i5neAOz76kGDZkcd696moUVJj9xOoy904391St9FRxfj49kLGzziMNTwdCYeBSCjlIKeQgpZCDnp4CNkQqhUdTwBTF7M9iLJuKVuVrG5fru4tsOoyv+4gsj7OVwmkH43saL1hMEvG+7NHJfNo2LFNAiU3f3MQteEQ8Zq7SOgQdfDnxSmErCmw6MWxwzZVQcY35Fb7jWoO3JhYFTxLKaWtepRS2EXYzLoQCvhp80rEle0ZfgGMELz5hhQIujdyCxydtXy2CUnhQX8fHd5evzKqcWD4940c3by8Xfw1rAwXZLC8TRqWp6F0HEIBblb6wlVLY3ifkfeUUCq54Jzx0i3cF132hBJKawgesmYKESwsUoKDReQcKwXiLB9qLEbEFni1a+kYfSSjQz7am4ICw5JUIYALK4OgGBEYpdBEibgWDFmF+LaubZOZ6fvV2utJHalOwTtZNUev4bhoqFIgC3UQpdHEE6slUDCOuuPkUdXEC9o1qU/CoSiZHoW7WrJO4oBS6gRAK/GxjL4xQQBGLZ4txcPJKTzMu8JX8Tu37k0oogAD94bRS6EgBnvALMRbmFAoQN/mL688B7T8do/WqfQGIAIYbMNARChjucXQOTil0jc713iEZEwsFAcQ25e/gmz1VfFjpIGgfaTcKpSxLckdz46uBoT2JhLoGbRWcI8qDAqrTbZTCUKUUcpBSyEFKIQcphRykFHLQIVF4MWAVh6KXQ1ahUqlUKpVKpVKpVCrVmv4BFVZLb/RhRNAAAAAASUVORK5CYII=" alt="HTTP1.1continue1"></p><p><img src="https://javaguide.cn/assets/HTTP1.1continue2.c4a70a7f.png" alt="HTTP1.1continue2"></p><p>然而在HTTP&#x2F;1.0中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值。</p><h6 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h6><p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP&#x2F;1.0对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p><p>HTTP&#x2F;1.1则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。</p><p>HTTP&#x2F;1.0包含了<code>Content-Encoding</code>头部，对消息进行端到端编码。HTTP&#x2F;1.1加入了<code>Transfer-Encoding</code>头部，可以对消息进行逐跳传输编码。HTTP&#x2F;1.1还加入了<code>Accept-Encoding</code>头部，是客户端用来指示他能处理什么样的内容编码</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol><li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host头处理</strong> : HTTP&#x2F;1.1在请求头中加入了<code>Host</code>字段。</li></ol><h3 id="计算机网络常见知识点-amp-面试题"><a href="#计算机网络常见知识点-amp-面试题" class="headerlink" title="计算机网络常见知识点&amp;面试题"></a>计算机网络常见知识点&amp;面试题</h3><h5 id="应用层有哪些常见的协议？"><a href="#应用层有哪些常见的协议？" class="headerlink" title="应用层有哪些常见的协议？"></a>应用层有哪些常见的协议？</h5><h6 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP:超文本传输协议"></a>HTTP:超文本传输协议</h6><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p><p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><h6 id="SMTP-简单邮件传输-发送-协议"><a href="#SMTP-简单邮件传输-发送-协议" class="headerlink" title="SMTP:简单邮件传输(发送)协议"></a>SMTP:简单邮件传输(发送)协议</h6><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p><p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><ol><li>电子邮件的发送过程</li><li>如何判断邮箱是真正存在的？</li></ol><p><strong>电子邮件的发送过程？</strong></p><p>比如我的邮箱是“<a href="mailto:&#x64;&#97;&#98;&#x61;&#105;&#64;&#99;&#115;&#122;&#104;&#x69;&#x6e;&#x61;&#110;&#46;&#99;&#111;&#109;">&#x64;&#97;&#98;&#x61;&#105;&#64;&#99;&#115;&#122;&#104;&#x69;&#x6e;&#x61;&#110;&#46;&#99;&#111;&#109;</a>”，我要向“<a href="mailto:&#x78;&#105;&#97;&#111;&#x6d;&#x61;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#105;&#97;&#111;&#x6d;&#x61;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#105;&#97;&#111;&#109;&#97;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x78;&#105;&#97;&#111;&#109;&#97;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a>”的用户来收邮件，然后用户就通过 <strong>POP3&#x2F;IMAP</strong> 协议将邮件取出。</li></ol><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><h6 id="POP3-x2F-IMAP-邮件接收的协议"><a href="#POP3-x2F-IMAP-邮件接收的协议" class="headerlink" title="POP3&#x2F;IMAP:邮件接收的协议"></a>POP3&#x2F;IMAP:邮件接收的协议</h6><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3&#x2F;IMAP。</strong></p><h6 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP:文件传输协议"></a>FTP:文件传输协议</h6><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote><h6 id="Telnet-远程登陆协议"><a href="#Telnet-远程登陆协议" class="headerlink" title="Telnet:远程登陆协议"></a>Telnet:远程登陆协议</h6><p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p><h6 id="SSH-安全的网络传输协议"><a href="#SSH-安全的网络传输协议" class="headerlink" title="SSH:安全的网络传输协议"></a>SSH:安全的网络传输协议</h6><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性</strong></p><h5 id="TCP-三次握手和四次挥手-面试常客"><a href="#TCP-三次握手和四次挥手-面试常客" class="headerlink" title="TCP 三次握手和四次挥手(面试常客)"></a>TCP 三次握手和四次挥手(面试常客)</h5><p><img src="https://pic1.zhimg.com/80/v2-eadfa5d23467c598646392d6d4350b48_720w.jpg" alt="img"></p><h6 id="TCP-三次握手漫画图解"><a href="#TCP-三次握手漫画图解" class="headerlink" title="TCP 三次握手漫画图解"></a>TCP 三次握手漫画图解</h6><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="TCP三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0c9f470819684156cfdc27c682db4def.png" alt="img"></p><h6 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h6><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><h6 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h6><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h6 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h6><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p><p><img src="https://segmentfault.com/img/remote/1460000039165595" alt="img"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h5 id="TCP-UDP-协议的区别"><a href="#TCP-UDP-协议的区别" class="headerlink" title="TCP, UDP 协议的区别"></a>TCP, UDP 协议的区别</h5><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景</p><h5 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h5><ol><li><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p></li><li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p></li><li><p><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li><li><p>TCP 的接收端会丢弃重复的数据。</p></li><li><p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p></li><li><p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p></li><li><p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p></li><li><p><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p></li></ol><h6 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h6><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><p><strong>停止等待 ARQ 协议</strong></p><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><p><strong>连续 ARQ 协议</strong></p><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优缺点：</strong></p><ul><li><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p></li><li><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p></li></ul><h6 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h6><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h6><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h5 id="在浏览器中输入-url-地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入-url-地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</h5><p>打开一个网页，整个过程会使用哪些协议？</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h6 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a><strong>DNS解析</strong></h6><p><strong>域名服务器划分</strong></p><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos">根域名服务器.<br>顶级域名服务器<span class="hljs-built_in">con</span> <span class="hljs-built_in">net</span> cn gov<br>权限域名服务器bilibili   qq  baidu<br></code></pre></div></td></tr></table></figure><p>输入地址，先看浏览器缓存，同时查看主机文件里有没有对应记录</p><p>浏览器进行域名解析，需要调用解析器 （DNS客户端）</p><p>解析器向本地DNS服务器      发送解析请求本地DNS服务器也就是互联网提供商ISP</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">本地DNS收到之后，会查看自己的缓存，如果有，直接返回，并标注非权威non-authoritative<br>如果缓存没有，则会去找，解析器只需到等DNS的返回结果即可<br></code></pre></div></td></tr></table></figure><p>本地DNS服务器解析过程</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>.向根域名服务器查询，获得到根域名服务器的IP地址<br><span class="hljs-number">2</span>.想根域名服务器咨询.<span class="hljs-keyword">com</span>域名服务器的地址     这次返回的是权威的响应<br><span class="hljs-number">3</span>.根域名放服务器返回.<span class="hljs-keyword">com</span>服务器地址，和名称<br><span class="hljs-number">4</span>.然后向顶级域名服务器咨询bilibili.<span class="hljs-keyword">com</span>的地址<br><span class="hljs-number">5</span>.咨询bilibili权威域名服务器的IP地址返回结果canonical <span class="hljs-keyword">name</span> ，a开头的域名是一个CDN，也就是内容分发网络，得到他的IP地址，就可以返回给本地DNS服务器，再返回给解析器<br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220330143748941.png" alt="image-20220330143748941"></p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p><h5 id="各种协议与-HTTP-协议之间的关系"><a href="#各种协议与-HTTP-协议之间的关系" class="headerlink" title="各种协议与 HTTP 协议之间的关系"></a>各种协议与 HTTP 协议之间的关系</h5><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p><h5 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h5><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><h6 id="Cookie-被禁用怎么办"><a href="#Cookie-被禁用怎么办" class="headerlink" title="Cookie 被禁用怎么办?"></a><strong>Cookie 被禁用怎么办?</strong></h6><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p><h5 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h5><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；② 一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密</p><h5 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="URI 和 URL 的区别是什么?"></a>URI 和 URL 的区别是什么?</h5><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</p><h2 id="2、操作系统"><a href="#2、操作系统" class="headerlink" title="2、操作系统"></a>2、操作系统</h2><h3 id="操作系统常见面试题总结"><a href="#操作系统常见面试题总结" class="headerlink" title="操作系统常见面试题总结"></a>操作系统常见面试题总结</h3><h5 id="一-、操作系统基础"><a href="#一-、操作系统基础" class="headerlink" title="一 、操作系统基础"></a>一 、操作系统基础</h5><h6 id="1-1-什么是操作系统？"><a href="#1-1-什么是操作系统？" class="headerlink" title="1.1 什么是操作系统？"></a>1.1 什么是操作系统？</h6><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p><h6 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h6><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>说了用户态和系统态之后，那么什么是系统调用呢？</p><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul><h5 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、进程和线程</h5><h6 id="2-1-进程和线程的区别"><a href="#2-1-进程和线程的区别" class="headerlink" title="2.1 进程和线程的区别"></a>2.1 进程和线程的区别</h6><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong></p><p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h6 id="2-2-进程有哪几种状态"><a href="#2-2-进程有哪几种状态" class="headerlink" title="2.2 进程有哪几种状态?"></a>2.2 进程有哪几种状态?</h6><p>我们一般把进程大致分为 5 种状态</p><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png" alt="process-state"></p><h6 id="2-3-进程间的通信方式"><a href="#2-3-进程间的通信方式" class="headerlink" title="2.3 进程间的通信方式"></a>2.3 进程间的通信方式</h6><p>大概有 7 种常见的进程间的通信方式。</p><ol><li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是<strong>先进先出的原则</strong>。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h6 id="2-4-线程间的同步的方式"><a href="#2-4-线程间的同步的方式" class="headerlink" title="2.4 线程间的同步的方式"></a>2.4 线程间的同步的方式</h6><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p><ol><li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h6 id="2-5-进程的调度算法"><a href="#2-5-进程的调度算法" class="headerlink" title="2.5 进程的调度算法"></a>2.5 进程的调度算法</h6><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h6 id="2-6-什么是死锁"><a href="#2-6-什么是死锁" class="headerlink" title="2.6 什么是死锁"></a>2.6 什么是死锁</h6><p>死锁描述的是这样一种情况：多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><h6 id="2-7-死锁的四个条件"><a href="#2-7-死锁的四个条件" class="headerlink" title="2.7 死锁的四个条件"></a>2.7 死锁的四个条件</h6><ul><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><p>注意，只有四个条件同时成立时，死锁才会出现。</p><h6 id="2-8-解决死锁的方法"><a href="#2-8-解决死锁的方法" class="headerlink" title="2.8 解决死锁的方法"></a>2.8 解决死锁的方法</h6><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><p><strong>死锁的预防</strong></p><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p><p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p><p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p><p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p><p><strong>1、静态分配策略</strong></p><p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p><p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p><p><strong>2、层次分配策略</strong></p><p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p><p><strong>死锁的避免</strong></p><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p><p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p><blockquote><p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p></blockquote><p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p><p>银行家算法详情可见：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》open in new window</a> 。</p><p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待</p><p>操作系统教程树中讲述的银行家算法也比较清晰，可以一看.</p><p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p><p><strong>死锁的检测</strong></p><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p><p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p><p><strong>进程-资源分配图</strong></p><p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p><p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p><p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p><p><img src="https://javaguide.cn/assets/%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.31e353df.jpg" alt="进程-资源分配图"></p><p>进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p><p><strong>死锁检测步骤</strong></p><p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p><ol><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li><li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li><li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li></ol><p><strong>死锁的解除</strong></p><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p><ol><li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li><li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h5 id="三、操作系统内存管理基础"><a href="#三、操作系统内存管理基础" class="headerlink" title="三、操作系统内存管理基础"></a>三、操作系统内存管理基础</h5><h6 id="3-1-内存管理介绍"><a href="#3-1-内存管理介绍" class="headerlink" title="3.1 内存管理介绍"></a>3.1 内存管理介绍</h6><p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p><h6 id="3-2-操作系统的常见的几种内存管理机制"><a href="#3-2-操作系统的常见的几种内存管理机制" class="headerlink" title="3.2 操作系统的常见的几种内存管理机制"></a>3.2 操作系统的常见的几种内存管理机制</h6><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p><ol><li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li></ol><p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p><p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p><h6 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h6><p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p><p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间大，页表也会很大的问题。</li></ol><p><strong>快表</strong></p><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p><p><strong>多级页表</strong></p><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p><ul><li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.htmlopen in new window</a></li></ul><p><strong>总结</strong></p><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p><h6 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="3.4 分页机制和分段机制的共同点和区别"></a>3.4 分页机制和分段机制的共同点和区别</h6><p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p><p>🙋 <strong>我</strong> ：</p><ol><li>共同点<ul><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ul></li><li>区别<ul><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li></ul></li></ol><h6 id="3-5-逻辑-虚拟-地址和物理地址"><a href="#3-5-逻辑-虚拟-地址和物理地址" class="headerlink" title="3.5 逻辑(虚拟)地址和物理地址"></a>3.5 逻辑(虚拟)地址和物理地址</h6><p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p><p>🙋 <strong>我：</strong> em…好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p><h6 id="3-6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#3-6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</h6><p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated"></p><p><strong>为什么要有虚拟地址空间呢？</strong></p><p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p><p>通过虚拟地址访问内存有以下优势：</p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><h5 id="四、虚拟内存"><a href="#四、虚拟内存" class="headerlink" title="四、虚拟内存"></a>四、虚拟内存</h5><h6 id="4-1-什么是虚拟内存-Virtual-Memory"><a href="#4-1-什么是虚拟内存-Virtual-Memory" class="headerlink" title="4.1 什么是虚拟内存(Virtual Memory)?"></a>4.1 什么是虚拟内存(Virtual Memory)?</h6><p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317">《虚拟内存的那点事儿》open in new window</a></p><p>维基百科中有几句话是这样介绍虚拟内存的。</p><blockquote><p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存open in new window</a></p></blockquote><h6 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="4.2 局部性原理"></a>4.2 局部性原理</h6><p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p><p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p><p>局部性原理表现在以下两个方面：</p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h6 id="4-3-虚拟存储器"><a href="#4-3-虚拟存储器" class="headerlink" title="4.3 虚拟存储器"></a>4.3 虚拟存储器</h6><p><strong>虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念</strong></p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p><p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p><h6 id="4-4-虚拟内存的技术实现"><a href="#4-4-虚拟内存的技术实现" class="headerlink" title="4.4 虚拟内存的技术实现"></a>4.4 虚拟内存的技术实现</h6><p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p><ol><li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li><strong>请求段页式存储管理</strong></li></ol><p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p><p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p><p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p><p>不管是上面那种实现方式，我们一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol><h6 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="4.5 页面置换算法"></a>4.5 页面置换算法</h6><p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p><p>🙋 <strong>我</strong> ：</p><blockquote><p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p></blockquote><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><blockquote><p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p></blockquote><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p><ul><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h3 id="后端程序员必备的-Linux-基础知识总结"><a href="#后端程序员必备的-Linux-基础知识总结" class="headerlink" title="后端程序员必备的 Linux 基础知识总结"></a>后端程序员必备的 Linux 基础知识总结</h3><h5 id="1-从认识操作系统开始"><a href="#1-从认识操作系统开始" class="headerlink" title="1. 从认识操作系统开始"></a>1. 从认识操作系统开始</h5><h6 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1. 操作系统简介"></a>1.1. 操作系统简介</h6><p>我通过以下四点介绍什么是操作系统：</p><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li></ol><h6 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2. 操作系统简单分类"></a>1.2. 操作系统简单分类</h6><p><strong>Windows</strong></p><p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。</p><p><strong>Unix</strong></p><p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix</p><p><strong>Linux</strong></p><p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> </p><p><strong>Mac OS</strong></p><p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p><h6 id="1-3-操作系统的内核（Kernel）"><a href="#1-3-操作系统的内核（Kernel）" class="headerlink" title="1.3. 操作系统的内核（Kernel）"></a>1.3. 操作系统的内核（Kernel）</h6><blockquote><p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I&#x2F;O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p><p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p></blockquote><p>简单概括两点：</p><ol><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li><li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性</strong></li></ol><h6 id="1-4-中央处理器（CPU，Central-Processing-Unit）"><a href="#1-4-中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="1.4. 中央处理器（CPU，Central Processing Unit）"></a>1.4. 中央处理器（CPU，Central Processing Unit）</h6><p>关于 CPU 简单概括三点：</p><ol><li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li><li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li><li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li></ol><h6 id="1-5-CPU-vs-Kernel-内核"><a href="#1-5-CPU-vs-Kernel-内核" class="headerlink" title="1.5. CPU vs Kernel(内核)"></a>1.5. CPU vs Kernel(内核)</h6><p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p><ol><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li></ol><p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p><h6 id="1-6-系统调用"><a href="#1-6-系统调用" class="headerlink" title="1.6. 系统调用"></a>1.6. 系统调用</h6><p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li><li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p><strong>说了用户态和系统态之后，那么什么是系统调用呢？</strong></p><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p><p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li><li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/L181kk2Eou-compress.jpg" alt="img"></p><h5 id="3-Linux-文件系统概览"><a href="#3-Linux-文件系统概览" class="headerlink" title="3. Linux 文件系统概览"></a>3. Linux 文件系统概览</h5><h6 id="3-1-Linux-文件系统简介"><a href="#3-1-Linux-文件系统简介" class="headerlink" title="3.1. Linux 文件系统简介"></a>3.1. Linux 文件系统简介</h6><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p><p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p><h6 id="3-2-inode-介绍"><a href="#3-2-inode-介绍" class="headerlink" title="3.2. inode 介绍"></a>3.2. inode 介绍</h6><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p><p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p><p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p><p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p><p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><p>简单总结一下：</p><ul><li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li><li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li></ul><h6 id="3-3-Linux-文件类型"><a href="#3-3-Linux-文件类型" class="headerlink" title="3.3. Linux 文件类型"></a>3.3. Linux 文件类型</h6><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p><ul><li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li><li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li><li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li><li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li><li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li><li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li><li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信</li></ul><h6 id="3-4-Linux-目录树"><a href="#3-4-Linux-目录树" class="headerlink" title="3.4. Linux 目录树"></a>3.4. Linux 目录树</h6><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p><p><strong>Linux 的目录结构如下：</strong></p><p><img src="https://javaguide.cn/assets/Linux%E7%9B%AE%E5%BD%95%E6%A0%91.5c5a8ebb.png" alt="Linux的目录结构"></p><p><strong>常见目录说明：</strong></p><ul><li><strong>&#x2F;bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li><strong>&#x2F;etc：</strong> 存放系统管理和配置文件；</li><li><strong>&#x2F;home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li><li><strong>&#x2F;usr ：</strong> 用于存放系统应用程序；</li><li><strong>&#x2F;opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li><strong>&#x2F;proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>&#x2F;root：</strong> 超级用户（系统管理员）的主目录（特权阶级o）；</li><li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li><strong>&#x2F;dev：</strong> 用于存放设备文件；</li><li><strong>&#x2F;mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>&#x2F;boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>&#x2F;lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>&#x2F;tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>&#x2F;var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>&#x2F;lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里</li></ul><h5 id="4-Linux-基本命令"><a href="#4-Linux-基本命令" class="headerlink" title="4. Linux 基本命令"></a>4. Linux 基本命令</h5><h6 id="4-1-目录切换命令"><a href="#4-1-目录切换命令" class="headerlink" title="4.1. 目录切换命令"></a>4.1. 目录切换命令</h6><ul><li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li><li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li><li><strong><code>cd /</code>：</strong> 切换到系统根目录</li><li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li><li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li></ul><h6 id="4-2-目录的操作命令-增删改查"><a href="#4-2-目录的操作命令-增删改查" class="headerlink" title="4.2. 目录的操作命令(增删改查)"></a>4.2. 目录的操作命令(增删改查)</h6><ul><li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li><li>**<code>ls/ll</code>**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li><li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li><li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li><li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li><li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li><li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录&#x2F;文件&#x2F;压缩包</li></ul><h6 id="4-3-文件的操作命令-增删改查）"><a href="#4-3-文件的操作命令-增删改查）" class="headerlink" title="4.3. 文件的操作命令(增删改查）"></a>4.3. 文件的操作命令(增删改查）</h6><ul><li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li><li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li><li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li></ul><h6 id="4-4-压缩文件的操作命令"><a href="#4-4-压缩文件的操作命令" class="headerlink" title="4.4. 压缩文件的操作命令"></a>4.4. 压缩文件的操作命令</h6><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code>**</p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中：x：代表解压</p><p>示例：</p><ul><li>将 &#x2F;test 下的 test.tar.gz 解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</li><li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C 代表指定解压的位置）</li></ul><h6 id="4-5-Linux-的权限命令"><a href="#4-5-Linux-的权限命令" class="headerlink" title="4.5. Linux 的权限命令"></a>4.5. Linux 的权限命令</h6><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p><p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下<code>ls -l</code></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk0AAADkBAMAAAB3WA1kAAAAElBMVEUAAACqqqoAAKoAqgD/AAAAqqr31TvxAAAKr0lEQVR42uycbZqjIBCEQ05A3SAPJ/HH3v9Mi72NJQMuhpDomK7dUQboGN/BD+ppvZlMJtO1hWqtq3f2tXAHxDVSG1D2SYu8sxTYVJFj4WA5PEPP18IR62MLtjo5cDt5ZyloU1Vg4WChmxPDG5yAtGA75rVywsc4wUE3K98DPmtqH3caxYMCwCoc2uQAv3FM5ZwgNdpZoYARK04ObHJzACCFRFj3C8CYg8d55RQFj7ypzUmjeFBgCdca/cK1cKlWhOQkC5H+wuYEQgCwiR+2jkwf9orIXDk5QHdKCkg7zsGwzelW5eR3cILC+R8nnrq5nHmBTQ4cu2tw8AM48W/kkcZT3tTizHXGieENTuyjYEtO2fGdcbqBTdDtl5HX4ITbfk5c6ee1OI0fTwDanLCXk/NVTijDGdXmxM5tTvKjv0lh0MUdPOi3r/soQxnFM0QsMXx1zoCvhGNuBzwjnO4f+6RvVXTmWV2jPKSQxpLidIffQJlMJpPJ9A16xX+i+v0nzlKW+xH4y/lPSf3+k9QwEFK4nP+U9Ir/VOF0Pf+JvkKn/yQR1/efFjhAn//EoSYsIZu5nv+08PS9/hPHE7fk/NX8p4VTt/9U53Q1/0nU7z9tcrqa/6R6wX9CldPF/KekLv+Jn1z64+Y/mUwmk8nUI/iXouE7/CeJgmchRuzxn6Tflv8UHrK8vUnOvxaMp3wVRsUFCwKr6T9pvw3/6X5iTlEdnKQDuKO8u236T27h5HyV03hxw3DgzFyNH/0iWVN93zv8p5ITnN/nP7mMk1tzCo95EYdUXAyWGjbIpkh+QYO8aZj/5BLLzL7Z7T8B9J94fro/ZjxhLowfWsl4Wr53wiNjIG+qx3f5T+ysBWCX/8TxpLg5ngTPuznxV+6jlNi0NZyavkqTk/Zq+wUlp9sxnHQ8qRzypmr4QZxYOIJT2k3uS950Q8kJz/tPzv86TnL+xfpM4LIzQdZU4dThP7Ema8Iu/8lt+0/3EOSi94+TyWQymUymvbpQ/tNXPH+XZM/f7eNkz9+9O/+JTQ7cluU/bT5/l08YLf+p9vxd8ZTi5Z6/G5H/hFvB6XLP3w3If6pxutzzd6ohz98x2PKf6s/fWf6TyWQymUy/N//pn9aXcYeND2Sfsob3ltSj2OgZ8nq68p84V+FtITY/kH3KGlfclN3PySmqmxNWnKRlEzzKWKWL2PAZTg6e/tMn8p8YKIBATmQiCEF2sijGmM8J3kOYfx5x8cb8J6HyqfwnDgnFR4ROoou3ySh41sD95BQpPeJ/LQyWAtLV+/OfKAgej/K9a9JETs5zyRrA/eQUQuJEjeREX+UT+U8U1EAq02S4kgI3zxr4glP8+RCnT+U/0QjJOOUZm6zhikXcDuIEwL8//6nkxAI56apxX1A/P4VYeGf+U1x9LP8phWhTNXUetJWYrJrXZMa9Xub0evc9MmfNOA0Rj0rTL9OfPk23L1PnDn8lJ/jnw07sP71FU99mpvP6T0kn43Q6/+k9mvr8p+mk/lOcroQw35LHwlAjaurzn6aT+k8zFUEUBNm4id7U5z9N5/Sf4j8ZRhFSuIcwcDo89flP00n9p5nMXTkJojAI1NTnP00n9Z8KTqOsqKnPf5pO6j+R0+jzU5//NJ3XfwqPIJzS9e768xY8H5JR+Zb5HZ6m9JWcnr/Nvq+ubt/D6VQyTubTJR2e/6RTW4z1n9rvf+JGGV7mqvBdNOFxaF4P5/mj/Kf+9z+RExUWYsdyoocwyH/a+/6nbOZJTlTB6cj8J3Ia6z+13/9ETjSiRJKustyGB72jumvNcflP3PWB/lP7+TtZ5EYUB07QaR05hftDag7Kf+LEfaT/1H7+jtukEVVwmhU4M5bUqGPyn1iFUf5T+3kpfmJuRLU5HZD/NJST7+fkPI2oJqcD85+kcZT/1M0JVU5SIidZHZT/RLdptP/Ufv+TgCmtqaBo+CIoOYc/wpdlRP1l7wqQ44SBGPgF7A8Y//+RPeylwnXbyRwbVkmkGRIfJBei5AzoJCEIgiAIOfoTVf94F5pq+zyCQn+i6R9fivNUvgtPwf3j4AmfgfT+ce/5MZb+8cZP8VNxIL1/3N1cxtI/fnndVexlfv94lyM3Y+kfP3hi7B8/ZVuW/vGDJ8b+8fMXZekfP3hi7B8/NjL1jx88MfaPn0c3lv7xpj+VH5e/EwRBEIQD6frTsm6h/qfvqj+dUhCX/4lPf1ptC83ffQ396Q3/kwuRUf6nWP2p1t3fOk/3P8GKFOF/itWf3FTg7oI0/xN4sqj8Xaz+1PJ3y2tpg5rZ/+TfFpa/C9Wf2vgsGEv0P4GEsPxdmK4CnjzTmel/Agkx/qd4njA/pfufOsVB/qdY/QnHOylSgiAIgvCA/oTrlqT8HS5p5qCdryHQVRrDq+Xk77Bp1lWAwsCTnx/m5e987X95otGfLDV/N/FUcT7e1xD0j2NPE/N3/sF5wtXc7yW/fxw8ZeXvXG2YeHqhVucpv38cu5ySv8NPnXg6xv7/RNA/Dp5y8ncf4Ymhfxw8BehPoTyVfeYpV38ys5T8HTZhn1x2QhHUItlJEARBEL7A/e8MJxEY3PE/OUodZQIGX8/b/ePQjQbD/T3/k4OUp7f8T4NuBJ7u+Z/A04j8/N2d/nHDxT54uul/ctkJRVCvEUP+7u3+cVCEiSrA/9RNT2VH0cpCkb+70z9uF64swv8EG0b9TJ7w8In73426rUX5n+r+FE+P3f/OhpdekP9pqU/x9Nj97wxfHMET5qeJp/z83Y3+cTNzfdwn4gD/E2xPXgQl7UkQBEEQHtKfjKZ//LVmbh0HcnWV1Wj6x8c/NBlPZjT942sUT/H+J7wWCPrHYX+q3qJdhiLyPP8TBCSG/vHx/uZ1r23YBm1Nrv/J+kLQPz7aDr3ftw1QO57kf8Imgv5xfwT9yWvsl77k+p9OLgj6xy/PWmeesv1PRtM/PsxPA0+Yn5L8TxCQOPrH8X5L6fNT2Y9jnmJ3giAIgvCI/gSsG03+7p9g8PXYRpO/+xNMPK220eTvJhDoTxdZhiV/V2r9i+xEkL/ra9P1p+Xif5plJ4L8nV9hseTvXH+ajAXp+TtfTZO/q/skp6TrT5cnoMnfzbJTvv50eQKW/J3rTz4AMvUngCd/dxzmJDv9aucMUiOGYSgqMN5XNzH0Itno/leprCp8MnJJxmqgNP4aPI40ZPHGScgHa2lpaenfqny+oUaP1SwnuBbzmu7/BGHLStp/qjlObcQJynBK9H+KfczT/pOMz36VE93JibOcsKUu6T+NOaFahksHmXNO0X+ypGUOJQqa7v8EYSdd0n8SEapCGjoSxJETafShj408o0c6J8uMOUX/yahooPS7++8iJ+Z0/ych5SSyVY3D6V85tWKcbNKoFZvYcf9d0xhziv6Tfbn/hFLQbP+nyIk/Mv4TOG1SwckXML9yIv/0pDIxRs6N2s+cBv6TzjmWgqb7GkVOWf8JnE7Xk4MxJHagw5ucmMHJ1xNK93Ga91XOOcX7ExmZ79gRXeIU/SdWkQZKQ/9pov/TnZwUEDjF553xcTL9Hr5z8owhAqf4VI7+E25Lh1LkNN3/KfaRyvd/quLrSWTwR4ITLr5iz7w9Q76eiJ7x3lK31HtLKw95v1ucrkkkxYnoIZyWr7L0d/UFD5a7hMwPx0AAAAAASUVORK5CYII=" alt="img"></p><p>第一列的内容的信息解释如下：</p><p><img src="https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB.5ddf952e.png" alt="img"></p><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以使用 cat 查看文件的内容</td></tr><tr><td align="left">w</td><td align="right">可以修改文件的内容</td></tr><tr><td align="left">x</td><td align="right">可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th align="left">权限名称</th><th align="right">可执行操作</th></tr></thead><tbody><tr><td align="left">r</td><td align="right">可以查看目录下列表</td></tr><tr><td align="left">w</td><td align="right">可以创建和删除目录下文件</td></tr><tr><td align="left">x</td><td align="right">可以使用 cd 进入目录</td></tr></tbody></table><p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p><p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li><li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li><li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><blockquote><p>我们再来看看如何修改文件&#x2F;目录的权限。</p></blockquote><p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAg0AAAD2BAMAAACn/KlUAAAAD1BMVEUAAACqqqr/AACqAAAAqgDVR6mAAAAHP0lEQVR42uxdAZKbMAzEzQe8P+j0BZnh/3+r0UI3ruJe7QsTCNo7iCIhX7wRBjbOMQUCgUAgEAgEAoFAILAbANlEMm9mSMglAlhInjor4dEFy5hOAjzzpDyhrFKWt9ibD/IIoKv8FkvxD+ChPF6Lh5SRVfMA/vCwelLxmMGAgZ4qi/wB+aQ8TMjQe70yQx60g7AeFgO+QvAR9VCWJg/A3zwsi3iwWviQ/YJLqx6migf1jR4z8ME8mJk9DynXPMj6gPGh5iGp+4/jAxwPqLPOXQ+YEqpzpLQZm4e8IGsbgh5lleWRB6yeQCAQCAQ+B8kZyKsDpzn4vwBwRsqbI13o4B88GFAJCMBVeVjVJwkIZbnq+CAegBz1sBgpeLg6Dw8CwpV5SJXskO3ZFcfJQCAQeI5fQ/g5fRrGehQ8rFmtM4v8L4lDIn8xlgXNKRjgqs4y0ECHnLIrD8iTR4sd2FofFclopCVwZag2ppHQISPsyUPq50EbQEYjDeCqyrJHGtiDB32ayVSIbYb+tV8g1aVOt59QYRAFjgfWCNO3TtddgjIZ2uYhAWZITuEWQH89IEM8JOj9YajFAzdWqa9eP6HClQNISM2DrQg+UZgd9SFfW7AF3fXAeS5bKsBXT4OhzQCe8ZA9D25ChXvVXNPd5EFDo9aadOEHXgIsk24eRGLKaE17EjwPtngeJs8Dw1jNikrHQ9VzujwpIttlHpoHMKGTBz0oyfPwunoAvuBBsTYPeMoDt5YHPTwwSzygxQMXPqPRxQP5s/bcWQ1DnocEaOOHPXT1+gkVBgA5AWBIxQOOt+IBOgYwa9KIoNCWlUGDtbBxnBDn1XF9ETwED6E/BI6Cbv3BA8hj+gM9+oYHjYb+sC+69QePcf3BPP4ynoAz9kTal4e2/sCsHXjo0R+EAf3Bt5D69QdmmfUS/UHo0R+EEf3Bk48+/UFZYIhcgf0e0h+EXv2BGNEf/K6FTv2BWaqHWu4cud4Ueq67hZHrbj8Wold/YFabB2WeiAcLDegP+9TDkP4wDekPnodB/QENHvr1B2FIf5i69QcHhnr1B/0tr0/W+sOJvkEbCAQCgc/Ha/SH48x/OKX+wFCNS+oP8C1eUX8oIX8+eUH9wULuA9Pr6Q8WcrNArqg/YPI8XFF/eMbD9fQHhZR8Rf1hCYX+EAgEAoETYVh/0GFuXH+AUh1u05c4hP7wiu9fYGpjnr7AcfQH8jCkP/TwcHj9AcsPeRjTH/DQ6fl2n273xaBnXkzzr4zcyha34j6a/pBQfLZCHtMfRGzp4b0QMNMgEfRb9+lYw8fTH0qI7H13/gPf+dt8p0GPee/q+kzXAa+7uVcwND7/wWB9nc0QD0aBHHQdkweGxvSHdj20eZgPpz+44+bo/Ac/PnAHKKZ4KB6Gp/lo+sO68bfnP/jjBXeQ5bE8Z4FYucxlKavLIygwFoKHAg6jb8OvI2F6CU7/RZUfHdsGD/vc/4I86Iipp3siO4M8vO/+Fz+bl9w7Qid5r+WhPF6Lh5ff/8J4YGjxZHNrR2PbANjyyp2u+uuQTiOxtFSfhapRC1u7Zgg/3nD/C9UDQ2y5YG1HPFTyBa/eG6F68gwy/P8WkUM54uFN978QD1vLxbUWmOMhb22jFRIPivvrFBEDt1+84f4XPTwAG62wtEZIPGyF//QrB3qtjof33f+iox7KwiiY4kMkV6meh7F62P/+Fxof/osH2PhHLn3o/3jgopfqeHjP/S+240XaeGA7a5XLgEYn+2VWHWK1SdmQFKz//7DWwlbOyKc+r/7N3tmlKgwDYfQi2UC3cFeSh9n/mhxntEMJKKFRJuk5WhkJQfIRxf7leDjtya0r7l9sPuzL72fpxCcHhxwccnixzPGH/0zg38S/iX8T/yb+TfybBv5NB/+mgX8TAACgF/ybf3gnyWEH/+YT/JsG/k0D7yQ5HMC/GeDfBPgCt+mu5P8Ot+nOpBvk4JCDkyeHtP7NEsUPcsjr35QofpBDXv/miRz8bGYYFOLGh2dT2yuJf7NI1QGLF4bou1L1qUV3DrH+gz7ixoe9qe2Vxr8pupVqhSO2Sfd8OK7/oB8XNz406z9EryT+zSKPAUv1IoKR2p3Dcd0DreKC/72p7ZXEvyn6KLVUKxzxl5M5+Hz4nEMS/2aTw4j5oGixxY0PbQ7a5r2S+DePOfjm76zozCHWf/Ch+Adt0dTmkMS/WWzUVbzwufBIxp7C/2r2L8iBHMiBHLIcn8S/mcB/gX8T/yb+Tfyb+Dfxb+LfxL+JfxMAABYH/2aC4w/4N/Fv4t/Ev4l/E/8m/k38m/g3AQBgcfBv4t/Ev4l/E/8m/k38m/g38W/i37wKRIB/M4l/E2Byxvkv5l6lebz/Ys4TB2/9F9fKYbD/Ys4vxxj/xRLz4bT/YpHvxXn/xcI59PsvFvh9GOO/mHs+3Nu7YxoAABAGghrwbxYPhA5N7iT80LWv/xe9HQib1qXQAQAAuFqK6eakDZMsPAAAAABJRU5ErkJggg==" alt="img"></p><p><strong>补充一个比较常用的东西:</strong></p><p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本 zookeeper</li><li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li><li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li></ol><h6 id="4-6-Linux-用户管理"><a href="#4-6-Linux-用户管理" class="headerlink" title="4.6. Linux 用户管理"></a>4.6. Linux 用户管理</h6><p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux 用户管理相关命令:</strong></p><ul><li><code>useradd 选项 用户名</code>:添加用户账号</li><li><code>userdel 选项 用户名</code>:删除用户帐号</li><li><code>usermod 选项 用户名</code>:修改帐号</li><li><code>passwd 用户名</code>:更改或创建用户的密码</li><li><code>passwd -S 用户名</code> :显示用户账号密码信息</li><li><code>passwd -d 用户名</code>: 清除用户密码</li></ul><p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p><p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h6 id="4-7-Linux-系统用户组的管理"><a href="#4-7-Linux-系统用户组的管理" class="headerlink" title="4.7. Linux 系统用户组的管理"></a>4.7. Linux 系统用户组的管理</h6><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li></ul><h6 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8. 其他常用命令"></a>4.8. 其他常用命令</h6><ul><li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p></li><li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p></li><li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color 代表高亮显示</p></li><li><p><strong><code>ps -ef</code>&#x2F;<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**<code>ps aux|grep redis</code>** （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p><p>先用 ps 查找进程，然后用 kill 杀掉</p></li><li><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><p><strong>net-tools 和 iproute2 ：</strong><code>net-tools</code>起源于 BSD 的 TCP&#x2F;IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS&#x2F;RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux">如何在 Linux 中使用 IP 命令和示例open in new window</a></p></li><li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。**<code>reboot -w</code>：** 做个重开机的模拟（只有纪录并不会真的重开机）</p></li></ul><h6 id="4-9-怎么查看一个进程的用的JVM堆内存资源"><a href="#4-9-怎么查看一个进程的用的JVM堆内存资源" class="headerlink" title="4.9 怎么查看一个进程的用的JVM堆内存资源"></a>4.9 怎么查看一个进程的用的JVM堆内存资源</h6><p>1、jps:查看本地正在运行的java进程和进程ID（pid）</p><p><img src="https://img2018.cnblogs.com/blog/1031555/201903/1031555-20190330210116689-1588206683.png" alt="img"></p><p>2、jinfo pid，查看指定pid的所有JVM信息</p><p>　   1）jinfo -flags pid 查询虚拟机运行参数信息。</p><p>　　2）jinfo -flag name pid，查询具体参数信息，如jinfo -flag UseSerialGC 42324，查看是否启用UseSerialGC</p><p><img src="https://img2018.cnblogs.com/blog/1031555/201903/1031555-20190331120005666-2136368791.png" alt="img"></p><p>3、jmap</p><p>　　1）jmap -heap pid：输出堆内存设置和使用情况（JDK11使用jhsdb jmap –heap –pid pid）</p><p>　　2）jmap -histo pid：输出heap的直方图，包括类名，对象数量，对象占用大小</p><p>　　3）jmap -histo:live pid：同上，只输出存活对象信息</p><p>　　4）jmap -clstats pid：输出加载类信息</p><p>　　5）jmap -help：jmap命令帮助信息</p><p>4、jstat：Java虚拟机统计工具，全称“Java Virtual Machine statistics monitoring tool”。可以用于监视JVM各种堆和非堆内存大小和使用量</p><p>　　1）jstat -class pid：输出加载类的数量及所占空间信息。</p><p>　　2）jstat -gc pid：输出gc信息，包括gc次数和时间，内存使用状况（可带时间和显示条目参数）</p><p>　　其他命令不一一列举。</p><p><img src="https://img2018.cnblogs.com/blog/1031555/201903/1031555-20190330231058233-370981744.png" alt="img"></p><p>5、jconsole，Java的GUI监视工具，${JAVA_HOME}&#x2F;bin&#x2F;jconsole.exe，本地和远程都可以监控。在CMD命令中输入JConsole pid可直接监控画面。</p><p><img src="https://img2018.cnblogs.com/blog/1031555/201903/1031555-20190330211146093-1464885001.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1031555/201903/1031555-20190330211244164-1248221660.png" alt="img"></p><h6 id="4-10-linux下通过进程名查看其占用端口："><a href="#4-10-linux下通过进程名查看其占用端口：" class="headerlink" title="4.10 linux下通过进程名查看其占用端口："></a>4.10 linux下通过进程名查看其占用端口：</h6><p><strong>1、先查看进程pid</strong></p><p>ps -ef | grep 进程名</p><p><strong>2、通过pid查看占用端口</strong></p><p>netstat -nap | grep 进程pid</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap"><span class="hljs-comment">#查看nginx进程pid：</span><br>命令：<br>ps -ef | grep nginx<br>结果：<br>root     <span class="hljs-number"> 9836 </span>   <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>Jul11 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx<br>nobody   <span class="hljs-number"> 9841 </span><span class="hljs-number"> 9836 </span><span class="hljs-number"> 0 </span>Jul11 ?        00:00:09 nginx: worker process      <br><br><span class="hljs-comment">#通过nginx进程pid查看占用端口（进程pid为9836）</span><br>命令：<br>netstat -nap | grep 9836<br>结果：<br>tcp       <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>0.0.0.0:8081                0.0.0.0:*                   LISTEN      9836/nginx          <br>tcp       <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>0.0.0.0:81                  0.0.0.0:*                   LISTEN      9836/nginx          <br>tcp       <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>0.0.0.0:8082                0.0.0.0:*                   LISTEN      9836/nginx          <br>tcp       <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>0.0.0.0:8083                0.0.0.0:*                   LISTEN      9836/nginx<br></code></pre></div></td></tr></table></figure><p><strong>linux通过端口查看进程：</strong></p><p>netstat -nap | grep 端口号</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">例：查看<span class="hljs-number">8081</span>号端口对应的进程名<br><br>命令：<br>netstat -nap | grep <span class="hljs-number">8081</span><br>结果：<br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0 0.0.0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">8081</span>                <span class="hljs-number">0.0.0.0</span>:*                   LISTEN      <span class="hljs-number">9836</span>/nginx <br></code></pre></div></td></tr></table></figure><h2 id="3、数据结构"><a href="#3、数据结构" class="headerlink" title="3、数据结构"></a>3、数据结构</h2><h3 id="线性数据结构-数组、链表、栈、队列"><a href="#线性数据结构-数组、链表、栈、队列" class="headerlink" title="线性数据结构 :数组、链表、栈、队列"></a>线性数据结构 :数组、链表、栈、队列</h3><h5 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h5><p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p><p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">假如数组的长度为 n。<br>访问：O（<span class="hljs-number">1</span>）<span class="hljs-regexp">//</span>访问特定位置的元素<br>插入：O（n ）<span class="hljs-regexp">//</span>最坏的情况发生在插入发生在数组的首部并需要移动所有元素时<br>删除：O（n）<span class="hljs-regexp">//</span>最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时<br></code></pre></div></td></tr></table></figure><h5 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h5><h6 id="2-1-链表简介"><a href="#2-1-链表简介" class="headerlink" title="2.1. 链表简介"></a>2.1. 链表简介</h6><p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><h6 id="2-2-链表分类"><a href="#2-2-链表分类" class="headerlink" title="2.2. 链表分类"></a>2.2. 链表分类</h6><p><strong>常见链表分类：</strong></p><ol><li>单链表</li><li>双向链表</li><li>循环链表</li><li>双向循环链表</li></ol><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">假如链表中有n个元素。<br>访问：O（n）<span class="hljs-regexp">//</span>访问特定位置的元素<br>插入删除：O（<span class="hljs-number">1</span>）<span class="hljs-regexp">//</span>必须要要知道插入元素的位置<br></code></pre></div></td></tr></table></figure><h6 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3. 应用场景"></a>2.3. 应用场景</h6><ul><li>如果需要支持随机访问的话，链表没办法做到。</li><li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li><li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li></ul><h6 id="2-4-数组-vs-链表"><a href="#2-4-数组-vs-链表" class="headerlink" title="2.4. 数组 vs 链表"></a>2.4. 数组 vs 链表</h6><ul><li>数组支持随机访问，而链表不支持。</li><li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li><li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li></ul><h5 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h5><h6 id="3-1-栈简介"><a href="#3-1-栈简介" class="headerlink" title="3.1. 栈简介"></a>3.1. 栈简介</h6><p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p><p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">假设堆栈中有n个元素。<br>访问：O（n）<span class="hljs-regexp">//</span>最坏情况<br>插入删除：O（<span class="hljs-number">1</span>）<span class="hljs-regexp">//</span>顶端插入和删除元素<br></code></pre></div></td></tr></table></figure><h6 id="3-3-栈的实现"><a href="#3-3-栈的实现" class="headerlink" title="3.3. 栈的实现"></a>3.3. 栈的实现</h6><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p><h5 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h5><h6 id="4-1-队列"><a href="#4-1-队列" class="headerlink" title="4.1. 队列"></a>4.1. 队列</h6><p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p><p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">假设队列中有n个元素。<br>访问：O（n）<span class="hljs-regexp">//</span>最坏情况<br>插入删除：O（<span class="hljs-number">1</span>）<span class="hljs-regexp">//</span>后端插入前端删除元素<br></code></pre></div></td></tr></table></figure><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><h6 id="栈内存线程可共享吗"><a href="#栈内存线程可共享吗" class="headerlink" title="栈内存线程可共享吗"></a>栈内存线程可共享吗</h6><p>java中每个线程都有一个栈，线程中执行函数的时候，就会往这个栈里面压入一个栈帧，这个栈帧包含局部变量表和操作数栈。所以栈内存是不能在线程之间共享的。</p><h6 id="进程的堆和栈哪个可以被其创建的线程所共享"><a href="#进程的堆和栈哪个可以被其创建的线程所共享" class="headerlink" title="进程的堆和栈哪个可以被其创建的线程所共享"></a>进程的堆和栈哪个可以被其创建的线程所共享</h6><p>在Java中，对象是放在堆内存中的，栈内存主要存放基本数据类型。Java的线程的对象来的。因此线程运行在堆内存上，如果设置的堆内存没有足够大，线程开得太多的话，会发生内存溢出！</p><p><img src="https://oscimg.oschina.net/oscnet/up-cd8ac705f6f004c01e0a1312f1599430ba5.png" alt="img"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p><p>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</p><p><strong>索引的优缺点</strong></p><p><strong>优点</strong> ：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。<br>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br></code></pre></div></td></tr></table></figure><p><strong>缺点</strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 <span class="hljs-keyword">SQL</span> 执行效率。<br>索引需要使用物理文件存储，也会耗费一定空间。<br></code></pre></div></td></tr></table></figure><p><strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</p><h4 id="MySQL索引的底层数据结构"><a href="#MySQL索引的底层数据结构" class="headerlink" title="MySQL索引的底层数据结构"></a>MySQL索引的底层数据结构</h4><h5 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h5><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的  key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p><strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><h5 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h5><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span> 树的所有节点既存放键(key) 也存放 数据(data)，而 <span class="hljs-selector-tag">B</span>+树只有叶子节点存放 key 和 data，其他内节点只存放 key。<br><span class="hljs-selector-tag">B</span> 树的叶子节点都是独立的;<span class="hljs-selector-tag">B</span>+树的叶子节点有一条引用链指向与它相邻的叶子节点。<br><span class="hljs-selector-tag">B</span> 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 <span class="hljs-selector-tag">B</span>+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210420165409106.png" alt="img"></p><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p><p>MyISAM 引擎中，<strong>B+Tree 叶节点的 data 域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p><p>InnoDB 引擎中，<strong>其数据文件本身就是索引文件</strong>。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，<strong>树的叶节点 data 域保存了完整的数据记录</strong>。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而<strong>其余的索引都作为辅助索引</strong>，辅助索引的 data 域存储相应记录<strong>主键的</strong>值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h5 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h5><h6 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h6><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h6 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h6><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><h6 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h6><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h5><p><strong>非聚集索引即索引结构和数据分开存放的索引</strong>，<strong>二级索引属于非聚集索引。</strong></p><p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p><h6 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h6><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><h6 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h6><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h4 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h4><h5 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h5><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用，通过 undo_log 实现</p><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的，通过MVCC、表锁、</p><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响，通过 redo_log 实现</p><h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h5><p><strong>1.脏读</strong></p><p>指一个事务读取到另一个事务未提交的数据，这个数据就是脏数据。</p><p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是”脏数据“。</p><p><strong>2.不可重复读</strong></p><p>指一个事务对同一行数据重复读取两次，但得到的结果不同。</p><p>举例：事务 1 读取表的一条数据期间，事务 2 更新了该条记录并提交，事务 1 再次读取该表该条记录时，发现和第一次内容不一致。</p><p><strong>3.幻读</strong></p><p>指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。</p><p>举例：事务 1 读取一个表期间，事务 2 对表做了 delete&#x2F;update&#x2F;insert 操作并提交，事务 1 再次读取表时，此时读取到事务 2 操作的记录，两次操作结果不一致。</p><p><strong>不可重复读和幻读区别</strong></p><p>幻读和不可重复读都是读取了另一条已经提交的事务；但不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><p>不可重复读和幻读是初学者不易分清的概念；简单来说，解决不可重复读的方法是大家常说的<strong>加行锁</strong>，解决幻读方式是<strong>加表锁</strong>。</p><p><strong>4.丢失更新</strong></p><p>指两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了。</p><p>注意：丢失更新可分为两类，分别为第一类丢失更新和第二类丢失更新。</p><p><strong>第一类丢失更新：</strong>两个事务同时操作同一个数据时，当第一个事务撤销时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失。</p><p><strong>第二类丢失更新：</strong>当两个事务同时操作同一个数据时，第一个事务将修改结果成功提交后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失。</p><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>避免上述事务并发问题的出现，SQL 标准定义了四个隔离级别：</p><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</p><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">不允许 <span class="hljs-number">2</span> 个未提交的事务之间并行执行，但它允许在一个事务执行的过程中，另外一个事务得到执行并提交。读取数据的一个事务不会禁止其他写事务，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别不能解决不可重复读问题<br><br><br><br>该方式是 <span class="hljs-keyword">oracle </span>数据库默认的隔离级别，事务提交需手动进行。<br>注意，在互联网大数据量，高并发量的场景下，几乎不会使用上述两种隔离级别。<br>原因如下：<br>“读未提交”虽说有最高的并行执行度，但大量的“脏读”是不被用户认可的；互联网场景下，经常会有大量的读写操作，当有大量写操作未提交时，会限制其他事务对数据的任何访问，这对互联网需要访问热点数据的需求下显得极为不够友好。<br></code></pre></div></td></tr></table></figure><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p><figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql">该隔离级别可解决不可重复读的问题。在该隔离级别下，在一个事务使用某行的数据的过程中，不允许别的事务再对该行数据进行操作。可重复读是给数据库的行加上了锁。<br><br>读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这里的事务读数据时禁止其他进程写，就保障了一个事务的可重复读性。<br><br>在可重复读取隔离级别下，因为只是对一个事务写操作的行加了行锁，但依旧允许别的事务在该表其他行插入和删除数据，于是就会出现，在事务 1 执行的过程中，如果先后两次 <span class="hljs-keyword">select</span> 出符合某个条件的行，如果在这两次 <span class="hljs-keyword">select</span> 之间另一个事务得到了执行，<span class="hljs-keyword">insert</span> 或 <span class="hljs-keyword">delete</span> 了某些行，就会出现先后两次 <span class="hljs-keyword">select</span> 出来的符合同一个条件的结果不一样，第一次 <span class="hljs-keyword">select</span> 好像出现了幻觉一样，因此，这个问题也被成为幻读。要想解决幻读问题，需要将数据库的隔离级别设置为串行化。<br></code></pre></div></td></tr></table></figure><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用。<br></code></pre></div></td></tr></table></figure><table><thead><tr><th align="center">隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td align="center">READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td align="center">REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td align="center">SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><p><strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁读使用到的机制就是 Next-Key Locks。</strong></p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">InnoDB</span> 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE<br></code></pre></div></td></tr></table></figure><h5 id="Innodb中的事务隔离级别和锁的关系"><a href="#Innodb中的事务隔离级别和锁的关系" class="headerlink" title="Innodb中的事务隔离级别和锁的关系"></a><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a></h5><h6 id="读未提交隔离级别下的锁"><a href="#读未提交隔离级别下的锁" class="headerlink" title="读未提交隔离级别下的锁"></a>读未提交隔离级别下的锁</h6><p> <strong>READ UNCOMMITTED 隔离级别下, 写操作是会加锁的, 而且是X排他锁, 直到客户端1事务完成, 锁才释放, 客户端2才能进行写操作</strong></p><p>测试脏读确实会出现，但是测试事务1和事务2同时修改一个字段的时候，如果事务1没有提交，事务二会被排他锁阻塞。</p><p>既然有排他锁，为什么一个拿到排他锁，另外一个还可以读取，是因为读取时不会发出共享锁</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">在 <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span> 级别运行的事务不会发出共享锁来防止其他事务修改当前事务读取的数据, 既然不加共享锁了, 那么当前事务所读取的数据自然就可以被其他事务来修改。<br>而且当前事务要读取其他事务未提交的修改, 也不会被排他锁阻止, 因为排他锁会阻止其他事务再对其锁定的数据加读写锁,但是可笑的是, 事务在该隔离级别下去读数据的话根本什么锁都不加, 这就让排他锁无法排它了, 因为它连锁都没有。<br>这就导致了事务可以读取未提交的修改, 称为脏读。<br></code></pre></div></td></tr></table></figure><h6 id="两个事务同时-update"><a href="#两个事务同时-update" class="headerlink" title="两个事务同时 update"></a>两个事务同时 update</h6><p>没有索引，会锁表，过滤，不满足的记录锁释放，</p><p>为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id&#x3D;1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。</p><p>这时我们要注意到，teacher_id是有索引的，如果是没有索引的class_name呢？update class_teacher set teacher_id&#x3D;3 where class_name &#x3D; ‘初三一班’; 那么MySQL会给整张表的所有数据行的加行锁。这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name &#x3D; ‘初三一班’的（没有索引嘛），如果一个条件无法通过索引快速过滤，<strong>存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤</strong>。</p><p>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）</p><p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p><h6 id="RR和RC级别下的-MVCC"><a href="#RR和RC级别下的-MVCC" class="headerlink" title="RR和RC级别下的 MVCC"></a>RR和RC级别下的 MVCC</h6><p>MySQL在RC和RR隔离级别下，是基于MVCC的并发控制。在 <code>InnoDB</code> 存储引擎中，多版本控制 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p><p>在  RR  和 RC 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在  RR 下  <code>MVCC</code> 实现了可重复读和防止部分幻读</p><p>锁定读，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br><span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span> 操作<br></code></pre></div></td></tr></table></figure><p><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</p><p><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</p><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。</p><p>但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong> </p><p><strong>InnoDB 对 MVCC 的实现</strong></p><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 隐藏字段 ：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><p> <strong>ReadView</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadView</span> &#123;<br>  <span class="hljs-comment">/* ... */</span><br><span class="hljs-keyword">private</span>:<br>  trx_id_t m_low_limit_id;      <span class="hljs-comment">/* 大于等于这个 ID 的事务均不可见 */</span><br><br>  trx_id_t m_up_limit_id;       <span class="hljs-comment">/* 小于这个 ID 的事务均可见 */</span><br><br>  trx_id_t m_creator_trx_id;    <span class="hljs-comment">/* 创建该 Read View 的事务ID */</span><br><br>  trx_id_t m_low_limit_no;      <span class="hljs-comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span><br><br>  ids_t m_ids;                  <span class="hljs-comment">/* 创建 Read View 时的活跃事务列表 */</span><br><br>  m_closed;                     <span class="hljs-comment">/* 标记 Read View 是否 close */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">主要有以下字段：<br>m_low_limit_id：目前出现过的最大的事务 ID+<span class="hljs-number">1</span>，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见 <br><br>m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见 <br><br>m_ids：<span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span> 创建时其他未提交的活跃事务 ID 列表。创建 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）<br><br>m_creator_trx_id：创建该 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span> 的事务 ID<br></code></pre></div></td></tr></table></figure><p><img src="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/trans_visible.jpg" alt="trans_visible"></p><p><strong>undo-log</strong></p><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p><ol><li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li><li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li></ol><p><strong>数据可见性算法</strong></p><ol><li><p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p></li><li><p>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p></li><li><p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p></li><li><p>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p><ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li><p>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p></li></ol><p><strong>RC 和 RR 隔离级别下 MVCC 的差异</strong></p><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表</li></ul><h6 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h6><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用  <strong>Next-key Lock</strong>   来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/b3b6a55f.png" alt="innodb_lock_2"></p><p>如图所示，InnoDB使用的是聚集索引，teacher_id身为二级索引，就要维护一个索引字段和主键id的树状结构（这里用链表形式表现），并保持顺序排列。</p><p>Innodb将这段数据分成几个个区间</p><ul><li>(negative infinity, 5],</li><li>(5,30],</li><li>(30,positive infinity)；</li></ul><p>update class_teacher set class_name&#x3D;‘初三四班’ where teacher_id&#x3D;30;不仅用行锁，锁住了相应的数据行；同时也在两边的区间，（5,30]和（30，positive infinity），都加入了gap锁。这样事务B就无法在这个两个区间insert进新数据。</p><p>update的teacher_id&#x3D;20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加gap锁，而其它区间不会影响，事务C正常插入。</p><p>如果使用的是没有索引的字段，比如update class_teacher set teacher_id&#x3D;7 where class_name&#x3D;‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。</p><p>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p><p><strong>MySQL是这么实现的：</strong></p><p>在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系，为了简化，我们用链表结构来表达（实际上是个树形结构，但原理相同）</p><h6 id="Serializable级别的锁"><a href="#Serializable级别的锁" class="headerlink" title="Serializable级别的锁"></a>Serializable级别的锁</h6><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p><p>这里要吐槽一句，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的！</p><h4 id="数据库一致性问题"><a href="#数据库一致性问题" class="headerlink" title="数据库一致性问题"></a>数据库一致性问题</h4><p>1.命中：程序直接从缓存中读取数据</p><p>2.失败：缓存中没有，从数据库中查询，并且同步到缓存中</p><p>3.更新，先更新数据库，再删除缓存</p><p>单点更新策略</p><p>1.先更缓存，在更数据库</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">如果回滚，缓存就要删除<br></code></pre></div></td></tr></table></figure><p>2.先删除缓存，在更数据库</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">A删掉缓存，B请求缓存不在去数据库读a<span class="hljs-operator">=</span><span class="hljs-number">0</span>，A写入数据库a<span class="hljs-operator">=</span><span class="hljs-number">2</span>，B写入缓存a<span class="hljs-operator">=</span><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>3.先更数据库，再更新缓存</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">有可能，AB两个线程同时再更新，<span class="hljs-selector-tag">A</span>更， <span class="hljs-selector-tag">B</span>来更， <span class="hljs-selector-tag">B</span>更新缓存，<span class="hljs-selector-tag">A</span>更新缓存<br></code></pre></div></td></tr></table></figure><p>4.先更新数据库，再删除缓存</p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns"><span class="hljs-keyword">A</span>缓存失效，<span class="hljs-keyword">A</span>请求读取a=<span class="hljs-number">1</span>，B更新a=<span class="hljs-number">2</span>，删除缓存，  <span class="hljs-keyword">A</span>将旧值写入缓存，<br>更新会加锁，比较慢，查询比较快。<br>延迟删除B睡几百ms<br><br><span class="hljs-keyword">A</span>缓存失效，<span class="hljs-keyword">A</span>请求读取a=<span class="hljs-number">1</span>，<span class="hljs-keyword">A</span>将旧值写入缓存， B更新a=<span class="hljs-number">2</span>，删除缓存，  <br></code></pre></div></td></tr></table></figure><p>MySQL读写分离（主从架构模式）</p><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220216235711229.png" alt="image-20220216235711229"></p><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220216235839462.png" alt="image-20220216235839462"></p><p>假如更新失败，或者redis挂掉， </p><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220217000237107.png" alt="image-20220217000237107"></p><h3 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h3><h6 id="Mysql、Oracle默认隔离级别"><a href="#Mysql、Oracle默认隔离级别" class="headerlink" title="Mysql、Oracle默认隔离级别"></a>Mysql、Oracle默认隔离级别</h6><p>参考连接：<a href="https://www.163.com/dy/article/G3F275VB05381TA2.html">https://www.163.com/dy/article/G3F275VB05381TA2.html</a></p><p> Oracle 默认隔离级别是 Read committed（读已提交）</p><p> MySQL 默认隔离级别是 Repeatable read（可重复读）</p><p>原因</p><p><strong>1. 时代背景分析：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Oracle 为商业数据库，服务对象面临的是传统行业。传统场景下，事务的增删改并不是很频繁，通常读和写比较均衡，且写操作是比较常见的一种 DML 方式，故在读写选择时做了折中处理，在一个事务在读操作时，允许其他事务做写操作。<br><br>Oracle 数据库只支持 <span class="hljs-keyword">Serializable</span>（串行化）和 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">committed</span>（读已提交）两种隔离级别，串行化不支持并发，为了保障较好的服务体验，必须保障一定的并发性，于是便默认选择 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">committed</span>（读已提交）隔离模式；但这种模式确实会发生不可重复读和幻读的现风险。这是为什么在 Oracle 中更新一张大表时，常规操作时会依据一定条件做批量写提交，减少其他读事务的不可重复读现象。<br></code></pre></div></td></tr></table></figure><p><strong>2. 场景原因分析：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">随着硬件工艺和制作成本的降低，互联网大并发读访问需求下，越来越多的开源库架构开始使用 <span class="hljs-keyword">share</span>-<span class="hljs-keyword">nothing</span> 的 MPP 架构，MySQL 隔离级别之所以选定为 <span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">read</span>（可重复读）；原因为要能最大限度的满足互联网场景下的高并发访问多次读的需求；且往往在大并发读场景下，分布式架构能有效把读操作进行分库分表式的方法访问，无形中增加了读操作的并行处理能力；<br><br>MySQL 在面临大量的写操作时，<span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">read</span>（可重复读）隔离级别就显得很不友好；一是一个读事务在读取一些行数据时会禁止对这些行的写事务（但允许读事务）；二是一个写事务会禁止其他任何其他事务操作。<br><br>MySQL 事务提交方式为默认提交，即 MySQL 执行每一条增删改 DML 语句后会默认自动提交，对行锁的获取和释放均很快操作结束，最大程度降低了读事务和写事物的冲突；因 MySQL 是 <span class="hljs-keyword">share</span>-<span class="hljs-keyword">nothing</span> 设计架构，自动提交事务的方式也能最大限度的保障从节点能和主库保持数据一致性。<br><br>MySQL 分布式架构也把读和写的操作分散在不同的节点上，也从另一方面降低了读事务和写事务的冲突，从而保障了前段业务的可用性。<br><br>**但如下场景会是一个头疼的事：**当读事务访问的某些数据行和写事务访问的某些行均落在分布式架构的一个节点上，会引起资源争用，这个时候只能等待事务完成，释放资源；或者杀掉某个事务会话，迫使其释放资源，让另一个事务完成后再行执行。<br></code></pre></div></td></tr></table></figure><p><strong>3. 底层设计思维的不同：</strong></p><p><strong>先说 oracle 架构设计思维：</strong></p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">大家都知道 oracle 是基于 share-disk 的设计思维，存储节点只有一份，控制文件、<span class="hljs-keyword">redo</span> 日志、归档日志、数据文件均在共享盘阵上。RAC 架构的数据一致性在计算节点间的内存层 <span class="hljs-keyword">buffer</span> cache 进行保证，然后落盘 <span class="hljs-keyword">redo</span> 日志。因为是在内存级别保证数据一致性，且 <span class="hljs-keyword">redo</span> 是顺序化的写入，故处理速度会非常快，Oracle 在一个事务提交后，会依据如下条生成 <span class="hljs-keyword">redo</span> 日志，<span class="hljs-keyword">redo</span> 日志记录的是发生变化的数据块，包含已经提交和未提交的（The <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> records <span class="hljs-keyword">all</span> <span class="hljs-keyword">changes</span> made <span class="hljs-keyword">to</span> data, including both uncommitted <span class="hljs-built_in">and</span> committed <span class="hljs-keyword">changes</span>.）。Redo 的功能主要通过 <span class="hljs-number">3</span> 个组件来实现：Redo Log Buffer、LGWR 后台进程和 Redo Log File。<br><br>因为 <span class="hljs-keyword">redo</span> 日志的刷新机制速度快且较为频繁（见下文），故 Oracle 虽然采用 Read committed（读已提交），也能最大限度的减少其他读事务的不可重复读现象。<br><br>Redo Log Buffer：如果数据需要写到在线重做日志中，则在写至磁盘之前要在 Redo Buffer 中临时缓存这些数据。由于内存到内存的传输比内存到磁盘的传输快得多，因此使用重做日志 Buffer 可以加快数据库的操作。数据在重做缓冲区的停留时间不会太长。实际上 LGWR 会在以下某个情况发生时启动对这个区的刷新输出(flush):<br><br>\* 每 <span class="hljs-number">3</span> 秒一次<br><br>\* 无论何时有人提交请求<br><br>\* 要求 LGWR 切换日志文件<br><br>\* 重做缓冲区 <span class="hljs-number">1</span>/<span class="hljs-number">3</span> 满，或者包含了 <span class="hljs-number">1</span>MB 的缓存重做日志数据<br></code></pre></div></td></tr></table></figure><p><strong>再谈 MySQL 设计思维：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">MySQL 是基于 <span class="hljs-keyword">share</span>-<span class="hljs-keyword">nothing</span> 的设计思维，所有的计算节点和存储节点为自身独享，通过网络来保持主从间的同步。不像 oracle 的 <span class="hljs-keyword">share</span>-disk 共享存储的设计架构（所有数据共享一份数据存储）；MySQL 主从节点为保持数据的一致性，须尽快将主库事务落盘，通过网络把主库的 bin-<span class="hljs-keyword">log</span> 日志传送至从库，从库根据中继日志 relay-<span class="hljs-keyword">log</span> 中抽取的 <span class="hljs-keyword">sql</span> 重新执行，达到主从库数据一致性，然后才能满足业务对从库的数据读取，实现读写分离。为此，MySQL 主库在执行完一个增删改的 DML 操作时，默认进行提交，有助于主库尽快将该事务通过网络同步至从库；也有助于降低读事务和写事务的冲突。<br><br>通常，MySQL 主从架构在通过半同步方式强化主从库的数据一致性；Innodb <span class="hljs-keyword">cluster</span> 使用 paxos 协议（二阶段提交）来保证集群环境的数据一致性。<br></code></pre></div></td></tr></table></figure><h6 id="MySQL缓存和Mybatis缓存"><a href="#MySQL缓存和Mybatis缓存" class="headerlink" title="MySQL缓存和Mybatis缓存"></a>MySQL缓存和Mybatis缓存</h6><p><strong>MySQL缓存</strong></p><p>何时缓存：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">缓存的 key：<span class="hljs-keyword">SQL</span> （所以<span class="hljs-keyword">sql</span>语句要完全相同才能使用上缓存）<br>缓存的 <span class="hljs-keyword">value</span>：结果集<br><span class="hljs-keyword">where</span>条件中如包含了某些函数永远不会被缓存, 比如<span class="hljs-built_in">current_date</span>, now等<br>太大的结果集不会被缓存<br></code></pre></div></td></tr></table></figure><p>何时缓存失效：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">表数据有任何修改，则有关于该表的数据全部失效<br></code></pre></div></td></tr></table></figure><p><strong>MyBatis缓存</strong></p><p>一级缓存</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">一级缓存是SqlSession级别的缓存，对于相同的查询，会从缓存中返回结果而不是查询数据库作用域是SqlSession<br></code></pre></div></td></tr></table></figure><p>二级缓存</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl">二级缓存是<span class="hljs-variable">Mapper</span>级别的缓存，定义在<span class="hljs-variable">Mapper</span>文件的标签中并需要开启此缓存，多个<span class="hljs-variable">Mapper</span>文件可以共用一个缓存，依赖标签配置。作用域是一个<span class="hljs-function"><span class="hljs-title">NameSpace</span>( 一般情况下一个<span class="hljs-variable">NameSpace</span>即一个<span class="hljs-variable">Mapper</span>)</span><br></code></pre></div></td></tr></table></figure><p>二级缓存不建议使用，因为二级缓存有严重的使用问题：</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">MapperA联合查询AB表中数据<br>MapperA：<span class="hljs-keyword">select</span> <span class="hljs-keyword">from</span> tableA <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tableB <span class="hljs-keyword">on</span> ……<br>MapperB修改了数据<br>MapperB：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tableB <span class="hljs-keyword">values</span> ……<br>由于MapperA和MapperB不在同一个作用域，即使MapperB新增了数据，MapperA缓存也不会刷新，造成MapperA查到的数据是脏数据。<br></code></pre></div></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h6 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h6><p>@Data：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">注解在类上；提供类所有属性的<span class="hljs-keyword">get</span>和<span class="hljs-keyword">set</span>方法，此外还提供了<span class="hljs-keyword">equals</span>、canEqual、hashCode、toString 方法。<br></code></pre></div></td></tr></table></figure><p>@Getter</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">注解在属性上；为单个属性提供 <span class="hljs-keyword">get</span> 方法; 注解在类上，为该类所有的属性提供<span class="hljs-keyword">get</span>方法，都提供默认构造方法。<br></code></pre></div></td></tr></table></figure><p>@Setter</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">注解在属性上；为单个属性提供<span class="hljs-keyword">set</span>方法; 注解在类上，为该类所有的属性提供<span class="hljs-keyword">set</span>方法， 都提供默认构造方法。<br></code></pre></div></td></tr></table></figure><p>@Log4j</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">注解在类上；为类提供一个 属性名为 <span class="hljs-built_in">log</span> 的 log4j 日志对象，提供默认构造方法。<br></code></pre></div></td></tr></table></figure><p>@AllArgsConstructor</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">注解在类上；为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了。<br></code></pre></div></td></tr></table></figure><p>@NoArgsConstructor</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">注解在类上；为类提供一个无参的构造方法。<br></code></pre></div></td></tr></table></figure><p>@EqualsAndHashCode</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">注解在类上, 可以生成 <span class="hljs-keyword">equals</span>、canEqual、hashCode 方法。<br></code></pre></div></td></tr></table></figure><p>@NonNull</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">注解在属性上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。<br></code></pre></div></td></tr></table></figure><p>@Cleanup</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">这个注解用在 变量 前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的 <span class="hljs-built_in">close</span>() 方法，如果该资源有其它关闭方法，可使用 <span class="hljs-keyword">@Cleanup</span>(“methodName”) 来指定要调用的方法，也会生成默认的构造方法<br></code></pre></div></td></tr></table></figure><p>@ToString</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">这个注解用在 类 上，可以生成所有参数的 <span class="hljs-built_in">toString</span> 方法，还会生成默认的构造方法。<br></code></pre></div></td></tr></table></figure><p>@RequiredArgsConstructor</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj">这个注解用在类上，使用类中所有带有 <span class="hljs-meta">@NonNull</span> 注解的或者带有 <span class="hljs-keyword">final</span> 修饰的成员变量生成对应的构造方法。<br></code></pre></div></td></tr></table></figure><p>@Value</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">这个注解用在类上，会生成含所有参数的构造方法，<span class="hljs-keyword">get</span> 方法，此外还提供了<span class="hljs-keyword">equals</span>、hashCode、toString 方法。<br></code></pre></div></td></tr></table></figure><p>@SneakyThrows</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">这个注解用在方法上，可以将方法中的代码用 <span class="hljs-keyword">try</span>-catch 语句包裹起来，捕获异常并在 catch 中用 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lombok</span>.</span></span>sneaky<span class="hljs-constructor">Throw(<span class="hljs-params">e</span>)</span> 把异常抛出，可以使用 @<span class="hljs-constructor">SneakyThrows(Exception.<span class="hljs-params">class</span>)</span> 的形式指定抛出哪种异常，也会生成默认的构造方法。<br></code></pre></div></td></tr></table></figure><p>@Synchronized</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">这个注解用在 类方法 或者 实例方法 上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 <span class="hljs-keyword">class</span> 对象和 <span class="hljs-symbol">this</span> 对象，而 @<span class="hljs-symbol">Synchronized</span> 的锁对象分别是 私有静态 <span class="hljs-symbol">final</span> 对象 <span class="hljs-symbol">lock</span> 和 私有 <span class="hljs-symbol">final</span> 对象 <span class="hljs-symbol">lock</span>，当然，也可以自己指定锁对象，此外也提供默认的构造方法。<br></code></pre></div></td></tr></table></figure><h4 id="（待整理）Mybatis缓存"><a href="#（待整理）Mybatis缓存" class="headerlink" title="（待整理）Mybatis缓存"></a>（待整理）Mybatis缓存</h4><p><strong>查询的时候，先看二极缓存有没有，然后再看一级缓存</strong></p><p><strong>SqlSession关闭连接， 会把一级缓存保存到二级缓存里边</strong></p><p>在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。</p><p>参考资料：<a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制</a></p><h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><h6 id="一级缓存介绍"><a href="#一级缓存介绍" class="headerlink" title="一级缓存介绍"></a>一级缓存介绍</h6><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。</p><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220302142440084.png" alt="image-20220302142440084"></p><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。具体实现类的类关系图如下图所示。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d76ec5fe.jpg" alt="img"></p><h6 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h6><p>开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>SESSION</code>或者<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。</p><p>参数：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">SESSION(默认)MyBatis会话中执行的所有语句都会共享这一个缓存<br>STATEMENT缓存只对当前执行的这一个Statement有效<br><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h6 id="一级缓存工作流程-amp-源码分析"><a href="#一级缓存工作流程-amp-源码分析" class="headerlink" title="一级缓存工作流程&amp;源码分析"></a>一级缓存工作流程&amp;源码分析</h6><p>工作流程</p><p><img src="/2022/04/27/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9/Users\baixxq\AppData\Roaming\Typora\typora-user-images\image-20220302143402698.png" alt="image-20220302143402698"></p><p>源码分析</p><p><strong>SqlSession</strong>： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是<code>DefaultSqlSession</code>。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ba96bc7f.jpg" alt="img"></p><p><strong>Executor</strong>： <code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ef5e0eb3.jpg" alt="img"></p><p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/83326eb3.jpg" alt="img"></p><p>在一级缓存的源码分析中，主要学习<code>BaseExecutor</code>的内部实现。</p><p><strong>BaseExecutor</strong>： <code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doUpdate</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> List&lt;BatchResult&gt; <span class="hljs-title function_">doFlushStatements</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isRollback)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;E&gt; Cursor&lt;E&gt; <span class="hljs-title function_">doQueryCursor</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException;<br></code></pre></div></td></tr></table></figure><p>在一级缓存的介绍中提到对<code>Local Cache</code>的查询和写入是在<code>Executor</code>内部完成的。在阅读<code>BaseExecutor</code>的代码后发现<code>Local Cache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br><span class="hljs-keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;<br><span class="hljs-keyword">protected</span> PerpetualCache localCache;<br></code></pre></div></td></tr></table></figure><p><strong>Cache</strong>： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/793031d0.jpg" alt="img"></p><p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cdb21712.jpg" alt="img"></p><h4 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h4><h6 id="Mybatis流程执行分析"><a href="#Mybatis流程执行分析" class="headerlink" title="Mybatis流程执行分析"></a>Mybatis流程执行分析</h6><p>1.Resources获取加载全局配置文件</p><p>2.实例化SqlSessionFactoryBuilder构造器</p><p>3.解析配置文件流XMLConfigBuilder</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br></code></pre></div></td></tr></table></figure><p>4.Configuration所有的配置信息</p><p>5.SqlSessionFactory实例化</p><p>6.transactional事务管理器</p><p>6.创建executor执行器</p><p>7.创建SqlSession</p><p>8.实现CURD,失败回滚到6</p><p>9.提交事务</p><p>10.关闭</p><h6 id="和-的区别"><a href="#和-的区别" class="headerlink" title="${}和#{}的区别"></a>${}和#{}的区别</h6><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="language-xml">1）#</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">是预编译处理，$</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">是字符串替换。</span><br><span class="language-xml"></span><br><span class="language-xml">2）MyBatis在处理#</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">时，会将SQL中的#</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">替换为?号，使用PreparedStatement的set方法来赋值；MyBatis在处理 $ </span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"> 时，就是把 $</span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"> 替换成变量的值。</span><br><span class="language-xml"></span><br><span class="language-xml">3）使用 #</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> 可以有效的防止SQL注入，提高系统安全性。</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">（2）预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。在某些特殊场合下只能用$</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">，不能用#</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">。例如：在使用排序时ORDER BY $</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">，如果使用#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">，则会被解析成ORDER BY “id”,这显然是一种错误的写法。</span><br></code></pre></div></td></tr></table></figure><h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><h6 id="Spring的优点-？"><a href="#Spring的优点-？" class="headerlink" title="Spring的优点 ？"></a>Spring的优点 ？</h6><ul><li>简化开发，解耦，集成其它框架。</li><li>低侵入式设计，代码污染级别较低。</li><li>Spring的DI机制降低了业务对象替换的复杂性，提高了软件之间的解耦。</li><li>Spring AOP支持将一些通用的任务进行集中式的管理，例如：安全，事务，日志等，从而使代码能更好的复用。</li></ul><h5 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h5><p>问题：什么是控制反转（IOC），什么是依赖注入（DI）？</p><ul><li>IOC：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。</li><li>DI：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。</li><li>控制反转是目标，依赖注入是我们实现控制反转的一种手段。</li></ul><p>举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。</p><p>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20171113/1510581504339027.png" alt="img"></p><h6 id="Java-中实现依赖注入的三种方式？"><a href="#Java-中实现依赖注入的三种方式？" class="headerlink" title="Java  中实现依赖注入的三种方式？"></a><strong>Java  中实现依赖注入的三种方式？</strong></h6><p>依赖注入：</p><p>依赖：bean中的对象创建依赖于容器    注入：bean对象中的所有属性，由容器来注入</p><ul><li>构造器注入</li><li>set方法注入</li><li>接口注入</li><li>C&#x2F;P标签注入</li></ul><h6 id="Spring容器中如何创建对象？"><a href="#Spring容器中如何创建对象？" class="headerlink" title="Spring容器中如何创建对象？"></a><strong>Spring容器中如何创建对象？</strong></h6><p>​无参构造创建 静态工厂创建 实例工厂创建</p><h6 id="Spring有几种自动装配方式"><a href="#Spring有几种自动装配方式" class="headerlink" title="Spring有几种自动装配方式"></a><strong>Spring有几种自动装配方式</strong></h6><ul><li>基于XML文件的配置 这种配置文件的格式常用<beans>开头，然后运用一系列的bean定义和专门的应用配置选项组成。 Spring XML配置方式是使用被Spring命名空间所支持的一些列XML的标签来实现的。</beans></li></ul><p>​byname装配     byType装配</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">autowire</span> = <span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>隐式的自动装配</strong></p><ul><li>基于注解的配置 可以使用注解的方式来代替XML方式的bean元素的配置。这就是组件扫描，常用依赖注入的一些注解有： @Controller @Service @Autowired @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @Resource @PostConstruct @PreDestroy @Repository @Scope @SessionAttributes @InitBinder @Required @Qualifier</li></ul><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">1.要导入约束的支持xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>2.导入注解的支持<span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>&gt;</span><br>3.在属性上用就可以，自动注入，反射实现的<br> <br></code></pre></div></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span> <span class="hljs-variable">@Resource</span>区别<br>都是自动装配的，都可以放在属性上<br><span class="hljs-variable">@Autowired</span>通过bytye，而且要求对象必须存在<br><span class="hljs-variable">@Resource</span>默认byname，但是没有名字会通过bytype，如果两个都没有报错<br></code></pre></div></td></tr></table></figure><ul><li>组件扫描： 容器会扫描base-package指定的包及其子包下面的所有类，如果该类有一些特定的注解，则纳入容器进行管理。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">类上边注解<span class="hljs-meta">@Component</span>，类托管给Spring，类似的组件,全都一样，代表类注册到Spring<br><span class="hljs-meta">@Repository</span>    dao层<br><span class="hljs-meta">@Service</span>Service<br><span class="hljs-meta">@Controller</span>Controller <br><br><span class="hljs-meta">@value(“”)</span>给属性注入值<br><br><span class="hljs-meta">@Scope(“prototype”)</span>  配置单例模式，原型模式，在类上<br></code></pre></div></td></tr></table></figure><ul><li><p>在类前面添加的一些特定的注解： @Component 通用注解 @Repository 持久层注解 @Service 业务层注解、 @Controller 控制层注解</p></li><li><p>基于Java的配置</p></li></ul><h6 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h6><table><thead><tr><th><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton">singleton</a></th><th>(Default) 将单个 bean 定义限定为每个 Spring IoC 容器的单个对象实例</th></tr></thead><tbody><tr><td><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype">prototype</a></td><td>将单个 bean 定义限定为任意数量的对象实例。</td></tr><tr><td><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request">request</a></td><td>将单个 bean 定义限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 Web 感知 Spring 的上下文中有效<code>ApplicationContext</code>。</td></tr><tr><td><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session">session</a></td><td>将单个 bean 定义限定为 HTTP 的生命周期<code>Session</code>。仅在 Web 感知 Spring 的上下文中有效<code>ApplicationContext</code>。</td></tr><tr><td><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application">application</a></td><td>将单个 bean 定义限定为<code>ServletContext</code>. 仅在 Web 感知 Spring 的上下文中有效<code>ApplicationContext</code></td></tr><tr><td><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope">websocket</a></td><td>将单个 bean 定义限定为<code>WebSocket</code>. 仅在 Web 感知 Spring 的上下文中有效<code>ApplicationContext</code>。</td></tr></tbody></table><p>单例模式（Spring默认机制）</p><p>将单个 bean 定义限定为每个 Spring IoC 容器的单个对象实例。</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><p>原型模式</p><p>每次从容器中get的时候，都会产生一个新的对象</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><p>代理模式</p><p>​静态代理</p><p>​动态代理</p><p>使用Spring实现AOP</p><p>方式一：使用Spring的API接口，主要SpringAPI</p><p>方式二：自定义来实现AOP【主要是切面定义】</p><p>方式三：注解实现</p><p>Mybatis   事务托管，</p><p>AOP方式</p><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h6 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a><strong>SpringBoot优点</strong></h6><p><strong>1.嵌web服务器，</strong></p><p>应用最终会达成war包，目标环境需要装tomcat，SpringBoot则不需要</p><p><strong>2.自动starter依赖，简化构建</strong></p><p>Spring整合MyBatis、MVC等，需要版本各个对应。比如web开发，只需要导入web，他会自动导入mvc、核心处理等依赖</p><p><strong>3.自动配置Spring以及第三方功能</strong></p><p><strong>4.提供生产级别的监控，健康检查以及外部配置</strong></p><p>要修改配置，无需打开源代码，在外部直接引入一个配置就可以。</p><h1 id="GoGoCoder"><a href="#GoGoCoder" class="headerlink" title="GoGoCoder"></a>GoGoCoder</h1><h6 id="hashmap底层原理（数据结构、为什么用红黑树等）"><a href="#hashmap底层原理（数据结构、为什么用红黑树等）" class="headerlink" title="hashmap底层原理（数据结构、为什么用红黑树等）"></a><strong>hashmap底层原理（数据结构、为什么用红黑树等）</strong></h6><p>在回答这个问题之前，我们先了解一下有关二叉树的基本内容。<br>①二叉排序树(又称二叉查找树)：<br>1)若左子树不为空，则左子树上所有结点的值均小于根结点的值。<br>2)若右子树不为空，则右子树上所有结点的值均大于根节点的值。<br>3)左右子树也为二叉排序树。</p><p>②平衡二叉树(AVL树)：是一种二叉查找树，当且仅当两个子树的高度差不超过1时，这个树是平衡二叉树。</p><p>③红黑树：是许多二叉查找树中的一种，它能保证在最坏的情况下，基本动态集合操作时间为O(lgn).</p><p>问题1：为什么不使用二叉排序树？</p><p>问题主要出现在二叉排序树在添加元素的时候极端情况下会出现线性结构。</p><p>举例说明：由于二叉排序树左子树所有节点的值均小于根节点的特点，如果我们添加的元素都比根节点小，会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷，导致查询时间增长。所以这是不用二叉查找树的原因。</p><p>问题2：为什么不使用平衡二叉树呢？</p><p><em>①红黑树不追求”完全平衡”，即不像AVL那样要求节点的 |balFact| &lt;&#x3D; 1，它只要求部分达到平衡，但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。<br>   就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)<br>删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！<br>   AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，如2所述，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。<br>针对插入和删除节点导致失衡后的rebalance操作，红黑树能够提供一个比较”便宜”的解决方案，降低开销，是对search，insert ，以及delete效率的折衷，总体来说，RB-Tree的统计性能高于AVL.<br>故引入RB-Tree是功能、性能、空间开销的折中结果。<br>② AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。</em><br>③ 红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。<br>基本上主要的几种平衡树看来，红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。*</p><h6 id="索引的数据结构对比（hash、B树与B-树），为什么不用红黑树"><a href="#索引的数据结构对比（hash、B树与B-树），为什么不用红黑树" class="headerlink" title="索引的数据结构对比（hash、B树与B+树），为什么不用红黑树"></a><strong>索引的数据结构对比（hash、B树与B+树），为什么不用红黑树</strong></h6><h6 id="Jvm内存模型"><a href="#Jvm内存模型" class="headerlink" title="Jvm内存模型"></a><strong>Jvm内存模型</strong></h6><h6 id="Java线程池核心参数与工作流程，拒绝策略"><a href="#Java线程池核心参数与工作流程，拒绝策略" class="headerlink" title="Java线程池核心参数与工作流程，拒绝策略"></a><strong>Java线程池核心参数与工作流程，拒绝策略</strong></h6><ul><li><p><strong>线程池的核心参数</strong></p><p><img src="https://img-blog.csdnimg.cn/20200818154619705.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNDQ4MTY=,size_16,color_FFFFFF,t_70" alt="img">corePoolSize: 线程池中的核心线程数，规定的是线程池中的常驻线程worker 的数量<br>maximumPoolSize：线程池的线程最大并行数量，规定的是线程池允许的最大的并行线程数量，在核心线程worker 已满 且 队列已满的情况下，会启动非核心的 线程worker 来执行任务<br>workQueue：核心执行线程已满时用于存放任务的阻塞队列，推荐使用带有边界的ArrayBlockingQueue</p></li></ul><p>线程池调度方式</p><p>线程池的调度，我主要是指线程池当进入一个新任务时是如何完成整个生命周期的，</p><p>新的任务进入 &#x3D;&gt;<br>先查询核心worker数是否已满 ? 未满则新增核心worker执行任务 ，<br>已满则查看阻塞队列，阻塞队列未满则加入阻塞队列，<br>已满 且 查看最大并行线程数是否已满，<br>已满则调用拒绝策略，拒绝接受新增任务<br>未满则新增非核心worker处理该任务</p><p>也就是说，<br>线程池的最大并行数是MAX_SIZE;<br>线程池的最大任务容量是MAX_SIZE + BlockingQueue.size()<br>同时，当我们设置阻塞队列的时候 如果采用 阻塞队列时如果 采用无边界的队列，或者不设置边界，在极端情况下对应用是危险的，会因为 Task的堆积发生OOM，这也是阿里大佬在小本本上要求自己去实现ThreadLocalPool 而不使用Executors中提供的线程池的原因。</p><p>线程池中的拒绝策略<br>实现自己的线程池拒绝策略就是这个接口，在线程池已满的情况下，我们可以把任务放进MQ，Redis，<br>应用内部队列中保存起来，找特定的时间窗口再去执行，当然，具体情况具体分析，反正接口，他就在那里</p><p>JDK大佬提供的拒绝策略：<br>AbortPolicy（默认）：直接报错<br>DiscardPolicy：不报错，悄悄的就丢了，注意是悄悄的，什么反应都没有<br>DiscardOldestPolicy：不报错，悄悄的把队列中等得最久得丢了<br>CallerRunsPolicy：调用者自己处理</p><h6 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h6><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p><p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p>TCP UDP<br>TCP与UDP基本区别<br>1.基于连接与无连接<br>2.TCP要求系统资源较多，UDP较少；<br>3.UDP程序结构较简单<br>4.流模式（TCP）与数据报模式(UDP);<br>5.TCP保证数据正确性，UDP可能丢包<br>6.TCP保证数据顺序，UDP不保证</p>]]></content>
    
    
    <categories>
      
      <category>面试问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习</title>
    <link href="/2022/04/26/Spring/"/>
    <url>/2022/04/26/Spring/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Spring"><a href="#一、Spring" class="headerlink" title="一、Spring"></a>一、Spring</h3><h4 id="1-Spring概念"><a href="#1-Spring概念" class="headerlink" title="1.Spring概念"></a>1.Spring概念</h4><p>Spring是分层的Java SE&#x2F;EE 应用 &#x3D;&#x3D;full-stack&#x3D;&#x3D; 轻量级开源框架，以&#x3D;&#x3D;IoC（Inverse Of Control：反转控制）&#x3D;&#x3D;和&#x3D;&#x3D;AOP（Aspect Oriented Programming：面向切面编程）&#x3D;&#x3D;为内核，提供了展现层Spring MVC 和持久层Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.Spring是轻量级的开源的<span class="hljs-keyword">JavaEE框架</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>.Spring解决企业应用开发的复杂性<br><span class="hljs-number">3</span>.Spring有两大核心部分，IOC和Aop<br>IOC：控制反转，把创建对象的过程交给Spring进行管理<br>Aop：面向贴面，不修改源代码进行功能增强<br><span class="hljs-number">4</span>.Spring特点<br>    （<span class="hljs-number">1</span>）方便解耦，简化开发<br>    （<span class="hljs-number">2</span>） Aop 编程支持<br>    （<span class="hljs-number">3</span>）方便程序测试<br>    （<span class="hljs-number">4</span>）方便和其他框架进行整合<br>    （<span class="hljs-number">5</span>）方便进行事务操作<br>    （<span class="hljs-number">6</span>）降低 API 开发难度<br></code></pre></div></td></tr></table></figure><h5 id="1-Spring的发展历程"><a href="#1-Spring的发展历程" class="headerlink" title="(1) Spring的发展历程"></a>(1) Spring的发展历程</h5><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1997</span><span class="hljs-string">年IBM提出了EJB的思想</span><br><span class="hljs-number">1998</span><span class="hljs-string">年，SUN制定开发标准规范EJB1.0</span><br><span class="hljs-number">1999</span><span class="hljs-string">年，EJB1.1发布</span><br><span class="hljs-number">2001</span><span class="hljs-string">年，EJB2.0发布</span><br><span class="hljs-number">2003</span><span class="hljs-string">年，EJB2.1发布</span><br><span class="hljs-number">2006</span><span class="hljs-string">年，EJB3.0发布</span><br><span class="hljs-string">Rod</span> <span class="hljs-string">Johnson（spring之父）</span><br><span class="hljs-string">Expert</span> <span class="hljs-string">One-to-One</span> <span class="hljs-string">J2EE</span> <span class="hljs-string">Design</span> <span class="hljs-string">and</span> <span class="hljs-string">Development(2002)</span><br><span class="hljs-string">阐述了J2EE使用EJB开发设计的优点及解决方案</span><br><span class="hljs-string">Expert</span> <span class="hljs-string">One-to-One</span> <span class="hljs-string">J2EE</span> <span class="hljs-string">Development</span> <span class="hljs-string">without</span> <span class="hljs-string">EJB(2004)</span><br><span class="hljs-string">阐述了J2EE开发不使用EJB的解决方式（Spring雏形）</span><br><span class="hljs-number">2017</span><span class="hljs-string">年9月份发布了spring的最新版本spring</span> <span class="hljs-number">5.0</span><span class="hljs-string">通用版（GA）</span><br></code></pre></div></td></tr></table></figure><h5 id="2-spring的优势"><a href="#2-spring的优势" class="headerlink" title="(2) spring的优势"></a>(2) spring的优势</h5><p>方便解耦，简化开发</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。<br></code></pre></div></td></tr></table></figure><p>AOP编程的支持</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。<br></code></pre></div></td></tr></table></figure><p>声明式事务的支持</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。<br></code></pre></div></td></tr></table></figure><p>方便程序的测试</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。<br></code></pre></div></td></tr></table></figure><p>方便集成各种优秀框架</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">Spring</span>可以降低各种框架的使用难度，提供了对各种优秀框架（<span class="hljs-variable">Struts</span>、<span class="hljs-variable">Hibernate</span>、<span class="hljs-built_in">Hessian</span>、<span class="hljs-variable">Quartz</span>等）的直接支持。<br></code></pre></div></td></tr></table></figure><p>降低JavaEE API的使用难度</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">Spring对<span class="hljs-keyword">JavaEE </span>API（如<span class="hljs-keyword">JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</span><br></code></pre></div></td></tr></table></figure><p>Java源码是经典学习范例</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。<br></code></pre></div></td></tr></table></figure><h2 id="二、IOC容器"><a href="#二、IOC容器" class="headerlink" title="二、IOC容器"></a>二、IOC容器</h2><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想，</p><p>传统的Java SE程序，都是程序员去new创建对象，IOC就是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建，把程序员去制动创建对象控制对象编程，程序员被动接收容器给的对象。</p><p><strong>Spring所倡导的开发方式</strong>就是如此，<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p><p><strong>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的</strong>。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p><p>类耦合，需要重新修改代码， 打包，上线，配置文件耦合，只需要发给服务器，读取新的就行了。配置与资源的耦合</p><p>Spring scope &#x3D; single   &#x2F;&#x2F;单例对象创建时间，加载容器的时候创建的</p><p>Spring scope &#x3D; propertype &#x2F;&#x2F;原型对象创建时间，加载容器的时候不创建，获取对象的时候创建</p><p>prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><ul><li><code>singleton</code> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li><li><code>request</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><code>global-session</code>： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p>而对于 Spring Bean 的生命周期来说：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><h2 id="三、Aop"><a href="#三、Aop" class="headerlink" title="三、Aop"></a>三、Aop</h2><h2 id="四、JdbcTemplate"><a href="#四、JdbcTemplate" class="headerlink" title="四、JdbcTemplate"></a>四、JdbcTemplate</h2><h2 id="五、事务管理"><a href="#五、事务管理" class="headerlink" title="五、事务管理"></a>五、事务管理</h2><h2 id="六、Spring5新特性"><a href="#六、Spring5新特性" class="headerlink" title="六、Spring5新特性"></a>六、Spring5新特性</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习</title>
    <link href="/2022/04/26/Nginx%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/26/Nginx%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Nginx快速配置"><a href="#一、Nginx快速配置" class="headerlink" title="一、Nginx快速配置"></a>一、Nginx快速配置</h2><h3 id="1、Nginx快速安装"><a href="#1、Nginx快速安装" class="headerlink" title="1、Nginx快速安装"></a>1、Nginx快速安装</h3><p>  以 CentOS7 为例，介绍如在虚拟机快速安装并配置 Nginx-1.21 </p><p>1、安装 Nginx 之前，虚拟机需要 gcc 安装环境 、 pcre 库 、zlib 库</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#安装 gcc 、 pcre 库 、zlib 库 ，注意虚拟机要有网</span><br><span class="hljs-string">yum</span> <span class="hljs-string">install</span> <span class="hljs-string">-y</span> <span class="hljs-string">gcc</span> <span class="hljs-string">pcre</span> <span class="hljs-string">pcre-devel</span> <span class="hljs-string">zlib</span> <span class="hljs-string">zlib-devel</span><br></code></pre></div></td></tr></table></figure><p>2、安装Nginx，直接从官网下载Nginx的安装包</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#解压缩</span><br><span class="hljs-string">tar</span> <span class="hljs-string">zxvf</span> <span class="hljs-string">nginx-1.21.tar.gz</span><br><span class="hljs-comment"># cd 到解压缩的文件 ./configure  运行就可以安装 , 我这里安装到/usr/local/nginx目录下</span><br><span class="hljs-string">./configure</span> <span class="hljs-string">--prefix=/usr/local/nginx</span><br><span class="hljs-comment"># ok,恭喜你安装好啦！</span><br><span class="hljs-string">make</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">make</span> <span class="hljs-string">install</span><br></code></pre></div></td></tr></table></figure><p>3、接下来就是启动Nginx了</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 进入到安装目录下的nginx/sbin/</span><br><span class="hljs-string">cd</span> <span class="hljs-string">/usr/local/nginx/sbin/</span><br><span class="hljs-comment"># 启动nginx</span><br><span class="hljs-string">./nginx</span><br><span class="hljs-comment"># ok,恭喜你启动好啦！  查看进程</span><br><span class="hljs-string">ps</span> <span class="hljs-bullet">-</span> <span class="hljs-string">ef</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">nginx</span><br></code></pre></div></td></tr></table></figure><p>4、此时，还不能直接访问  localhost   ，因为防火墙可能没放行呀，防火墙开放80端口</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#放行端口</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-string">--zone=public</span> <span class="hljs-string">--add-port=80/tcp</span> <span class="hljs-string">--permanent</span><br><span class="hljs-comment">#重启防火墙，注意改完要重启一下才能生效</span><br><span class="hljs-string">firewall-cmd</span> <span class="hljs-string">--reload</span><br></code></pre></div></td></tr></table></figure><p>5、如果想要Nginx配置成开机自启动，就需要把他安装成系统服务，设置开启自启动</p><p>​（1）首先创建脚本服务</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#创建脚本服务</span><br><span class="hljs-string">vi</span> <span class="hljs-string">/usr/lib/systemd/system/nginx.service</span><br></code></pre></div></td></tr></table></figure><p>​（2）脚本的内容为（注意里边的文件路径要写自己的的呀）</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml">[<span class="hljs-string">Unit</span>]<br><span class="hljs-string">Description=nginx</span> <span class="hljs-bullet">-</span> <span class="hljs-string">web</span> <span class="hljs-string">server</span><br><span class="hljs-string">After=network.target</span> <span class="hljs-string">remote-fs.target</span> <span class="hljs-string">nss-lookup.target</span><br>[<span class="hljs-string">Service</span>]<br><span class="hljs-string">Type=forking</span><br><span class="hljs-string">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="hljs-string">ExecStartPre=/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">-t</span> <span class="hljs-string">-c</span> <span class="hljs-string">/usr/local/nginx/conf/nginx.conf</span><br><span class="hljs-string">ExecStart=/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">-c</span> <span class="hljs-string">/usr/local/nginx/conf/nginx.conf</span><br><span class="hljs-string">ExecReload=/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">-s</span> <span class="hljs-string">reload</span><br><span class="hljs-string">ExecStop=/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">-s</span> <span class="hljs-string">stop</span><br><span class="hljs-string">ExecQuit=/usr/local/nginx/sbin/nginx</span> <span class="hljs-string">-s</span> <span class="hljs-string">quit</span><br><span class="hljs-string">PrivateTmp=true</span><br>[<span class="hljs-string">Install</span>]<br><span class="hljs-string">WantedBy=multi-user.target</span><br></code></pre></div></td></tr></table></figure><p>​（3）重启加载系统服务</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">systemctl</span> <span class="hljs-string">daemon-reload</span><br></code></pre></div></td></tr></table></figure><p>​（4）启动服务</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">nginx.service</span><br></code></pre></div></td></tr></table></figure><p>​（5）配置开机自启动</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">nginx.service</span><br></code></pre></div></td></tr></table></figure><p>这里再提供一种在线安装的方式，更加简单快捷，默认配置文件在  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf   下</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#也需要先安装 pcre库 、zlib库 、openssl   ，然后 首先安装Nginx的库</span><br><span class="hljs-string">rpm</span> <span class="hljs-string">-Uvh</span> <span class="hljs-string">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="hljs-comment">#安装Nginx</span><br><span class="hljs-string">yum</span> <span class="hljs-string">-y</span> <span class="hljs-string">install</span> <span class="hljs-string">nginx</span><br><span class="hljs-comment">#可以直接设置开机自启动</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">nginx.service</span><br></code></pre></div></td></tr></table></figure><h3 id="2、Nginx快速配置"><a href="#2、Nginx快速配置" class="headerlink" title="2、Nginx快速配置"></a>2、Nginx快速配置</h3><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">####我这里两台Nginx的配置都一样####</span><br><span class="hljs-string">worker_processes</span>  <span class="hljs-number">1</span><span class="hljs-string">;</span><span class="hljs-comment">#指定工作线程数</span><br><span class="hljs-string">events</span> &#123;<br>    <span class="hljs-string">worker_connections</span>  <span class="hljs-number">1024</span><span class="hljs-string">;</span><span class="hljs-comment">#最大连接数</span><br>&#125;<br><span class="hljs-comment">#HTTP块</span><br><span class="hljs-string">http</span> &#123;<br>    <span class="hljs-string">include</span>       <span class="hljs-string">mime.types;</span><span class="hljs-comment">#文件扩展名与文件类型映射表</span><br>    <span class="hljs-string">default_type</span>  <span class="hljs-string">application/octet-stream;</span><span class="hljs-comment">#默认文件类型，</span><br>    <span class="hljs-string">sendfile</span>        <span class="hljs-string">on;</span><span class="hljs-comment">#数据0拷贝</span><br>    <span class="hljs-string">keepalive_timeout</span>  <span class="hljs-number">65</span><span class="hljs-string">;</span><span class="hljs-comment">#与用户建立会话连接后，Nginx保持的时间</span><br>    <span class="hljs-string">server</span> &#123;<br>        <span class="hljs-string">listen</span>       <span class="hljs-number">80</span><span class="hljs-string">;</span><span class="hljs-comment">#监听端口</span><br>        <span class="hljs-string">server_name</span>  <span class="hljs-string">localhost;</span><span class="hljs-comment">#监听地址</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>            <span class="hljs-string">root</span>   <span class="hljs-string">html;</span><br>            <span class="hljs-string">index</span>  <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm;</span><br>        &#125;<br>        <span class="hljs-string">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  <span class="hljs-string">/50x.html;</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">=</span> <span class="hljs-string">/50x.html</span> &#123;<br>            <span class="hljs-string">root</span>   <span class="hljs-string">html;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3、安装Keepalived"><a href="#3、安装Keepalived" class="headerlink" title="3、安装Keepalived"></a>3、安装Keepalived</h3><p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。这里展示一下 Keepalived 的快速配置</p><p>1、安装 Keepalived 所需要的环境依赖</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">yum</span> <span class="hljs-string">-y</span> <span class="hljs-string">install</span> <span class="hljs-string">openssl-devel</span><br></code></pre></div></td></tr></table></figure><p>2、安装keepalived</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">yum</span> <span class="hljs-string">-y</span> <span class="hljs-string">install</span> <span class="hljs-string">keepalived</span><br></code></pre></div></td></tr></table></figure><p>3、进入配置文件，配置相应端口</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">/etc/keepalived/keepalived.conf</span><br></code></pre></div></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">!</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">File</span> <span class="hljs-string">for</span> <span class="hljs-string">keepalived</span><br><span class="hljs-comment">#我配置了两台虚拟机，两台均安装 Keepalived ，配置keepalived.conf文件</span><br><span class="hljs-string">global_defs</span> &#123;<br>    <span class="hljs-string">router_id</span> <span class="hljs-string">group1</span><span class="hljs-comment">#组名称 group1</span><br>&#125;<br><br><span class="hljs-string">vrrp_instance</span> <span class="hljs-string">baixxq</span> &#123;  <span class="hljs-comment">#一样</span><br>    <span class="hljs-string">state</span> <span class="hljs-string">MASTER</span> <span class="hljs-comment">#或者BACKUP，设置一个MASTER</span><br>    <span class="hljs-string">interface</span> <span class="hljs-string">ens33</span><span class="hljs-comment">#网卡名字</span><br>    <span class="hljs-string">virtual_router_id</span> <span class="hljs-number">51</span> <span class="hljs-comment">#一样</span><br>    <span class="hljs-string">priority</span> <span class="hljs-number">100</span><span class="hljs-comment">#权重</span><br>    <span class="hljs-string">advert_int</span> <span class="hljs-number">1</span>     <span class="hljs-comment">#一样</span><br>    <span class="hljs-string">authentication</span> &#123;     <span class="hljs-comment">#一样</span><br>        <span class="hljs-string">auth_type</span> <span class="hljs-string">PASS</span><br>        <span class="hljs-string">auth_pass</span> <span class="hljs-number">1111</span><br>    &#125;<br>    <span class="hljs-string">virtual_ipaddress</span> &#123;<br>        <span class="hljs-number">192.168</span><span class="hljs-number">.112</span><span class="hljs-number">.99</span><span class="hljs-comment">#你的代理的IP，keepalived会把这个IP给其中一台Nginx</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>4、启动服务</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">keepalived</span><br></code></pre></div></td></tr></table></figure><p>5、配置开机自启</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">keepalived.service</span><br></code></pre></div></td></tr></table></figure><h2 id="二、Nginx初级入门"><a href="#二、Nginx初级入门" class="headerlink" title="二、Nginx初级入门"></a>二、Nginx初级入门</h2><h3 id="1、Nginx目录结构"><a href="#1、Nginx目录结构" class="headerlink" title="1、Nginx目录结构"></a>1、Nginx目录结构</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">client_body_temp<span class="hljs-comment">//临时文件</span><br>logs proxy_temp<span class="hljs-comment">//临时文件</span><br>uwsgi_temp<span class="hljs-comment">//临时文件</span><br>fastcgi_temp<span class="hljs-comment">//临时文件</span><br>scgi_temp <span class="hljs-comment">//临时文件</span><br>conf<span class="hljs-comment">//用来存放配置文件相关</span><br>html<span class="hljs-comment">//用来存放静态文件的默认目录 html、css等</span><br>sbin<span class="hljs-comment">//nginx的主程序</span><br></code></pre></div></td></tr></table></figure><h3 id="2、Nginx配置文件详解"><a href="#2、Nginx配置文件详解" class="headerlink" title="2、Nginx配置文件详解"></a>2、Nginx配置文件详解</h3><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">########### 每个指令必须有分号结束。#################</span><br><span class="hljs-comment">#配置用户或者组，默认为user nobody nobody; user注释或配置成nobody的话所有用户都可以运行</span><br><span class="hljs-comment">#user [user] [group]; </span><br><span class="hljs-comment">#指定工作线程数，可以制定具体的进程数，也可使用自动模式 ，worker_processes number | auto；这种情况下会生成一个master进程和number个worker进程</span><br><span class="hljs-string">worker_processes</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>  <br><span class="hljs-comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="hljs-comment">#error_log log/error.log debug;  #制定日志路径级别</span><br><span class="hljs-string">events</span> &#123;<br>    <span class="hljs-comment">#accept_mutex on;  #设置网路连接序列化，防止多个进程对连接的争抢，默认为on</span><br>    <span class="hljs-comment">#multi_accept off;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br>    <span class="hljs-comment">#use epoll;      #事件驱动模型，有 select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br>    <span class="hljs-string">worker_connections</span>  <span class="hljs-number">1024</span><span class="hljs-string">;</span>    <span class="hljs-comment">#最大连接数，默认为512</span><br>&#125;<br><br><span class="hljs-comment">#HTTP块</span><br><span class="hljs-string">http</span> &#123;<br><span class="hljs-comment">#常用的浏览器中，可以显示的内容有HTML、XML、GIF及Flash等种类繁多的文本、媒体等资源，浏览器为区分这些资源，需要使用MIME Type。换言之，MIME Type是网络资源的媒体类型。Nginx服务器作为Web服务器，必须能够识别前端请求的资源类型。你可以加一个mp9 ，指定解析格式</span><br>    <span class="hljs-string">include</span>  <span class="hljs-string">mime.types;</span>   <span class="hljs-comment">#文件扩展名与文件类型映射表，mime.types和ngin.cfg同级目录，不同级的话需要指定具体路径</span><br>    <span class="hljs-string">default_type</span>  <span class="hljs-string">application/octet-stream;</span> <span class="hljs-comment">#默认文件类型，如果不加此指令，默认值为text/plain。在全局块中，我们介绍过errer_log指令，其用于配置Nginx进程运行时的日志存放和级别，此处所指的日志与常规的不同，它是指记录Nginx服务器提供服务过程应答前端请求的日志</span><br>    <span class="hljs-string">sendfile</span> <span class="hljs-string">on;</span>  <span class="hljs-comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块，这个高效网络传输，也就是数据0拷贝。开启后不用Nginx应用程序不用再读取，可以直接发送sendfile方式传输文件</span><br>    <span class="hljs-comment">#sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br>    <span class="hljs-comment">#keepalive_timeout 65;  #与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间，默认为75s，可以在http，server，location块。</span><br><span class="hljs-comment"># 下面配置的含义是，在服务器端保持连接的时间设置为120 s，发给用户端的应答报文头部中Keep-Alive域的超时时间设置为100 s。header_timeout，可选项，在应答报文头部的Keep-Alive域设置超时时间：</span><br><span class="hljs-comment"># keepalive_timeout 120s 100s</span><br><span class="hljs-comment"># Nginx服务器端和用户端建立会话连接后，用户端通过此连接发送请求。指令keepalive_requests用于限制用户通过某一连接向Nginx服务器发送请求的次数。默认是100</span><br><span class="hljs-comment"># keepalive_requests number; #配置单连接请求数上限，</span><br><br><span class="hljs-comment">#负载均衡配置</span><br>    <span class="hljs-string">upstream</span> <span class="hljs-string">mysvr</span> &#123;   <br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.121</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.122</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=2;</span><br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.123</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>    &#125;<br>    <span class="hljs-comment">#error_page 404 https://www.baidu.com; #错误页</span><br>    <br>    <span class="hljs-string">server</span> &#123;<br>        <span class="hljs-comment">#keepalive_requests 120; //#单连接请求上限次数。</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8000;</span>  <span class="hljs-comment">#只监听来自127.0.0.1这个IP，请求8000端口的请求</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">;</span> <span class="hljs-comment">#只监听来自127.0.0.1这个IP，请求80端口的请求（不指定端口，默认80）</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">8000</span><span class="hljs-string">;</span> <span class="hljs-comment">#监听来自所有IP，请求8000端口的请求</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-string">*:8000;</span> <span class="hljs-comment">#和上面效果一样</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-string">localhost:8000;</span> <span class="hljs-comment">#和第一种效</span><br>        <span class="hljs-string">listen</span>       <span class="hljs-number">80</span><span class="hljs-string">;</span>   <span class="hljs-comment">#监听端口</span><br><br>        <span class="hljs-string">server_name</span>  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">;</span>   <span class="hljs-comment">#监听地址  www.lovebai.fun     </span><br>        <span class="hljs-string">location</span>  <span class="hljs-string">~*^.+$</span> &#123;       <span class="hljs-comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br>           <span class="hljs-comment">#root path;  #根目录</span><br>           <span class="hljs-comment">#index vv.txt;  #设置默认页</span><br>           <span class="hljs-string">proxy_pass</span>  <span class="hljs-string">http://mysvr;</span>    <span class="hljs-string">//请求转向mysvr</span> <span class="hljs-string">定义的服务器列表</span><br>           <span class="hljs-comment">#deny 127.0.0.1;  #拒绝的ip</span><br>           <span class="hljs-comment">#allow 172.18.5.54; #允许的ip           </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参考链接 ： <a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">Nginx配置文件详解</a></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">//###########</span> <span class="hljs-string">每个指令必须有分号结束。#################</span><br><span class="hljs-string">//配置用户或者组，默认为user</span> <span class="hljs-string">nobody</span> <span class="hljs-string">nobody;</span>  <span class="hljs-string">将user指令注释掉，或者配置成nobody的话所有用户都可以运行</span><br><span class="hljs-comment">#user [user] [group]; </span><br><span class="hljs-string">//指定工作线程数，可以制定具体的进程数，也可使用自动模式</span> <span class="hljs-string">，worker_processes</span> <span class="hljs-string">number</span> <span class="hljs-string">|</span> <span class="hljs-string">auto；这种情况下会生成一个master进程和number个worker进程</span><br><span class="hljs-string">worker_processes</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>  <br><span class="hljs-comment">#pid /nginx/pid/nginx.pid;   //指定nginx进程运行文件存放地址</span><br><span class="hljs-string">//</span>  <span class="hljs-string">error_log</span> [<span class="hljs-string">path</span>] [<span class="hljs-string">debug</span> <span class="hljs-string">|</span> <span class="hljs-string">info</span> <span class="hljs-string">|</span> <span class="hljs-string">notice</span> <span class="hljs-string">|</span> <span class="hljs-string">warn</span> <span class="hljs-string">|</span> <span class="hljs-string">error</span> <span class="hljs-string">|</span> <span class="hljs-string">crit</span> <span class="hljs-string">|</span> <span class="hljs-string">alert</span> <span class="hljs-string">|</span> <span class="hljs-string">emerg</span>] <br><span class="hljs-comment">#error_log log/error.log debug;  //制定日志路径，级别。这个设置可以放入全局块，http块，server块,其中debug级别的日志需要编译时使用--with-debug开启debug开关</span><br><span class="hljs-string">events</span> &#123;<br><span class="hljs-string">//当某一时刻只有一个网络连接到来时，多个睡眠进程会被同时叫醒，但只有一个进程可获得连接。如果每次唤醒的进程数目太多，会影响一部分系统性能。在Nginx服务器的多进程下，就有可能出现这样的问题。</span><br>    <span class="hljs-comment">#accept_mutex on;  // #设置网路连接序列化，防止多个进程对连接的争抢，默认为on   , 可改为off</span><br>    <span class="hljs-comment">#multi_accept off;  //#设置一个进程是否同时接受多个网络连接，默认为off</span><br>    <span class="hljs-comment">#use epoll;      //#事件驱动模型，有 select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br>    <span class="hljs-string">worker_connections</span>  <span class="hljs-number">1024</span><span class="hljs-string">;</span>    <span class="hljs-comment">#最大连接数，默认为512</span><br>&#125;<br><br><span class="hljs-string">//HTTP块</span><br><span class="hljs-string">http</span> &#123;<br><span class="hljs-string">//常用的浏览器中，可以显示的内容有HTML、XML、GIF及Flash等种类繁多的文本、媒体等资源，浏览器为区分这些资源，需要使用MIME</span> <span class="hljs-string">Type。换言之，MIME</span> <span class="hljs-string">Type是网络资源的媒体类型。Nginx服务器作为Web服务器，必须能够识别前端请求的资源类型。你可以加一个mp9</span> <span class="hljs-string">，指定解析格式</span><br>    <span class="hljs-string">include</span>  <span class="hljs-string">mime.types;</span>   <span class="hljs-string">//#文件扩展名与文件类型映射表，mime.types和ngin.cfg同级目录，不同级的话需要指定具体路径</span><br>    <span class="hljs-string">default_type</span>  <span class="hljs-string">application/octet-stream;</span> <span class="hljs-string">//#默认文件类型，如果不加此指令，默认值为text/plain。</span><br><span class="hljs-string">//在全局块中，我们介绍过errer_log指令，其用于配置Nginx进程运行时的日志存放和级别，此处所指的日志与常规的不同，它是指记录Nginx服务器提供服务过程应答前端请求的日志</span><br>    <span class="hljs-comment">#access_log off; //#取消服务日志     access_log path [format [buffer=size]]</span><br>    <span class="hljs-comment">#log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; //#自定义格式 ，定义了上面的日志格式后，可以以下面的形式使用日志</span><br>    <span class="hljs-comment">#access_log log/access.log myFormat;  //#combined为日志格式的默认值</span><br><br>    <span class="hljs-string">sendfile</span> <span class="hljs-string">on;</span>  <span class="hljs-string">//</span> <span class="hljs-comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块，这个高效网络传输，也就是数据0拷贝。开启后不用Nginx应用程序不用再读取，可以直接发送sendfile方式传输文件</span><br>    <span class="hljs-comment">#sendfile_max_chunk 100k;  //#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br>    <span class="hljs-comment">#keepalive_timeout 65;  //与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间，默认为75s，可以在http，server，location块。</span><br><span class="hljs-string">//#</span> <span class="hljs-string">下面配置的含义是，在服务器端保持连接的时间设置为120</span> <span class="hljs-string">s，发给用户端的应答报文头部中Keep-Alive域的超时时间设置为100</span> <span class="hljs-string">s。header_timeout，可选项，在应答报文头部的Keep-Alive域设置超时时间：</span><br><span class="hljs-string">//#</span> <span class="hljs-string">keepalive_timeout</span> <span class="hljs-string">120s</span> <span class="hljs-string">100s</span><br><span class="hljs-string">//Nginx服务器端和用户端建立会话连接后，用户端通过此连接发送请求。指令keepalive_requests用于限制用户通过某一连接向Nginx服务器发送请求的次数。默认是100</span><br><span class="hljs-comment"># keepalive_requests number; //配置单连接请求数上限，</span><br><br><span class="hljs-string">//负载均衡配置</span><br>    <span class="hljs-string">upstream</span> <span class="hljs-string">mysvr</span> &#123;   <br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.121</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.122</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=2;</span><br>      <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.123</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>    &#125;<br>    <span class="hljs-comment">#error_page 404 https://www.baidu.com; #错误页</span><br>    <br>    <span class="hljs-string">server</span> &#123;<br>        <span class="hljs-comment">#keepalive_requests 120; //#单连接请求上限次数。</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8000;</span>  <span class="hljs-comment">#只监听来自127.0.0.1这个IP，请求8000端口的请求</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">;</span> <span class="hljs-comment">#只监听来自127.0.0.1这个IP，请求80端口的请求（不指定端口，默认80）</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-number">8000</span><span class="hljs-string">;</span> <span class="hljs-comment">#监听来自所有IP，请求8000端口的请求</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-string">*:8000;</span> <span class="hljs-comment">#和上面效果一样</span><br>        <span class="hljs-string">//listen</span> <span class="hljs-string">localhost:8000;</span> <span class="hljs-comment">#和第一种效</span><br>        <span class="hljs-string">listen</span>       <span class="hljs-number">80</span><span class="hljs-string">;</span>   <span class="hljs-string">//#监听端口</span><br><br>        <span class="hljs-string">server_name</span>  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">;</span>   <span class="hljs-string">//#监听地址</span>  <span class="hljs-string">www.lovebai.fun</span>     <br>        <span class="hljs-string">location</span>  <span class="hljs-string">~*^.+$</span> &#123;       <span class="hljs-comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br>           <span class="hljs-comment">#root path;  #根目录</span><br>           <span class="hljs-comment">#index vv.txt;  #设置默认页</span><br>           <span class="hljs-string">proxy_pass</span>  <span class="hljs-string">http://mysvr;</span>    <span class="hljs-string">//请求转向mysvr</span> <span class="hljs-string">定义的服务器列表</span><br>           <span class="hljs-comment">#deny 127.0.0.1;  #拒绝的ip</span><br>           <span class="hljs-comment">#allow 172.18.5.54; #允许的ip           </span><br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>例子</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">######Nginx配置文件nginx.conf中文详解#####</span><br><br><span class="hljs-comment">#定义Nginx运行的用户和用户组</span><br><span class="hljs-string">user</span> <span class="hljs-string">www</span> <span class="hljs-string">www;</span><br><br><span class="hljs-comment">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="hljs-string">worker_processes</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br> <br><span class="hljs-comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="hljs-string">error_log</span> <span class="hljs-string">/usr/local/nginx/logs/error.log</span> <span class="hljs-string">info;</span><br><br><span class="hljs-comment">#进程pid文件</span><br><span class="hljs-string">pid</span> <span class="hljs-string">/usr/local/nginx/logs/nginx.pid;</span><br><br><span class="hljs-comment">#指定进程可以打开的最大描述符：数目</span><br><span class="hljs-comment">#工作模式与连接数上限</span><br><span class="hljs-comment">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="hljs-comment">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span><br><span class="hljs-comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="hljs-string">worker_rlimit_nofile</span> <span class="hljs-number">65535</span><span class="hljs-string">;</span><br><br><br><span class="hljs-string">events</span><br>&#123;<br>    <span class="hljs-comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br>    <span class="hljs-comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br>    <span class="hljs-comment">#补充说明：</span><br>    <span class="hljs-comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br>    <span class="hljs-comment">#A）标准事件模型</span><br>    <span class="hljs-comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br>    <span class="hljs-comment">#B）高效事件模型</span><br>    <span class="hljs-comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br>    <span class="hljs-comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span><br>    <span class="hljs-comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br>    <span class="hljs-comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br>    <span class="hljs-string">use</span> <span class="hljs-string">epoll;</span><br><br>    <span class="hljs-comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span><br>    <span class="hljs-comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br>    <span class="hljs-string">worker_connections</span> <span class="hljs-number">65535</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#keepalive超时时间。</span><br>    <span class="hljs-string">keepalive_timeout</span> <span class="hljs-number">60</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br>    <span class="hljs-comment">#分页大小可以用命令getconf PAGESIZE 取得。</span><br>    <span class="hljs-comment">#[root@web001 ~]# getconf PAGESIZE</span><br>    <span class="hljs-comment">#4096</span><br>    <span class="hljs-comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br>    <span class="hljs-string">client_header_buffer_size</span> <span class="hljs-string">4k;</span><br><br>    <span class="hljs-comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br>    <span class="hljs-string">open_file_cache</span> <span class="hljs-string">max=65535</span> <span class="hljs-string">inactive=60s;</span><br><br>    <span class="hljs-comment">#这个是指多长时间检查一次缓存的有效信息。</span><br>    <span class="hljs-comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br>    <span class="hljs-string">open_file_cache_valid</span> <span class="hljs-string">80s;</span><br><br>    <span class="hljs-comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br>    <span class="hljs-comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br>    <span class="hljs-string">open_file_cache_min_uses</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    <br>    <span class="hljs-comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误.</span><br>    <span class="hljs-string">open_file_cache_errors</span> <span class="hljs-string">on;</span><br>&#125;<br> <br> <br> <br><span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="hljs-string">http</span><br>&#123;<br>    <span class="hljs-comment">#文件扩展名与文件类型映射表</span><br>    <span class="hljs-string">include</span> <span class="hljs-string">mime.types;</span><br><br>    <span class="hljs-comment">#默认文件类型</span><br>    <span class="hljs-string">default_type</span> <span class="hljs-string">application/octet-stream;</span><br><br>    <span class="hljs-comment">#默认编码</span><br>    <span class="hljs-comment">#charset utf-8;</span><br><br>    <span class="hljs-comment">#服务器名字的hash表大小</span><br>    <span class="hljs-comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br>    <span class="hljs-string">server_names_hash_bucket_size</span> <span class="hljs-number">128</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br>    <span class="hljs-string">client_header_buffer_size</span> <span class="hljs-string">32k;</span><br><br>    <span class="hljs-comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br>    <span class="hljs-string">large_client_header_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">64k;</span><br><br>    <span class="hljs-comment">#设定通过nginx上传文件的大小</span><br>    <span class="hljs-string">client_max_body_size</span> <span class="hljs-string">8m;</span><br><br>    <span class="hljs-comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br>    <span class="hljs-comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br>    <span class="hljs-string">sendfile</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#开启目录列表访问，合适下载服务器，默认关闭。</span><br>    <span class="hljs-string">autoindex</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br>    <span class="hljs-string">tcp_nopush</span> <span class="hljs-string">on;</span><br>     <br>    <span class="hljs-string">tcp_nodelay</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#长连接超时时间，单位是秒</span><br>    <span class="hljs-string">keepalive_timeout</span> <span class="hljs-number">120</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br>    <span class="hljs-string">fastcgi_connect_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_send_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_read_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_buffer_size</span> <span class="hljs-string">64k;</span><br>    <span class="hljs-string">fastcgi_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">64k;</span><br>    <span class="hljs-string">fastcgi_busy_buffers_size</span> <span class="hljs-string">128k;</span><br>    <span class="hljs-string">fastcgi_temp_file_write_size</span> <span class="hljs-string">128k;</span><br><br>    <span class="hljs-comment">#gzip模块设置</span><br>    <span class="hljs-string">gzip</span> <span class="hljs-string">on;</span> <span class="hljs-comment">#开启gzip压缩输出</span><br>    <span class="hljs-string">gzip_min_length</span> <span class="hljs-string">1k;</span>    <span class="hljs-comment">#最小压缩文件大小</span><br>    <span class="hljs-string">gzip_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">16k;</span>    <span class="hljs-comment">#压缩缓冲区</span><br>    <span class="hljs-string">gzip_http_version</span> <span class="hljs-number">1.0</span><span class="hljs-string">;</span>    <span class="hljs-comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br>    <span class="hljs-string">gzip_comp_level</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>    <span class="hljs-comment">#压缩等级</span><br>    <span class="hljs-string">gzip_types</span> <span class="hljs-string">text/plain</span> <span class="hljs-string">application/x-javascript</span> <span class="hljs-string">text/css</span> <span class="hljs-string">application/xml;</span>    <span class="hljs-comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br>    <span class="hljs-string">gzip_vary</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#开启限制IP连接数的时候需要使用</span><br>    <span class="hljs-comment">#limit_zone crawler $binary_remote_addr 10m;</span><br><br><br><br>    <span class="hljs-comment">#负载均衡配置</span><br>    <span class="hljs-string">upstream</span> <span class="hljs-string">jh.w3cschool.cn</span> &#123;<br>     <br>        <span class="hljs-comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.121</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.122</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=2;</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.123</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br><br>        <span class="hljs-comment">#nginx的upstream目前支持4种方式的分配</span><br>        <span class="hljs-comment">#1、轮询（默认）</span><br>        <span class="hljs-comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br>        <span class="hljs-comment">#2、weight</span><br>        <span class="hljs-comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br>        <span class="hljs-comment">#例如：</span><br>        <span class="hljs-comment">#upstream bakend &#123;</span><br>        <span class="hljs-comment">#    server 192.168.0.14 weight=10;</span><br>        <span class="hljs-comment">#    server 192.168.0.15 weight=10;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#2、ip_hash</span><br>        <span class="hljs-comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br>        <span class="hljs-comment">#例如：</span><br>        <span class="hljs-comment">#upstream bakend &#123;</span><br>        <span class="hljs-comment">#    ip_hash;</span><br>        <span class="hljs-comment">#    server 192.168.0.14:88;</span><br>        <span class="hljs-comment">#    server 192.168.0.15:80;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#3、fair（第三方）</span><br>        <span class="hljs-comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br>        <span class="hljs-comment">#upstream backend &#123;</span><br>        <span class="hljs-comment">#    server server1;</span><br>        <span class="hljs-comment">#    server server2;</span><br>        <span class="hljs-comment">#    fair;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#4、url_hash（第三方）</span><br>        <span class="hljs-comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br>        <span class="hljs-comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br>        <span class="hljs-comment">#upstream backend &#123;</span><br>        <span class="hljs-comment">#    server squid1:3128;</span><br>        <span class="hljs-comment">#    server squid2:3128;</span><br>        <span class="hljs-comment">#    hash $request_uri;</span><br>        <span class="hljs-comment">#    hash_method crc32;</span><br>        <span class="hljs-comment">#&#125;</span><br><br>        <span class="hljs-comment">#tips:</span><br>        <span class="hljs-comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br>        <span class="hljs-comment">#    ip_hash;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:9090 down;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:8080 weight=2;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:6060;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:7070 backup;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><br>        <span class="hljs-comment">#每个设备的状态设置为:</span><br>        <span class="hljs-comment">#1.down表示单前的server暂时不参与负载</span><br>        <span class="hljs-comment">#2.weight为weight越大，负载的权重就越大。</span><br>        <span class="hljs-comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br>        <span class="hljs-comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span><br>        <span class="hljs-comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><br>        <span class="hljs-comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br>        <span class="hljs-comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br>        <span class="hljs-comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br>        <span class="hljs-comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br>    &#125;<br>     <br>     <br>     <br>    <span class="hljs-comment">#虚拟主机的配置</span><br>    <span class="hljs-string">server</span><br>    &#123;<br>        <span class="hljs-comment">#监听端口</span><br>        <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span><br><br>        <span class="hljs-comment">#域名可以有多个，用空格隔开</span><br>        <span class="hljs-string">server_name</span> <span class="hljs-string">www.w3cschool.cn</span> <span class="hljs-string">w3cschool.cn;</span><br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm</span> <span class="hljs-string">index.php;</span><br>        <span class="hljs-string">root</span> <span class="hljs-string">/data/www/w3cschool;</span><br><br>        <span class="hljs-comment">#对******进行负载均衡</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(php|php5)?$</span><br>        &#123;<br>            <span class="hljs-string">fastcgi_pass</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9000;</span><br>            <span class="hljs-string">fastcgi_index</span> <span class="hljs-string">index.php;</span><br>            <span class="hljs-string">include</span> <span class="hljs-string">fastcgi.conf;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#图片缓存时间设置</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(gif|jpg|jpeg|png|bmp|swf)$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">10d;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#JS和CSS缓存时间设置</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(js|css)?$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">1h;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#日志格式设定</span><br>        <span class="hljs-comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br>        <span class="hljs-comment">#$remote_user：用来记录客户端用户名称；</span><br>        <span class="hljs-comment">#$time_local： 用来记录访问时间与时区；</span><br>        <span class="hljs-comment">#$request： 用来记录请求的url与http协议；</span><br>        <span class="hljs-comment">#$status： 用来记录请求状态；成功是200，</span><br>        <span class="hljs-comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br>        <span class="hljs-comment">#$http_referer：用来记录从那个页面链接访问过来的；</span><br>        <span class="hljs-comment">#$http_user_agent：记录客户浏览器的相关信息；</span><br>        <span class="hljs-comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br>        <span class="hljs-string">log_format</span> <span class="hljs-string">access</span> <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>        <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>        <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;</span><span class="hljs-string">;</span><br>         <br>        <span class="hljs-comment">#定义本虚拟主机的访问日志</span><br>        <span class="hljs-string">access_log</span>  <span class="hljs-string">/usr/local/nginx/logs/host.access.log</span>  <span class="hljs-string">main;</span><br>        <span class="hljs-string">access_log</span>  <span class="hljs-string">/usr/local/nginx/logs/host.access.404.log</span>  <span class="hljs-string">log404;</span><br>         <br>        <span class="hljs-comment">#对 &quot;/&quot; 启用反向代理</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>            <span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://127.0.0.1:88;</span><br>            <span class="hljs-string">proxy_redirect</span> <span class="hljs-string">off;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Real-IP</span> <span class="hljs-string">$remote_addr;</span><br>             <br>            <span class="hljs-comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For</span> <span class="hljs-string">$proxy_add_x_forwarded_for;</span><br>             <br>            <span class="hljs-comment">#以下是一些反向代理的配置，可选。</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">Host</span> <span class="hljs-string">$host;</span><br><br>            <span class="hljs-comment">#允许客户端请求的最大单文件字节数</span><br>            <span class="hljs-string">client_max_body_size</span> <span class="hljs-string">10m;</span><br><br>            <span class="hljs-comment">#缓冲区代理缓冲用户端请求的最大字节数，</span><br>            <span class="hljs-comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br>            <span class="hljs-comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br>            <span class="hljs-string">client_body_buffer_size</span> <span class="hljs-string">128k;</span><br><br>            <span class="hljs-comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br>            <span class="hljs-string">proxy_intercept_errors</span> <span class="hljs-string">on;</span><br><br>            <span class="hljs-comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span><br>            <span class="hljs-comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br>            <span class="hljs-string">proxy_connect_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#后端服务器数据回传时间(代理发送超时)</span><br>            <span class="hljs-comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br>            <span class="hljs-string">proxy_send_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#连接成功后，后端服务器响应时间(代理接收超时)</span><br>            <span class="hljs-comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br>            <span class="hljs-string">proxy_read_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br>            <span class="hljs-comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br>            <span class="hljs-string">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br><br>            <span class="hljs-comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span><br>            <span class="hljs-comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br>            <span class="hljs-string">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">32k;</span><br><br>            <span class="hljs-comment">#高负荷下缓冲大小（proxy_buffers*2）</span><br>            <span class="hljs-string">proxy_busy_buffers_size</span> <span class="hljs-string">64k;</span><br><br>            <span class="hljs-comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br>            <span class="hljs-comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br>            <span class="hljs-string">proxy_temp_file_write_size</span> <span class="hljs-string">64k;</span><br>        &#125;<br>         <br>         <br>        <span class="hljs-comment">#设定查看Nginx状态的地址</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">/NginxStatus</span> &#123;<br>            <span class="hljs-string">stub_status</span> <span class="hljs-string">on;</span><br>            <span class="hljs-string">access_log</span> <span class="hljs-string">on;</span><br>            <span class="hljs-string">auth_basic</span> <span class="hljs-string">&quot;NginxStatus&quot;</span><span class="hljs-string">;</span><br>            <span class="hljs-string">auth_basic_user_file</span> <span class="hljs-string">confpasswd;</span><br>            <span class="hljs-comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#本地动静分离反向代理配置</span><br>        <span class="hljs-comment">#所有jsp的页面均交由tomcat或resin处理</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.(jsp|jspx|do)?$</span> &#123;<br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">Host</span> <span class="hljs-string">$host;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Real-IP</span> <span class="hljs-string">$remote_addr;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For</span> <span class="hljs-string">$proxy_add_x_forwarded_for;</span><br>            <span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://127.0.0.1:8080;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#所有静态文件由nginx直接读取不经过tomcat或resin</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br>        <span class="hljs-string">pdf|xls|mp3|wma)$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">15d;</span> <br>        &#125;<br>         <br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(js|css)?$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">1h;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">######Nginx配置文件nginx.conf中文详解#####</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
